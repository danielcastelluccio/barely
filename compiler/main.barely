declare empty: any_8;

declare cached_sizes_map: HashMap;
declare cached_signedness_map: HashMap;

define main = function(arguments: **, argument_count: whole_8) {
    println("Parsing...");

    cached_sizes_map = hashmap_new(131072);
    cached_signedness_map = hashmap_new(131072);
    while_target_id_stack = autobuffer_stack8_new(64);

    declare tokens = Tokens.new();

    declare output_file = "output";
    declare format = "";
    declare instruction_set = "";
    declare target_os = "";

    // In the future, there should be a better way of translating these into strings
    #compile_if(target, linux, target_os = "linux";);
    #compile_if(instruction_set, x86_64, instruction_set = "x86_64";);
    #compile_if(format, elf, format = "elf";);
    #compile_if(format, macho, format = "macho";);

    declare flags = hashmap_new(32);

    declare i = 1;
    while <(i, argument_count) {
        declare pointer = *.cast(array8_get(arguments, i));

        if string=(pointer, "--output") {
            output_file = *.cast(array8_get(arguments, +(i, 1)));
            
            i = +(i, 2);
        } else if string=(pointer, "--target") {
            declare target = *.cast(array8_get(arguments, +(i, 1)));
            format = substring_brk_allocate(target, 0, first_index(target, ASCII.COLON));
            instruction_set = substring_brk_allocate(target, +(first_index(target, ASCII.COLON), 1), nth_index(target, ASCII.COLON, 1));
            target_os = +(target, +(nth_index(target, ASCII.COLON, 1), 1));

            i = +(i, 2);
        } else if string_length=(pointer, "--", 2) {
            hashmap_string_put(&(flags), +(pointer, 2), *.cast(array8_get(arguments, +(i, 1))));

            i = +(i, 2);
        } else {
            include_file(pointer, &(tokens));
            i = +(i, 1);
        };
    };

    hashmap_string_put(&(flags), "format", format);
    hashmap_string_put(&(flags), "instruction_set", instruction_set);
    hashmap_string_put(&(flags), "target", target_os);

    if =(length(format), 0) {
        println("No output format specified!");
        exit(1);
    };

    declare output_instruction_set = if string=(instruction_set, "x86_64") {
        Target_X86_64.get_functions()
    } else {
        Target_X86_64.get_functions()
    };

    declare output_format = if string=(format, "elf") {
        Target_Elf.output:*function[*Nodes,ProgramData,*,*,InstructionSetFunctions:]
    } else if string=(format, "macho") {
        Target_Macho.output:*function[*Nodes,ProgramData,*,*,InstructionSetFunctions:]
    } else {
        print("Invalid output format '");
        print(format);
        println("'");
        exit(1);
        // temporary
        Target_Elf.output:*function[*Nodes,ProgramData,*,*,InstructionSetFunctions:]
    };

    declare tokens_expanded = Tokens.new();
    expand_macros(&(tokens), &(tokens_expanded), &(flags));

    declare nodes = nodes_new();
    parse(&(tokens_expanded), &(nodes));

    add_basic_internals(&(nodes));
    add_used_any_types(&(nodes));
    add_structure_functions(&(nodes));
    add_internal_functions(&(nodes));

    println("Processing...");
    declare program_data = process(&(nodes), InstructionSetFunctions.>get_size(&(output_instruction_set)));

    println("Outputting...");
    output_format(&(nodes), program_data, target_os, output_file, output_instruction_set);
};

define add_internal_functions = function(nodes: *Nodes) {
    declare function_arguments = create_size_one_array8_brk_allocate("whole_8");
    declare function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall0", function_arguments, function_returns);

    declare function_arguments = create_size_two_array8_brk_allocate("whole_8", "any_8");
    declare function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall1", function_arguments, function_returns);

    declare function_arguments = create_size_three_array8_brk_allocate("whole_8", "any_8", "any_8");
    declare function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall2", function_arguments, function_returns);

    declare function_arguments = create_size_four_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8");
    declare function_returns2 = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall3", function_arguments, function_returns);

    declare function_arguments = create_size_five_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8", "any_8");
    declare function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall4", function_arguments, function_returns);

    declare function_arguments = create_size_six_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8", "any_8", "any_8");
    declare function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall5", function_arguments, function_returns);

    declare function_arguments = create_size_seven_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8", "any_8", "any_8", "any_8");
    declare function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall6", function_arguments, function_returns);
};

define add_structure_functions = function(nodes: *Nodes) {
    declare nodes_index_saved = Nodes.>index(nodes);
    declare i = 0;

    declare module_id = 0;
    declare module_stack = autobuffer_stack8_new(32);

    while <(i, nodes_index_saved) {
        declare id = nodes_get_id(nodes, i);
        if =(id, NODE_MODULE) {
            declare module_data = nodes_get_id(nodes, i);
            autobuffer_stack8_push(&(module_stack), module_id);
            module_id = +(module_id, 1);
        } else if =(id, NODE_ENDMODULE) {
            declare _ = autobuffer_stack8_pop(&(module_stack));
        } else if =(nodes_get_id(nodes, i), NODE_STRUCTURE) {
            declare pointer = NodeStructureData.pcast(nodes_get_pointer_data(nodes, i));
            declare name = NodeStructureData.>name(pointer);
            declare is_internal = NodeStructureData.>is_internal(pointer);

            if =(name, 0) {
                declare define_data = NodeDefineData.pcast(nodes_get_pointer_data(nodes, -(i, 1)));
                name = NodeDefineData.>name(define_data);
            };

            if >(AutoBufferStack8.>index(&(module_stack)), 0) {
                declare module_id_buffer = any_16.>0();
                whole_8_to_string(whole_8.cast(autobuffer_stack8_peek(&(module_stack))), &(module_id_buffer));
                name = concatenate2_brk_allocate(&(module_id_buffer), name);
            };

            declare pointer_name = concatenate2_brk_allocate("*", name);

            // Setter for whole value
            declare function_name = concatenate2_brk_allocate(name, "<");
            declare function_arguments = create_size_two_array8_brk_allocate(pointer_name, name);
            declare function_returns = create_size_zero_array8_brk_allocate();
            nodes_append_function(nodes, function_name, function_arguments, function_returns);

            // Setter for whole value with reversed inputs
            declare function_name = concatenate2_brk_allocate(name, "<2");
            declare function_arguments = create_size_two_array8_brk_allocate(name, pointer_name);
            declare function_returns = create_size_zero_array8_brk_allocate();
            nodes_append_function(nodes, function_name, function_arguments, function_returns);

            // Getter for whole value
            declare function_name = concatenate2_brk_allocate(name, ">");
            declare function_arguments = create_size_one_array8_brk_allocate(pointer_name);
            declare function_returns = create_size_one_array8_brk_allocate(name);
            nodes_append_function(nodes, function_name, function_arguments, function_returns);

            // Zero initializer for whole value
            declare function_name = concatenate2_brk_allocate(name, ">0");
            declare function_arguments = create_size_zero_array8_brk_allocate();
            declare function_returns = create_size_one_array8_brk_allocate(name);
            nodes_append_function(nodes, function_name, function_arguments, function_returns);

            // Size getter for the whole value
            declare function_name = concatenate2_brk_allocate(name, "size");
            declare function_arguments = create_size_zero_array8_brk_allocate();
            declare function_returns = create_size_one_array8_brk_allocate("whole_8");
            nodes_append_function(nodes, function_name, function_arguments, function_returns);

            declare item_names = NodeStructureData.>item_names(pointer);
            declare item_types = NodeStructureData.>item_types(pointer);

            declare j = 0;
            while !(=(array8_get(item_names, j), 0)) {
                declare item_name = *.cast(array8_get(item_names, j));
                declare item_type = *.cast(array8_get(item_types, j));

                // Setter for an individual member
                declare function_name = concatenate3_brk_allocate(name, "<", item_name);
                declare function_arguments = create_size_two_array8_brk_allocate(pointer_name, item_type);
                declare function_returns = brk_allocate(8);
                nodes_append_function(nodes, function_name, function_arguments, function_returns);

                // Setter for an individual member with reversed inputs
                declare function_name = concatenate3_brk_allocate(name, "<2", item_name);
                declare function_arguments = create_size_two_array8_brk_allocate(item_type, pointer_name);
                declare function_returns = brk_allocate(8);
                nodes_append_function(nodes, function_name, function_arguments, function_returns);

                // Getter for individual members
                declare function_name = concatenate3_brk_allocate(name, ">", item_name);
                declare function_arguments = create_size_one_array8_brk_allocate(pointer_name);
                declare function_returns = create_size_one_array8_brk_allocate(item_type);
                nodes_append_function(nodes, function_name, function_arguments, function_returns);

                // Pointer Getter for individual members
                declare function_name = concatenate3_brk_allocate(name, "*>", item_name);
                declare function_arguments = create_size_one_array8_brk_allocate(pointer_name);
                declare function_returns = create_size_one_array8_brk_allocate(concatenate2_brk_allocate("*", item_type));
                nodes_append_function(nodes, function_name, function_arguments, function_returns);

                j = +(j, 1);
            };
        };
        i = +(i, 1);
    };
};

define add_used_any_types = function(nodes: *Nodes) {
    declare already_added_types = autobuffer_new(64);
    declare already_added_types_index = 0;

    declare nodes_index_saved = Nodes.>index(nodes);
    declare i = 0;
    while <(i, nodes_index_saved) {
        declare id = nodes_get_id(nodes, i);
    
        if =(id, NODE_RETRIEVE) {
            declare retrieve_data = NodeRetrieveData.pcast(nodes_get_pointer_data(nodes, i));
            declare name = NodeRetrieveData.>name_single(retrieve_data);
            if string_length=(name, "any_", 4) {
                declare added = false;
                declare j = 0;
                while <(j, already_added_types_index) {
                    if string=(*.cast(autobuffer_array8_get(&(already_added_types), j)), name) {
                        added = true;
                    };
                    j = +(j, 1);
                };

                if !(added) {
                    nodes_append_structure_any(nodes, name);
                    autobuffer_stack8_legacy_push(&(already_added_types), &(already_added_types_index), name);
                };
            };
        };

        i = +(i, 1);
    };

};

define add_basic_internals = function(nodes: *Nodes) {
    nodes_append_structure(nodes, "boolean", 1);
    nodes_append_structure(nodes, "whole_8", 8);
    nodes_append_structure(nodes, "whole_4", 4);
    nodes_append_structure(nodes, "whole_2", 2);
    nodes_append_structure(nodes, "whole_1", 1);
    nodes_append_structure(nodes, "integer_8", 8);
    nodes_append_structure(nodes, "integer_4", 4);
    nodes_append_structure(nodes, "integer_2", 2);
    nodes_append_structure(nodes, "integer_1", 1);
    nodes_append_structure(nodes, "*", 8);
    nodes_append_structure(nodes, "**", 8);

    // The internal functions that have simple argument types. ('+', which supports different sizes, is not simple)
    declare function_arguments = create_size_one_array8_brk_allocate("boolean");
    declare function_returns = create_size_one_array8_brk_allocate("boolean");
    nodes_append_function(nodes, "!", function_arguments, function_returns);

    declare function_arguments = create_size_two_array8_brk_allocate("boolean", "boolean");
    declare function_returns = create_size_one_array8_brk_allocate("boolean");
    nodes_append_function(nodes, "&&", function_arguments, function_returns);
    nodes_append_function(nodes, "|", function_arguments, function_returns);
};

define include_file = function(file_name: *, tokens: *Tokens.Tokens) {
    declare contents = get_contents(file_name);

    tokenize(file_name, contents, tokens);
};

define get_contents = function(name: *): * {
    declare size = get_file_size(name);
    declare contents = brk_allocate(+(size, 1));

    read_file_to_buffer(name, contents, size);

    return contents;
};
