define empty = global(any_8);

define cached_sizes_map = global(HashMap);
define cached_signedness_map = global(HashMap);

define main = function(arguments: **, argument_count: whole_8) {
    println("Parsing...");

    cached_sizes_map = hashmap_new(131072);
    cached_signedness_map = hashmap_new(131072);
    while_target_id_stack = autobuffer_stack8_new(64);

    variable output_file = "output";
    variable format = "";
    variable instruction_set = "";
    variable target_os = "";

    variable flags = hashmap_new(32);

    variable i = 1;
    while <(i, argument_count) {
        variable pointer = *.cast(array8_get(arguments, i));

        if string=(pointer, "--output") {
            output_file = *.cast(array8_get(arguments, +(i, 1)));
            
            i = +(i, 2);
        } else if string=(pointer, "--target") {
            variable target = *.cast(array8_get(arguments, +(i, 1)));
            format = substring_brk_allocate(target, 0, first_index(target, 58_whole_1));
            instruction_set = substring_brk_allocate(target, +(first_index(target, 58_whole_1), 1), nth_index(target, 58_whole_1, 1));
            target_os = +(target, +(nth_index(target, 58_whole_1, 1), 1));
            hashmap_string_put(&(flags), "target", target_os);

            i = +(i, 2);
        } else if string_length=(pointer, "--", 2) {
            hashmap_string_put(&(flags), +(pointer, 2), *.cast(array8_get(arguments, +(i, 1))));

            i = +(i, 2);
        } else {
            i = +(i, 1);
        };
    };

    if =(length(format), 0) {
        println("No output format specified!");
        exit(1);
    };

    variable output_instruction_set = if string=(instruction_set, "x86_64") {
        Target/X86_64.get_functions()
    } else {
        Target/X86_64.get_functions()
    };

    variable output_format = if string=(format, "elf") {
        Target/Elf.output:*function[*Nodes,ProgramData,*,*,InstructionSetFunctions:]
    } else if string=(format, "macho") {
        Target/Macho.output:*function[*Nodes,ProgramData,*,*,InstructionSetFunctions:]
    } else {
        // temporary
        Target/Elf.output:*function[*Nodes,ProgramData,*,*,InstructionSetFunctions:]
    };

    variable tokens = tokens_new();

    variable i = 1;
    while <(i, argument_count) {
        variable pointer = *.cast(array8_get(arguments, i));

        if string_length=(pointer, "--", 2) {
            i = +(i, 2);
        } else {
            include_file(pointer, &(tokens));

            i = +(i, 1);
        };
    };

    variable nodes = nodes_new();

    variable tokens_expanded = tokens_new();
    expand_macros(&(tokens), &(tokens_expanded), &(flags));

    parse(&(tokens_expanded), &(nodes));

    add_basic_internals(&(nodes));
    add_used_any_types(&(nodes));
    add_structure_pseudo_functions(&(nodes));
    add_internal_functions(&(nodes));

    println("Processing...");
    expand_modules(&(nodes));

    variable program_data = process(&(nodes), InstructionSetFunctions.>get_size(&(output_instruction_set)));

    println("Outputting...");
    output_format(&(nodes), program_data, target_os, output_file, output_instruction_set);
};

// First go through and correlate module ids with the names to access them ("0Foo" -> 1) (Foo module inside of "Test" module 0)
// Modify stuff to reflect the modules with their number forms
define expand_modules = function(nodes: *Nodes) {
    variable module_stack = autobuffer_stack8_new(32);
    variable module_id_map = hashmap_new(64);
    variable module_references_map = hashmap_new(64);
    variable current_module_id = 0;
    variable i = 0;
    while <(i, Nodes.>index(nodes)) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_DEFINE) {
            variable define_data = NodeDefineData.*cast(pointer_data);
            variable define_name = NodeDefineData.>name(define_data);
            variable define_type = NodeDefineData.>type(define_data);

            variable name = NodeDefineData.>name(define_data);
            if >(AutoBufferStack8.>index(&(module_stack)), 0) {
                variable top_module = whole_8.cast(autobuffer_stack8_peek(&(module_stack)));
                variable top_module_string = any_16.>0();
                whole_8_to_string(top_module, &(top_module_string));

                name = concatenate2_brk_allocate(&(top_module_string), name);
            };

            if string=(define_type, "module") {
                hashmap_string_put(&(module_id_map), name, current_module_id);

                autobuffer_stack8_push(&(module_stack), current_module_id);
                current_module_id = +(current_module_id, 1);
            } else if string=(define_type, "define") {
                variable full_define = "";
                variable j = +(i, 1);
                while =(nodes_get_id(nodes, j), NODE_RETRIEVE) {
                    j = +(j, 1);
                };

                j = -(j, 1);

                while >(j, i) {
                    variable retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, j));
                    variable retrieve_name = NodeRetrieveData.>name(retrieve_data);
                    if string=(retrieve_name, "@current_module") {
                        variable top_module = whole_8.cast(autobuffer_stack8_peek(&(module_stack)));
                        variable top_module_string = any_16.>0();
                        whole_8_to_string(top_module, &(top_module_string));

                        full_define = concatenate2_brk_allocate(full_define, &(top_module_string));
                    } else {
                        full_define = concatenate3_brk_allocate(full_define, retrieve_name, ".");
                    };

                    j = -(j, 1);
                };
                full_define = substring_brk_allocate(full_define, 0, -(length(full_define), 1));
                hashmap_string_put(&(module_references_map), name, full_define);
            };
        } else if =(id, NODE_ENDDEFINE) {
            variable define_data = NodeEndDefineData.*cast(pointer_data);

            if !(=(NodeEndDefineData.>type(define_data), 0)) {
                if string=(NodeEndDefineData.>type(define_data), "module") {
                    variable _ = autobuffer_stack8_pop(&(module_stack));
                };
            };
        };

        i = +(i, 1);
    };

    variable current_module_id = 0;
    variable module_stack = autobuffer_stack8_new(32);
    variable i = 0;
    while <(i, Nodes.>index(nodes)) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            variable function_data = NodeFunctionData.*cast(pointer_data);
            variable argument_types = NodeFunctionData.>argument_types(function_data);

            variable j = 0;
            while <(j, array8_length(argument_types)) {
                variable argument_type = *.cast(array8_get(argument_types, j));
                array8_set(argument_types, j, expand_module_name(argument_type, &(module_id_map), &(module_references_map), &(module_stack)));
                j = +(j, 1);
            };

            if =(nodes_get_id(nodes, -(i, 1)), NODE_DEFINE) {
                variable define_data = NodeDefineData.*cast(nodes_get_pointer_data(nodes, -(i, 1)));

                // I feel like there should be a better way to do this.
                // Possibly the define type could be set after doing this computation?
                NodeDefineData.<type(define_data, get_function_string_type(function_data));
            };
        } else if =(id, NODE_DECLARE) {
            variable declare_data = NodeDeclareData.*cast(pointer_data);
            variable declare_type = NodeDeclareData.>type(declare_data);
            NodeDeclareData.<type(declare_data, expand_module_name(declare_type, &(module_id_map), &(module_references_map), &(module_stack)));
        } else if =(id, NODE_RETRIEVE) {
            variable retrieve_data = NodeRetrieveData.*cast(pointer_data);
            variable retrieve_name = NodeRetrieveData.>name(retrieve_data);

            if NodeRetrieveData.>using_module(retrieve_data) {
                variable index_stack = autobuffer_stack8_new(16);

                variable module_stack2 = autobuffer_stack8_new(16);
                variable running = true;
                variable j = +(i, 1);
                while running {
                    variable node_id = nodes_get_id(nodes, j);
                    variable node_pointer_data = nodes_get_pointer_data(nodes, j);

                    if =(node_id, NODE_SKIP) {
                    } else if =(node_id, NODE_RETRIEVE) {
                        variable retrieve_data2 = NodeRetrieveData.*cast(node_pointer_data);

                        if NodeRetrieveData.>is_module(retrieve_data2) {
                            autobuffer_stack8_push(&(module_stack2), NodeRetrieveData.>name(retrieve_data2));
                            autobuffer_stack8_push(&(index_stack), j);
                        } else {
                            running = false;
                        };
                    } else {
                        running = false;
                    };

                    j = +(j, 1);
                };

                variable full_name = "";
                while >(AutoBufferStack8.>index(&(module_stack2)), 0) {
                    variable module_name = *.cast(autobuffer_stack8_pop(&(module_stack2)));
                    full_name = concatenate3_brk_allocate(full_name, module_name, ".");
                };

                full_name = concatenate2_brk_allocate(full_name, retrieve_name);

                while >(AutoBufferStack8.>index(&(index_stack)), 0) {
                    variable index = whole_8.cast(autobuffer_stack8_pop(&(index_stack)));
                    nodes_set_skip(nodes, index);
                };

                NodeRetrieveData.<name(retrieve_data, expand_module_name(full_name, &(module_id_map), &(module_references_map), &(module_stack)));
            };
        } else if =(id, NODE_DEFINE) {
            variable define_data = NodeDefineData.*cast(pointer_data);

            if string=(NodeDefineData.>type(define_data), "module") {
                autobuffer_stack8_push(&(module_stack), current_module_id);
                current_module_id = +(current_module_id, 1);
            };
        } else if =(id, NODE_ENDDEFINE) {
            variable define_data = NodeEndDefineData.*cast(pointer_data);

            if !(=(NodeEndDefineData.>type(define_data), 0)) {
                if string=(NodeEndDefineData.>type(define_data), "module") {
                    variable _ = autobuffer_stack8_pop(&(module_stack));
                };
            };
        };

        i = +(i, 1);
    };
};

define expand_module_name = function(name_in: *, module_id_map: *HashMap, module_references_map: *HashMap, module_stack: *AutoBufferStack8): * {
    variable name = name_in;
    variable pointer_count = 0;
    while =(any_1.>(any_1.*cast(+(name, pointer_count))), ASCII_ASTERISK) {
         pointer_count = +(pointer_count, 1);
    };

    name = +(name, pointer_count);

    variable current_module_id = 999;
    variable buffer = autobuffer_buffer_new(8);
    variable i = 0;
    while <(i, length(name)) {
        variable character = any_1.>(any_1.*cast(+(name, i)));
        if =(character, ASCII_PERIOD) {
            variable current_module = autobuffer_buffer_get_buffer_pointer(&(buffer));

            variable new_id = if string=(current_module, "@current_module") {
                whole_8.cast(autobuffer_stack8_peek(module_stack))
            } else if =(current_module_id, 999) {
                variable temp_id = whole_8.cast(hashmap_string_get2(module_id_map, current_module));

                if =(temp_id, 999) {
                    variable temp_name = *.cast(hashmap_string_get2(module_references_map, current_module));
                    temp_name = expand_module_name(temp_name, module_id_map, module_references_map, module_stack);
                    temp_id = whole_8.cast(hashmap_string_get2(module_id_map, temp_name));
                };
                temp_id
            } else {
                variable current_module_id_string = any_16.>0();
                whole_8_to_string(current_module_id, &(current_module_id_string));

                variable current_module_full = concatenate2_brk_allocate(&(current_module_id_string), current_module);
                variable temp_id = whole_8.cast(hashmap_string_get2(module_id_map, current_module_full));

                if =(temp_id, 999) {
                    variable temp_name = *.cast(hashmap_string_get2(module_references_map, current_module_full));
                    temp_name = expand_module_name(temp_name, module_id_map, module_references_map, module_stack);
                    temp_id = whole_8.cast(hashmap_string_get2(module_id_map, temp_name));
                };
                temp_id
            };

            current_module_id = new_id;

            autobuffer_buffer_reset(&(buffer));
        } else {
            autobuffer_buffer_push_whole_1(&(buffer), whole_1.cast(character));
        };
        i = +(i, 1);
    };

    if !(=(current_module_id, 999)) {
        variable current_module_id_string = any_16.>0();
        whole_8_to_string(current_module_id, &(current_module_id_string));
        name = concatenate2_brk_allocate(&(current_module_id_string), autobuffer_buffer_get_buffer_pointer(&(buffer)));
    };

    variable possible_reference = *.cast(hashmap_string_get2(module_references_map, name));
    if !(=(possible_reference, 999)) {
        name = expand_module_name(possible_reference, module_id_map, module_references_map, module_stack);
    };

    variable i = 0;
    while <(i, pointer_count) {
        name = concatenate2_brk_allocate("*", name);
        i = +(i, 1);
    };

    return name;
};

define add_internal_functions = function(nodes: *Nodes) {
    variable function_arguments = create_size_one_array8_brk_allocate("whole_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall0", function_arguments, function_returns);

    variable function_arguments = create_size_two_array8_brk_allocate("whole_8", "any_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall1", function_arguments, function_returns);

    variable function_arguments = create_size_three_array8_brk_allocate("whole_8", "any_8", "any_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall2", function_arguments, function_returns);

    variable function_arguments = create_size_four_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8");
    variable function_returns2 = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall3", function_arguments, function_returns);

    variable function_arguments = create_size_five_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8", "any_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall4", function_arguments, function_returns);

    variable function_arguments = create_size_six_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8", "any_8", "any_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall5", function_arguments, function_returns);

    variable function_arguments = create_size_seven_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8", "any_8", "any_8", "any_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall6", function_arguments, function_returns);
};

define add_structure_pseudo_functions = function(nodes: *Nodes) {
    variable nodes_index_saved = Nodes.>index(nodes);
    variable i = 0;

    variable module_id = 0;
    variable module_stack = autobuffer_stack8_new(32);

    while <(i, nodes_index_saved) {
        variable id = nodes_get_id(nodes, i);
        if =(id, NODE_MODULE) {
            variable module_data = nodes_get_id(nodes, i);
            //print_node_info(nodes, -(i, 1));
            autobuffer_stack8_push(&(module_stack), module_id);
            module_id = +(module_id, 1);
        } else if =(id, NODE_ENDMODULE) {
            variable _ = autobuffer_stack8_pop(&(module_stack));
        } else if =(nodes_get_id(nodes, i), NODE_STRUCTURE) {
            variable pointer = NodeStructureData.*cast(nodes_get_pointer_data(nodes, i));
            variable name = NodeStructureData.>name(pointer);
            variable is_internal = NodeStructureData.>is_internal(pointer);

            if |(=(name, 0), is_internal) {
                if =(name, 0) {
                    variable define_data = NodeDefineData.*cast(nodes_get_pointer_data(nodes, -(i, 1)));
                    name = NodeDefineData.>name(define_data);
                };

                if >(AutoBufferStack8.>index(&(module_stack)), 0) {
                    variable module_id_buffer = any_16.>0();
                    whole_8_to_string(whole_8.cast(autobuffer_stack8_peek(&(module_stack))), &(module_id_buffer));
                    name = concatenate2_brk_allocate(&(module_id_buffer), name);
                };

                variable pointer_name = concatenate2_brk_allocate("*", name);

                // Setter for whole value
                variable function_name = concatenate2_brk_allocate(name, "<");
                variable function_arguments = create_size_two_array8_brk_allocate(pointer_name, name);
                variable function_returns = create_size_zero_array8_brk_allocate();
                nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                // Getter for whole value
                variable function_name = concatenate2_brk_allocate(name, ">");
                variable function_arguments = create_size_one_array8_brk_allocate(pointer_name);
                variable function_returns = create_size_one_array8_brk_allocate(name);
                nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                // Zero initializer for whole value
                variable function_name = concatenate2_brk_allocate(name, ">0");
                variable function_arguments = create_size_zero_array8_brk_allocate();
                variable function_returns = create_size_one_array8_brk_allocate(name);
                nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                // Size getter for the whole value
                variable function_name = concatenate2_brk_allocate(name, "size");
                variable function_arguments = create_size_zero_array8_brk_allocate();
                variable function_returns = create_size_one_array8_brk_allocate("whole_8");
                nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                variable item_names = NodeStructureData.>item_names(pointer);
                variable item_types = NodeStructureData.>item_types(pointer);

                variable j = 0;
                while !(=(array8_get(item_names, j), 0)) {
                    variable item_name = *.cast(array8_get(item_names, j));
                    variable item_type = *.cast(array8_get(item_types, j));

                    // Setter for an individual member
                    variable function_name = concatenate3_brk_allocate(name, "<", item_name);
                    variable function_arguments = create_size_two_array8_brk_allocate(pointer_name, item_type);
                    variable function_returns = brk_allocate(8);
                    nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                    // Getter for individual members
                    variable function_name = concatenate3_brk_allocate(name, ">", item_name);
                    variable function_arguments = create_size_one_array8_brk_allocate(pointer_name);
                    variable function_returns = create_size_one_array8_brk_allocate(item_type);
                    nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                    // Pointer Getter for individual members
                    variable function_name = concatenate3_brk_allocate(name, "*>", item_name);
                    variable function_arguments = create_size_one_array8_brk_allocate(pointer_name);
                    variable function_returns = create_size_one_array8_brk_allocate(concatenate2_brk_allocate("*", item_type));
                    nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                    j = +(j, 1);
                };
            };
        };
        i = +(i, 1);
    };
};

define add_used_any_types = function(nodes: *Nodes) {
    variable already_added_types = autobuffer_new(64);
    variable already_added_types_index = 0;

    variable nodes_index_saved = Nodes.>index(nodes);
    variable i = 0;
    while <(i, nodes_index_saved) {
        variable id = nodes_get_id(nodes, i);
    
        if =(id, NODE_INVOKE) {
            variable invoke_data = NodeInvokeData.*cast(nodes_get_pointer_data(nodes, i));
            variable name = NodeInvokeData.>name(invoke_data);
            variable has_specifier = NodeInvokeData.>has_specifier(invoke_data);

            if &&(has_specifier, !(=(name, 0))) {
                if |(string_length=(name, ">", 1), string_length=(name, "<", 1)) {
                    variable previous_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(i, 1)));
                    variable previous_name = NodeRetrieveData.>name(previous_data);

                    if string_length=(previous_name, "any_", 4) {
                        variable added = false;
                        variable j = 0;
                        while <(j, already_added_types_index) {
                            if string=(*.cast(autobuffer_array8_get(&(already_added_types), j)), previous_name) {
                                added = true;
                            };
                            j = +(j, 1);
                        };

                        if !(added) {
                            nodes_append_structure_any(nodes, previous_name);
                            autobuffer_stack8_legacy_push(&(already_added_types), &(already_added_types_index), previous_name);
                        };
                    };
                };
            };
        };

         i = +(i, 1);
    };

};

define get_structure_string_type = function(pointer: *NodeStructureData): * {
    variable main_name_buffer = autobuffer_buffer_new(16);

    autobuffer_buffer_push_string(&(main_name_buffer), "structure[");

    variable items = NodeStructureData.>item_types(pointer);
    variable item_names = NodeStructureData.>item_names(pointer);

    variable j = 0;
    while !(=(array8_get(items, j), 0)) {
        autobuffer_buffer_push_string(&(main_name_buffer), *.cast(array8_get(item_names, j)));
        autobuffer_buffer_push_string(&(main_name_buffer), ":");
        autobuffer_buffer_push_string(&(main_name_buffer), *.cast(array8_get(items, j)));
        autobuffer_buffer_push_string(&(main_name_buffer), ",");
        j = +(j, 1);
    };

    AutoBufferBuffer.<index(&(main_name_buffer), -(AutoBufferBuffer.>index(&(main_name_buffer)), 1));
    autobuffer_buffer_push_string(&(main_name_buffer), "]");

    return autobuffer_buffer_get_buffer_pointer(&(main_name_buffer));
};

define get_function_string_type = function(pointer: *NodeFunctionData): * {
    variable main_name_buffer = autobuffer_buffer_new(16);

    autobuffer_buffer_push_string(&(main_name_buffer), "*function[");

    variable arguments = NodeFunctionData.>argument_types(pointer);
    variable returns = NodeFunctionData.>returns(pointer);

    variable j = 0;
    while !(=(array8_get(arguments, j), 0)) {
        autobuffer_buffer_push_string(&(main_name_buffer), *.cast(array8_get(arguments, j)));
        autobuffer_buffer_push_string(&(main_name_buffer), ",");
        j = +(j, 1);
    };

    if >(j, 0) {
        AutoBufferBuffer.<index(&(main_name_buffer), -(AutoBufferBuffer.>index(&(main_name_buffer)), 1));
    };
    autobuffer_buffer_push_string(&(main_name_buffer), ":");

    variable j = 0;
    while !(=(array8_get(returns, j), 0)) {
        autobuffer_buffer_push_string(&(main_name_buffer), *.cast(array8_get(returns, j)));
        autobuffer_buffer_push_string(&(main_name_buffer), ",");
        j = +(j, 1);
    };

    if >(j, 0) {
        AutoBufferBuffer.<index(&(main_name_buffer), -(AutoBufferBuffer.>index(&(main_name_buffer)), 1));
    };
    autobuffer_buffer_push_string(&(main_name_buffer), "]");

    return autobuffer_buffer_get_buffer_pointer(&(main_name_buffer));
};

define Nodes = structure {
    buffer: AutoBuffer;
    index: whole_8;
};

define nodes_new = function(): Nodes {
    variable nodes: Nodes;

    Nodes.<buffer(&(nodes), autobuffer_new(131072));
    Nodes.<index(&(nodes), 0);

    return nodes;
};

define add_basic_internals = function(nodes: *Nodes) {
    nodes_append_structure(nodes, "boolean", "any_1");
    nodes_append_structure(nodes, "whole_8", "any_8");
    nodes_append_structure(nodes, "whole_4", "any_4");
    nodes_append_structure(nodes, "whole_2", "any_2");
    nodes_append_structure(nodes, "whole_1", "any_1");
    nodes_append_structure(nodes, "integer_8", "any_8");
    nodes_append_structure(nodes, "integer_4", "any_4");
    nodes_append_structure(nodes, "integer_2", "any_2");
    nodes_append_structure(nodes, "integer_1", "any_1");
    nodes_append_structure(nodes, "*", "any_8");
    nodes_append_structure(nodes, "**", "any_8");

    // Just the internal functions that don't have more advanced argument types. (like '+' which supports different sizes)
    variable function_arguments = create_size_one_array8_brk_allocate("boolean");
    variable function_returns = create_size_one_array8_brk_allocate("boolean");
    nodes_append_function(nodes, "!", function_arguments, function_returns);

    variable function_arguments = create_size_two_array8_brk_allocate("boolean", "boolean");
    variable function_returns = create_size_one_array8_brk_allocate("boolean");
    nodes_append_function(nodes, "&&", function_arguments, function_returns);
    nodes_append_function(nodes, "|", function_arguments, function_returns);
};

define Tokens = structure {
    buffer: AutoBuffer;
    index: whole_8;
};

define tokens_new = function(): Tokens {
    variable tokens: Tokens;

    Tokens.<buffer(&(tokens), autobuffer_new(131072));
    Tokens.<index(&(tokens), 0);

    return tokens;
};

define include_file = function(file_name: *, tokens: *Tokens) {
    variable contents = get_contents(file_name);

    tokenize(file_name, contents, tokens);
};

define get_contents = function(name: *): * {
    variable size = get_file_size(name);
    variable contents = brk_allocate(+(size, 1));

    read_file_to_buffer(name, contents, size);

    return contents;
};
