define empty = global(any_8);

define cached_sizes_map = global(HashMap);
define cached_signedness_map = global(HashMap);

define main = function(arguments: **, argument_count: whole_8) {
    println("Parsing...");

    cached_sizes_map = hashmap_new(131072);
    cached_signedness_map = hashmap_new(131072);
    while_target_id_stack = autobuffer_stack8_new(64);

    variable tokens = tokens_new();

    variable output_file = "output";
    variable format = "";
    variable instruction_set = "";
    variable target_os = "";

    variable flags = hashmap_new(32);

    variable i = 1;
    while <(i, argument_count) {
        variable pointer = *.cast(array8_get(arguments, i));

        if string=(pointer, "--output") {
            output_file = *.cast(array8_get(arguments, +(i, 1)));
            
            i = +(i, 2);
        } else if string=(pointer, "--target") {
            variable target = *.cast(array8_get(arguments, +(i, 1)));
            format = substring_brk_allocate(target, 0, first_index(target, ASCII.COLON));
            instruction_set = substring_brk_allocate(target, +(first_index(target, ASCII.COLON), 1), nth_index(target, ASCII.COLON, 1));
            target_os = +(target, +(nth_index(target, ASCII.COLON, 1), 1));
            hashmap_string_put(&(flags), "target", target_os);

            i = +(i, 2);
        } else if string_length=(pointer, "--", 2) {
            hashmap_string_put(&(flags), +(pointer, 2), *.cast(array8_get(arguments, +(i, 1))));

            i = +(i, 2);
        } else {
            include_file(pointer, &(tokens));
            i = +(i, 1);
        };
    };

    if =(length(format), 0) {
        println("No output format specified!");
        exit(1);
    };

    variable output_instruction_set = if string=(instruction_set, "x86_64") {
        Target/X86_64.get_functions()
    } else {
        Target/X86_64.get_functions()
    };

    variable output_format = if string=(format, "elf") {
        Target/Elf.output:*function[*Nodes,ProgramData,*,*,InstructionSetFunctions:]
    } else if string=(format, "macho") {
        Target/Macho.output:*function[*Nodes,ProgramData,*,*,InstructionSetFunctions:]
    } else {
        print("Invalid output format '");
        print(format);
        println("'");
        exit(1);
        // temporary
        Target/Elf.output:*function[*Nodes,ProgramData,*,*,InstructionSetFunctions:]
    };

    variable tokens_expanded = tokens_new();
    expand_macros(&(tokens), &(tokens_expanded), &(flags));

    variable nodes = nodes_new();
    parse(&(tokens_expanded), &(nodes));

    add_basic_internals(&(nodes));
    add_used_any_types(&(nodes));
    add_structure_functions(&(nodes));
    add_internal_functions(&(nodes));

    println("Processing...");
    variable program_data = process(&(nodes), InstructionSetFunctions.>get_size(&(output_instruction_set)));

    println("Outputting...");
    output_format(&(nodes), program_data, target_os, output_file, output_instruction_set);
};

define add_internal_functions = function(nodes: *Nodes) {
    variable function_arguments = create_size_one_array8_brk_allocate("whole_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall0", function_arguments, function_returns);

    variable function_arguments = create_size_two_array8_brk_allocate("whole_8", "any_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall1", function_arguments, function_returns);

    variable function_arguments = create_size_three_array8_brk_allocate("whole_8", "any_8", "any_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall2", function_arguments, function_returns);

    variable function_arguments = create_size_four_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8");
    variable function_returns2 = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall3", function_arguments, function_returns);

    variable function_arguments = create_size_five_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8", "any_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall4", function_arguments, function_returns);

    variable function_arguments = create_size_six_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8", "any_8", "any_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall5", function_arguments, function_returns);

    variable function_arguments = create_size_seven_array8_brk_allocate("whole_8", "any_8", "any_8", "any_8", "any_8", "any_8", "any_8");
    variable function_returns = create_size_one_array8_brk_allocate("any_8");
    nodes_append_function(nodes, "@syscall6", function_arguments, function_returns);
};

define add_structure_functions = function(nodes: *Nodes) {
    variable nodes_index_saved = Nodes.>index(nodes);
    variable i = 0;

    variable module_id = 0;
    variable module_stack = autobuffer_stack8_new(32);

    while <(i, nodes_index_saved) {
        variable id = nodes_get_id(nodes, i);
        if =(id, NODE_MODULE) {
            variable module_data = nodes_get_id(nodes, i);
            autobuffer_stack8_push(&(module_stack), module_id);
            module_id = +(module_id, 1);
        } else if =(id, NODE_ENDMODULE) {
            variable _ = autobuffer_stack8_pop(&(module_stack));
        } else if =(nodes_get_id(nodes, i), NODE_STRUCTURE) {
            variable pointer = NodeStructureData.*cast(nodes_get_pointer_data(nodes, i));
            variable name = NodeStructureData.>name(pointer);
            variable is_internal = NodeStructureData.>is_internal(pointer);

            if =(name, 0) {
                variable define_data = NodeDefineData.*cast(nodes_get_pointer_data(nodes, -(i, 1)));
                name = NodeDefineData.>name(define_data);
            };

            if >(AutoBufferStack8.>index(&(module_stack)), 0) {
                variable module_id_buffer = any_16.>0();
                whole_8_to_string(whole_8.cast(autobuffer_stack8_peek(&(module_stack))), &(module_id_buffer));
                name = concatenate2_brk_allocate(&(module_id_buffer), name);
            };

            variable pointer_name = concatenate2_brk_allocate("*", name);

            // Setter for whole value
            variable function_name = concatenate2_brk_allocate(name, "<");
            variable function_arguments = create_size_two_array8_brk_allocate(pointer_name, name);
            variable function_returns = create_size_zero_array8_brk_allocate();
            nodes_append_function(nodes, function_name, function_arguments, function_returns);

            // Getter for whole value
            variable function_name = concatenate2_brk_allocate(name, ">");
            variable function_arguments = create_size_one_array8_brk_allocate(pointer_name);
            variable function_returns = create_size_one_array8_brk_allocate(name);
            nodes_append_function(nodes, function_name, function_arguments, function_returns);

            // Zero initializer for whole value
            variable function_name = concatenate2_brk_allocate(name, ">0");
            variable function_arguments = create_size_zero_array8_brk_allocate();
            variable function_returns = create_size_one_array8_brk_allocate(name);
            nodes_append_function(nodes, function_name, function_arguments, function_returns);

            // Size getter for the whole value
            variable function_name = concatenate2_brk_allocate(name, "size");
            variable function_arguments = create_size_zero_array8_brk_allocate();
            variable function_returns = create_size_one_array8_brk_allocate("whole_8");
            nodes_append_function(nodes, function_name, function_arguments, function_returns);

            variable item_names = NodeStructureData.>item_names(pointer);
            variable item_types = NodeStructureData.>item_types(pointer);

            variable j = 0;
            while !(=(array8_get(item_names, j), 0)) {
                variable item_name = *.cast(array8_get(item_names, j));
                variable item_type = *.cast(array8_get(item_types, j));

                // Setter for an individual member
                variable function_name = concatenate3_brk_allocate(name, "<", item_name);
                variable function_arguments = create_size_two_array8_brk_allocate(pointer_name, item_type);
                variable function_returns = brk_allocate(8);
                nodes_append_function(nodes, function_name, function_arguments, function_returns);

                // Getter for individual members
                variable function_name = concatenate3_brk_allocate(name, ">", item_name);
                variable function_arguments = create_size_one_array8_brk_allocate(pointer_name);
                variable function_returns = create_size_one_array8_brk_allocate(item_type);
                nodes_append_function(nodes, function_name, function_arguments, function_returns);

                // Pointer Getter for individual members
                variable function_name = concatenate3_brk_allocate(name, "*>", item_name);
                variable function_arguments = create_size_one_array8_brk_allocate(pointer_name);
                variable function_returns = create_size_one_array8_brk_allocate(concatenate2_brk_allocate("*", item_type));
                nodes_append_function(nodes, function_name, function_arguments, function_returns);

                j = +(j, 1);
            };
        };
        i = +(i, 1);
    };
};

define add_used_any_types = function(nodes: *Nodes) {
    variable already_added_types = autobuffer_new(64);
    variable already_added_types_index = 0;

    variable nodes_index_saved = Nodes.>index(nodes);
    variable i = 0;
    while <(i, nodes_index_saved) {
        variable id = nodes_get_id(nodes, i);
    
        if =(id, NODE_INVOKE_INTERNAL) {
            variable invoke_data = NodeInvokeInternalData.*cast(nodes_get_pointer_data(nodes, i));
            variable names = NodeInvokeInternalData.>name(invoke_data);
            variable name_first = *.cast(array8_get(names, 0));
            if &&(>(array8_length(names), 1), string_length=(name_first, "any_", 4)) {
                variable added = false;
                variable j = 0;
                while <(j, already_added_types_index) {
                    if string=(*.cast(autobuffer_array8_get(&(already_added_types), j)), name_first) {
                        added = true;
                    };
                    j = +(j, 1);
                };

                if !(added) {
                    nodes_append_structure_any(nodes, name_first);
                    autobuffer_stack8_legacy_push(&(already_added_types), &(already_added_types_index), name_first);
                };
            };
        };

        i = +(i, 1);
    };

};

define add_basic_internals = function(nodes: *Nodes) {
    nodes_append_structure(nodes, "boolean", 1);
    nodes_append_structure(nodes, "whole_8", 8);
    nodes_append_structure(nodes, "whole_4", 4);
    nodes_append_structure(nodes, "whole_2", 2);
    nodes_append_structure(nodes, "whole_1", 1);
    nodes_append_structure(nodes, "integer_8", 8);
    nodes_append_structure(nodes, "integer_4", 4);
    nodes_append_structure(nodes, "integer_2", 2);
    nodes_append_structure(nodes, "integer_1", 1);
    nodes_append_structure(nodes, "*", 8);
    nodes_append_structure(nodes, "**", 8);

    // The internal functions that have simple argument types. ('+', which supports different sizes, is not simple)
    variable function_arguments = create_size_one_array8_brk_allocate("boolean");
    variable function_returns = create_size_one_array8_brk_allocate("boolean");
    nodes_append_function(nodes, "!", function_arguments, function_returns);

    variable function_arguments = create_size_two_array8_brk_allocate("boolean", "boolean");
    variable function_returns = create_size_one_array8_brk_allocate("boolean");
    nodes_append_function(nodes, "&&", function_arguments, function_returns);
    nodes_append_function(nodes, "|", function_arguments, function_returns);
};

define include_file = function(file_name: *, tokens: *Tokens) {
    variable contents = get_contents(file_name);

    tokenize(file_name, contents, tokens);
};

define get_contents = function(name: *): * {
    variable size = get_file_size(name);
    variable contents = brk_allocate(+(size, 1));

    read_file_to_buffer(name, contents, size);

    return contents;
};
