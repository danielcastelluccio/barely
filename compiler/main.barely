define empty = global(any_8);

define cached_sizes_map = global(HashMap);
define cached_signedness_map = global(HashMap);

define main = function(arguments: **, argument_count: whole_8) {
    println("Parsing...");

    variable nodes = nodes_new();

    // hardcoded because it's the only platform we current support
    variable current_platform = "linux";
    variable add_target_internal_functions, is_target_internal_function = if string=(current_platform, "linux") {
        add_internal_functions_linux_x86-64, is_internal_function_linux_x86-64
    };

    cached_sizes_map = hashmap_new(131072);
    cached_signedness_map = hashmap_new(131072);
    while_target_id_stack = autobuffer_stack8_new(64);

    variable output_file = "output";

    variable i = 1;
    while <(i, argument_count) {
        variable pointer = *.cast(array8_get(arguments, i));

        if string=(pointer, "--output") {
            output_file = *.cast(array8_get(arguments, +(i, 1)));
            
            i = +(i, 2);
        } else {
            include_file(pointer, &(nodes), is_target_internal_function);

            i = +(i, 1);
        };

    };

    add_basic_internals(&(nodes));
    add_used_any_types(&(nodes));
    add_structure_pseudo_functions(&(nodes));
    add_target_internal_functions(&(nodes));

    println("Checking...");
    variable program_data = process(&(nodes));

    println("Outputting...");
    output_linux_x86-64_elf(&(nodes), program_data, output_file);
};

define add_structure_pseudo_functions = function(nodes: *Nodes) {
    variable nodes_index_saved = Nodes.>index(nodes);
    variable i = 0;
    while <(i, nodes_index_saved) {
        if =(nodes_get_id(nodes, i), NODE_STRUCTURE) {
            variable pointer = NodeStructureData.*cast(nodes_get_pointer_data(nodes, i));
            variable name = NodeStructureData.>name(pointer);
            variable is_internal = NodeStructureData.>is_internal(pointer);

            if |(=(name, 0), is_internal) {
                if =(name, 0) {
                    name = get_structure_string_type(pointer);
                };

                variable pointer_name = concatenate2_brk_allocate("*", name);

                // Setter for whole value
                variable function_name = concatenate2_brk_allocate(name, "<");
                variable function_arguments = create_size_two_array8_brk_allocate(pointer_name, name);
                variable function_returns = create_size_zero_array8_brk_allocate();
                nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                // Getter for whole value
                variable function_name = concatenate2_brk_allocate(name, ">");
                variable function_arguments = create_size_one_array8_brk_allocate(pointer_name);
                variable function_returns = create_size_one_array8_brk_allocate(name);
                nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                // Zero initializer for whole value
                variable function_name = concatenate2_brk_allocate(name, ">0");
                variable function_arguments = create_size_zero_array8_brk_allocate();
                variable function_returns = create_size_one_array8_brk_allocate(name);
                nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                variable item_names = NodeStructureData.>item_names(pointer);
                variable item_types = NodeStructureData.>item_types(pointer);

                variable j = 0;
                while !(=(array8_get(item_names, j), 0)) {
                    variable item_name = *.cast(array8_get(item_names, j));
                    variable item_type = *.cast(array8_get(item_types, j));

                    // Setter for an individual member
                    variable function_name = concatenate3_brk_allocate(name, "<", item_name);
                    variable function_arguments = create_size_two_array8_brk_allocate(pointer_name, item_type);
                    variable function_returns = brk_allocate(8);
                    nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                    // Getter for individual members
                    variable function_name = concatenate3_brk_allocate(name, ">", item_name);
                    variable function_arguments = create_size_one_array8_brk_allocate(pointer_name);
                    variable function_returns = create_size_one_array8_brk_allocate(item_type);
                    nodes_append_pseudo_function(nodes, function_name, function_arguments, function_returns);

                    j = +(j, 1);
                };
            };
        };
        i = +(i, 1);
    };
};

define add_used_any_types = function(nodes: *Nodes) {
    variable already_added_types = autobuffer_new(64);
    variable already_added_types_index = 0;

    variable nodes_index_saved = Nodes.>index(nodes);
    variable i = 0;
    while <(i, nodes_index_saved) {
        variable id = nodes_get_id(nodes, i);
    
        if =(id, NODE_INVOKE) {
            variable invoke_data = NodeInvokeData.*cast(nodes_get_pointer_data(nodes, i));
            variable name = NodeInvokeData.>name(invoke_data);
            variable has_specifier = NodeInvokeData.>has_specifier(invoke_data);

            if &&(has_specifier, !(=(name, 0))) {
                if |(string_length=(name, ">", 1), string_length=(name, "<", 1)) {
                    variable previous_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(i, 1)));
                    variable previous_name = NodeRetrieveData.>name(previous_data);

                    if string_length=(previous_name, "any_", 4) {
                        variable added = false;
                        variable j = 0;
                        while <(j, already_added_types_index) {
                            if string=(*.cast(autobuffer_array8_get(&(already_added_types), j)), previous_name) {
                                added = true;
                            };
                            j = +(j, 1);
                        };

                        if !(added) {
                            nodes_append_structure_any(nodes, previous_name);
                            autobuffer_stack8_legacy_push(&(already_added_types), &(already_added_types_index), previous_name);
                        };
                    };
                };
            };
        };

         i = +(i, 1);
    };

};

define get_structure_string_type = function(pointer: *NodeStructureData): * {
    variable main_name_buffer = autobuffer_buffer_new(16);

    autobuffer_buffer_push_string(&(main_name_buffer), "structure[");

    variable items = NodeStructureData.>item_types(pointer);
    variable item_names = NodeStructureData.>item_names(pointer);

    variable j = 0;
    while !(=(array8_get(items, j), 0)) {
        autobuffer_buffer_push_string(&(main_name_buffer), *.cast(array8_get(item_names, j)));
        autobuffer_buffer_push_string(&(main_name_buffer), ":");
        autobuffer_buffer_push_string(&(main_name_buffer), *.cast(array8_get(items, j)));
        autobuffer_buffer_push_string(&(main_name_buffer), ",");
        j = +(j, 1);
    };

    AutoBufferBuffer.<index(&(main_name_buffer), -(AutoBufferBuffer.>index(&(main_name_buffer)), 1));
    autobuffer_buffer_push_string(&(main_name_buffer), "]");

    return autobuffer_buffer_get_buffer_pointer(&(main_name_buffer));
};

define Nodes = structure {
    buffer: AutoBuffer;
    index: whole_8;
};

define nodes_new = function(): Nodes {
    variable nodes: Nodes;

    Nodes.<buffer(&(nodes), autobuffer_new(131072));
    Nodes.<index(&(nodes), 0);

    return nodes;
};

define add_basic_internals = function(nodes: *Nodes) {
    nodes_append_structure(nodes, "boolean", "any_1");
    nodes_append_structure(nodes, "whole_8", "any_8");
    nodes_append_structure(nodes, "whole_4", "any_4");
    nodes_append_structure(nodes, "whole_2", "any_2");
    nodes_append_structure(nodes, "whole_1", "any_1");
    nodes_append_structure(nodes, "integer_8", "any_8");
    nodes_append_structure(nodes, "integer_4", "any_4");
    nodes_append_structure(nodes, "integer_2", "any_2");
    nodes_append_structure(nodes, "integer_1", "any_1");
    nodes_append_structure(nodes, "*", "any_8");
    nodes_append_structure(nodes, "**", "any_8");

    // Just the internal functions that don't have more advanced argument types. (like '+' which supports different sizes)
    variable function_arguments = create_size_one_array8_brk_allocate("boolean");
    variable function_returns = create_size_one_array8_brk_allocate("boolean");
    nodes_append_function(nodes, "!", function_arguments, function_returns);

    variable function_arguments = create_size_two_array8_brk_allocate("boolean", "boolean");
    variable function_returns = create_size_one_array8_brk_allocate("boolean");
    nodes_append_function(nodes, "&&", function_arguments, function_returns);
    nodes_append_function(nodes, "|", function_arguments, function_returns);
};

define Tokens = structure {
    buffer: AutoBuffer;
    index: whole_8;
};

define tokens_new = function(): Tokens {
    variable tokens: Tokens;

    Tokens.<buffer(&(tokens), autobuffer_new(131072));
    Tokens.<index(&(tokens), 0);

    return tokens;
};

define include_file = function(file_name: *, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable nodes_index = &(Nodes.>index(nodes));
    variable tokens = tokens_new();

    variable contents = get_contents(file_name);

    tokenize(file_name, contents, &(tokens));

    variable previous_index = whole_8.>(nodes_index);

    parse(&(tokens), nodes, is_target_internal_function);
};

define get_contents = function(name: *): * {
    variable descriptor = sys_open(name, O_RDONLY, 0);

    variable stat: Stat;
    sys_fstat(descriptor, &(stat));

    variable contents = brk_allocate(+(Stat.>size(&(stat)), 1));

    sys_read(descriptor, contents, Stat.>size(&(stat)));

    return contents;
};
