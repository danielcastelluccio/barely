global target_id: integer;

function main(arguments: **, argument_count: integer) {
    variable i = 1;

    variable tokens = autobuffer_new(131072);
    variable tokens_index = 0;

    variable allocator: BumpAllocator;

    variable main_name: *;

    while <(i, argument_count) {
        variable pointer = @cast_*(*8(@cast_*(+(arguments, *(8, i)))));

        if =(i, 1) {
            main_name = pointer;
        };

        variable contents = get_contents(pointer);

        tokenize(contents, &(tokens), &(tokens_index), &(allocator));

        i = @cast_integer(+(i, 1));
    };

    variable nodes = autobuffer_new(131072);
    variable nodes_index = 0;

    variable empty: any_8;

    variable integer_structure = append_node(&(nodes), &(nodes_index), NODE_STRUCTURE);
    *<-(@cast_**(+(integer_structure, 8)), "integer");
    *<-(@cast_**(+(integer_structure, 16)), &(empty));
    *<-(@cast_**(+(integer_structure, 24)), &(empty));

    println("Parsing...");

    parse(&(tokens), tokens_index, &(nodes), &(nodes_index), &(allocator));

    variable nodes_index_saved = nodes_index;
    variable i = 0;
    while <(i, nodes_index_saved) {
        if =(nodes_get_id2(&(nodes), i), NODE_STRUCTURE) {
            variable name = *->(@cast_**(+(nodes_get_pointer2(&(nodes), i), 8)));

            // Setter for whole value
            variable allocated = bump_allocate(&(allocator), integer+(length(name), 3));
            copy(name, allocated, length(name));
            copy("<-", @cast_*(+(allocated, length(name))), 2);

            variable allocated_pointer = bump_allocate(&(allocator), integer+(length(name), 2));
            copy("*", allocated_pointer, 1);
            copy(name, @cast_*(+(allocated_pointer, 1)), length(name));

            variable allocated_arguments = bump_allocate(&(allocator), 24);
            array8_set(allocated_arguments, 0, allocated_pointer);
            array8_set(allocated_arguments, 1, name);

            variable allocated_returns = bump_allocate(&(allocator), 8);

            variable pointer_store_node = append_node(&(nodes), &(nodes_index), NODE_FUNCTION);
            *<-(@cast_**(+(pointer_store_node, 8)), allocated);
            *<-(@cast_**(+(pointer_store_node, 16)), @cast_*(0));
            *<-(@cast_**(+(pointer_store_node, 24)), allocated_arguments);
            *<-(@cast_**(+(pointer_store_node, 32)), allocated_returns);

            variable end_node = append_node(&(nodes), &(nodes_index), NODE_ENDFUNCTION);

            // Getter for whole value
            variable allocated = bump_allocate(&(allocator), integer+(length(name), 3));
            copy(name, allocated, length(name));
            copy("->", @cast_*(+(allocated, length(name))), 2);

            variable allocated_arguments = bump_allocate(&(allocator), 16);
            array8_set(allocated_arguments, 0, allocated_pointer);

            variable allocated_returns = bump_allocate(&(allocator), 16);
            array8_set(allocated_returns, 0, name);

            variable pointer_store_node = append_node(&(nodes), &(nodes_index), NODE_FUNCTION);
            *<-(@cast_**(+(pointer_store_node, 8)), allocated);
            *<-(@cast_**(+(pointer_store_node, 16)), @cast_*(0));
            *<-(@cast_**(+(pointer_store_node, 24)), allocated_arguments);
            *<-(@cast_**(+(pointer_store_node, 32)), allocated_returns);

            variable end_node = append_node(&(nodes), &(nodes_index), NODE_ENDFUNCTION);


            variable member_names = *->(@cast_**(+(nodes_get_pointer2(&(nodes), i), 16)));
            variable member_types = *->(@cast_**(+(nodes_get_pointer2(&(nodes), i), 24)));

            variable j = 0;
            while !(=(array8_get(member_names, j), 0)) {
                variable member_name = @cast_*(array8_get(member_names, j));
                variable member_type = @cast_*(array8_get(member_types, j));

                // Setter for individual members
                variable allocated = bump_allocate(&(allocator), integer+(length(name), integer+(length(member_name), 3)));
                copy(name, allocated, length(name));
                copy("<-", @cast_*(+(allocated, length(name))), 2);
                copy(member_name, @cast_*(+(allocated, +(length(name), 2))), length(member_name));

                variable allocated_arguments = bump_allocate(&(allocator), 24);
                array8_set(allocated_arguments, 0, allocated_pointer);
                array8_set(allocated_arguments, 1, member_type);

                variable allocated_returns = bump_allocate(&(allocator), 8);

                variable member_store_node = append_node(&(nodes), &(nodes_index), NODE_FUNCTION);
                *<-(@cast_**(+(member_store_node, 8)), allocated);
                *<-(@cast_**(+(member_store_node, 16)), @cast_*(0));
                *<-(@cast_**(+(member_store_node, 24)), allocated_arguments);
                *<-(@cast_**(+(member_store_node, 32)), allocated_returns);

                variable end_node = append_node(&(nodes), &(nodes_index), NODE_ENDFUNCTION);


                // Getter for individual members
                variable allocated = bump_allocate(&(allocator), integer+(length(name), integer+(length(member_name), 3)));
                copy(name, allocated, length(name));
                copy("->", @cast_*(+(allocated, length(name))), 2);
                copy(member_name, @cast_*(+(allocated, +(length(name), 2))), length(member_name));

                variable allocated_arguments = bump_allocate(&(allocator), 16);
                array8_set(allocated_arguments, 0, allocated_pointer);

                variable allocated_returns = bump_allocate(&(allocator), 16);
                array8_set(allocated_returns, 0, member_type);

                variable member_store_node = append_node(&(nodes), &(nodes_index), NODE_FUNCTION);
                *<-(@cast_**(+(member_store_node, 8)), allocated);
                *<-(@cast_**(+(member_store_node, 16)), @cast_*(0));
                *<-(@cast_**(+(member_store_node, 24)), allocated_arguments);
                *<-(@cast_**(+(member_store_node, 32)), allocated_returns);

                variable end_node = append_node(&(nodes), &(nodes_index), NODE_ENDFUNCTION);

                j = integer+(j, 1);
            };
        };
        i = integer+(i, 1);
    };

    println("Checking...");
    type_check(&(nodes), nodes_index, &(allocator));

    println("Outputting...");
    output_linux_x86-64(&(nodes), nodes_index, main_name, &(allocator));
};

function is_number(string: *): boolean {
    variable length = length(string);

    variable i = 0;
    while <(i, length) {
        variable character = any_1->(@cast_*any_1(+(string, i)));
        if <(byte_to_integer(character), 48) {
            return false;
        };

        if >(byte_to_integer(character), 57) {
            return false;
        };
        i = @cast_integer(+(i, 1));
    };

    return true;
};

function to_number(string: *): integer {
    variable length = length(string);

    variable integer = 0;

    variable i = 0;
    while <(i, length) {
        variable character = byte_to_integer(any_1->(@cast_*any_1(+(string, i))));
        integer = @cast_integer(*(integer, 10));
        integer = @cast_integer(+(integer, -(character, 48)));
        i = @cast_integer(+(i, 1));
    };

    return integer;
};

function integer_to_string(integer: integer, buffer: *) {
    variable integer2 = integer;

    if =(integer, 0) {
        any_1<-(@cast_*any_1(buffer), byte(48));
    };

    variable length = 0;
    while !(=(integer2, 0)) {
        integer2 = @cast_integer(/(integer2, 10));
        length = @cast_integer(+(length, 1));
    };

    integer2 = integer;

    variable i = 0;
    while !(=(integer2, 0)) {
        variable number = @cast_integer(%(integer2, 10));
        any_1<-(@cast_*any_1(+(buffer, -(-(length, 1), i))), byte(+(number, 48)));
        integer2 = @cast_integer(/(integer2, 10));
        i = @cast_integer(+(i, 1));
    };
};

function tokenize_inner(auto_buffer: *AutoBuffer, tokens: *AutoBuffer, tokens_index: *integer, allocator: *BumpAllocator) {
    variable buffer = AutoBuffer->buffer(auto_buffer);
    variable buffer_length = length(AutoBuffer->buffer(auto_buffer));

    if =(buffer_length, 0) {
        return;
    };

    variable is_keyword = false;
    if string=(buffer, "function") {
        is_keyword = true;
    };
    if string=(buffer, "variable") {
        is_keyword = true;
    };
    if string=(buffer, "return") {
        is_keyword = true;
    };
    if string=(buffer, "structure") {
        is_keyword = true;
    };
    if string=(buffer, "if") {
        is_keyword = true;
    };
    if string=(buffer, "while") {
        is_keyword = true;
    };
    if string=(buffer, "global") {
        is_keyword = true;
    };
    if string=(buffer, "constant") {
        is_keyword = true;
    };

    if is_keyword {
        variable allocated = bump_allocate(allocator, @cast_integer(+(buffer_length, 1)));
        copy(buffer, allocated, buffer_length);

        autobuffer_set_integer(tokens, TOKEN_KEYWORD, integer*(integer->(tokens_index), TOKEN_SIZE));
        autobuffer_set_*(tokens, allocated, integer+(integer*(integer->(tokens_index), TOKEN_SIZE), 8));

        increment_integer_pointer(tokens_index, 1);
        return;
    };

    if is_number(buffer) {
        autobuffer_set_integer(tokens, TOKEN_INTEGER, integer*(integer->(tokens_index), TOKEN_SIZE));
        autobuffer_set_integer(tokens, to_number(buffer), integer+(integer*(integer->(tokens_index), TOKEN_SIZE), 8));
        increment_integer_pointer(tokens_index, 1);
        return;
    };

    if |(string=(buffer, "true"), string=(buffer, "false")) {
        autobuffer_set_integer(tokens, TOKEN_BOOLEAN, integer*(integer->(tokens_index), TOKEN_SIZE));
        autobuffer_set_boolean(tokens, string=(buffer, "true"), integer+(integer*(integer->(tokens_index), TOKEN_SIZE), 8));
        increment_integer_pointer(tokens_index, 1);
        return;
    };
    
    variable allocated = bump_allocate(allocator, @cast_integer(+(buffer_length, 1)));
    copy(buffer, allocated, buffer_length);
    autobuffer_set_integer(tokens, TOKEN_NAME, integer*(integer->(tokens_index), TOKEN_SIZE));
    autobuffer_set_*(tokens, allocated, integer+(integer*(integer->(tokens_index), TOKEN_SIZE), 8));
    increment_integer_pointer(tokens_index, 1);
};

constant ASCII_SPACE: integer = 32;
constant ASCII_OPEN_PARENTHESIS: integer = 40;
constant ASCII_CLOSED_PARENTHESIS: integer = 41;
constant ASCII_OPEN_CURLY_BRACKETS: integer = 123;
constant ASCII_CLOSED_CURLY_BRACKETS: integer = 125;
constant ASCII_COMMA: integer = 44;
constant ASCII_SEMICOLON: integer = 59;
constant ASCII_COLON: integer = 58;
constant ASCII_TAB: integer = 9;
constant ASCII_LINE_FEED: integer = 10;
constant ASCII_QUOTATION: integer = 34;
constant ASCII_SLASH: integer = 47;

constant TOKEN_OPEN_PARENTHESIS: integer = 0;
constant TOKEN_CLOSED_PARENTHESIS: integer = 1;
constant TOKEN_OPEN_CURLY_BRACKETS: integer = 2;
constant TOKEN_CLOSED_CURLY_BRACKETS: integer = 3;
constant TOKEN_COMMA: integer = 4;
constant TOKEN_SEMICOLON: integer = 5;
constant TOKEN_KEYWORD: integer = 6;
constant TOKEN_NAME: integer = 7;
constant TOKEN_STRING: integer = 8;
constant TOKEN_INTEGER: integer = 9;
constant TOKEN_COLON: integer = 10;
constant TOKEN_BOOLEAN: integer = 11;

structure TokenKeywordData {
    keyword: *;
};

structure TokenNameData {
    name: *;
};

structure TokenStringData {
    string: *;
};

structure TokenIntegerData {
    integer: integer;
};

constant TOKEN_SIZE: integer = 16;

function tokenize(contents: *, tokens: *AutoBuffer, tokens_index: *integer, allocator: *BumpAllocator) {
    variable index = 0;
    variable contents_length = length(contents);

    variable buffer = autobuffer_new(64);
    variable buffer_index = 0;

    variable in_quotes = false;
    variable in_comment = false;

    while <(index, contents_length) {
        variable character_pointer = @cast_*(+(contents, index));
        variable character_pointer_next = @cast_*(+(contents, +(index, 1)));
        variable done_anything = false;

        if !(in_quotes) {
            if !(in_comment) {
                if =1(*1(character_pointer), byte(ASCII_SPACE)) {
                    tokenize_inner(&(buffer), tokens, tokens_index, allocator);
                    done_anything = true;
                    autobuffer_reset(&(buffer));
                    buffer_index = 0;
                };
                if =1(*1(character_pointer), byte(ASCII_OPEN_PARENTHESIS)) {
                    tokenize_inner(&(buffer), tokens, tokens_index, allocator);
                    done_anything = true;
                    autobuffer_reset(&(buffer));
                    buffer_index = 0;

                    autobuffer_set_integer(tokens, TOKEN_OPEN_PARENTHESIS, integer*(integer->(tokens_index), TOKEN_SIZE));
                    increment_integer_pointer(tokens_index, 1);
                };
                if =1(*1(character_pointer), byte(ASCII_CLOSED_PARENTHESIS)) {
                    tokenize_inner(&(buffer), tokens, tokens_index, allocator);
                    done_anything = true;
                    autobuffer_reset(&(buffer));
                    buffer_index = 0;

                    autobuffer_set_integer(tokens, TOKEN_CLOSED_PARENTHESIS, integer*(integer->(tokens_index), TOKEN_SIZE));
                    increment_integer_pointer(tokens_index, 1);
                };
                if =1(*1(character_pointer), byte(ASCII_OPEN_CURLY_BRACKETS)) {
                    tokenize_inner(&(buffer), tokens, tokens_index, allocator);
                    done_anything = true;
                    autobuffer_reset(&(buffer));
                    buffer_index = 0;

                    autobuffer_set_integer(tokens, TOKEN_OPEN_CURLY_BRACKETS, integer*(integer->(tokens_index), TOKEN_SIZE));
                    increment_integer_pointer(tokens_index, 1);
                };
                if =1(*1(character_pointer), byte(ASCII_CLOSED_CURLY_BRACKETS)) {
                    tokenize_inner(&(buffer), tokens, tokens_index, allocator);
                    done_anything = true;
                    autobuffer_reset(&(buffer));
                    buffer_index = 0;

                    autobuffer_set_integer(tokens, TOKEN_CLOSED_CURLY_BRACKETS, integer*(integer->(tokens_index), TOKEN_SIZE));
                    increment_integer_pointer(tokens_index, 1);
                };
                if =1(*1(character_pointer), byte(ASCII_COMMA)) {
                    tokenize_inner(&(buffer), tokens, tokens_index, allocator);
                    done_anything = true;
                    autobuffer_reset(&(buffer));
                    buffer_index = 0;

                    autobuffer_set_integer(tokens, TOKEN_COMMA, integer*(integer->(tokens_index), TOKEN_SIZE));
                    increment_integer_pointer(tokens_index, 1);
                };
                if =1(*1(character_pointer), byte(ASCII_SEMICOLON)) {
                    tokenize_inner(&(buffer), tokens, tokens_index, allocator);
                    done_anything = true;
                    autobuffer_reset(&(buffer));
                    buffer_index = 0;

                    autobuffer_set_integer(tokens, TOKEN_SEMICOLON, integer*(integer->(tokens_index), TOKEN_SIZE));
                    increment_integer_pointer(tokens_index, 1);
                };
                if =1(*1(character_pointer), byte(ASCII_COLON)) {
                    tokenize_inner(&(buffer), tokens, tokens_index, allocator);
                    done_anything = true;
                    autobuffer_reset(&(buffer));
                    buffer_index = 0;

                    autobuffer_set_integer(tokens, TOKEN_COLON, integer*(integer->(tokens_index), TOKEN_SIZE));
                    increment_integer_pointer(tokens_index, 1);
                };
                if =1(*1(character_pointer), byte(ASCII_TAB)) {
                    done_anything = true;
                    autobuffer_reset(&(buffer));
                    buffer_index = 0;
                };
            };

            if =1(*1(character_pointer), byte(ASCII_LINE_FEED)) {
                in_comment = false;
                done_anything = true;
                autobuffer_reset(&(buffer));
                buffer_index = 0;
            };
        };
        if !(in_comment) {
            if =1(*1(character_pointer), byte(ASCII_QUOTATION)) {
                if in_quotes {
                    variable buffer_length = length(AutoBuffer->buffer(&(buffer)));
                    variable allocated = bump_allocate(allocator, @cast_integer(+(buffer_length, 1)));
                    copy(AutoBuffer->buffer(&(buffer)), allocated, buffer_length);

                    autobuffer_set_integer(tokens, TOKEN_STRING, integer*(integer->(tokens_index), TOKEN_SIZE));
                    autobuffer_set_*(tokens, allocated, integer+(integer*(integer->(tokens_index), TOKEN_SIZE), 8));
                    increment_integer_pointer(tokens_index, 1);

                    autobuffer_reset(&(buffer));
                    buffer_index = 0;
                };

                in_quotes = !(in_quotes);
                done_anything = true;
            };
        };
        if =1(*1(character_pointer), byte(ASCII_SLASH)) {
            if =1(*1(character_pointer_next), byte(ASCII_SLASH)) {
                in_comment = true;
                done_anything = true;
            };
        };

        if !(done_anything) {
            if !(in_comment) {
                autobuffer_set_any_1(&(buffer), any_1->(@cast_*any_1(character_pointer)), buffer_index);

                buffer_index = integer+(buffer_index, 1);
            };
        };

        index = @cast_integer(+(index, 1));
    };
};

constant NODE_FUNCTION: integer = 0;
constant NODE_ENDFUNCTION: integer = 1;
constant NODE_RETRIEVE: integer = 2;
constant NODE_STRING: integer = 3;
constant NODE_INTEGER: integer = 4;
constant NODE_INVOKE: integer = 5;
constant NODE_DECLARE: integer = 6;
constant NODE_ASSIGN: integer = 7;
constant NODE_RETURN: integer = 8;
constant NODE_STRUCTURE: integer = 9;
constant NODE_POINTER: integer = 10;
constant NODE_BOOLEAN: integer = 11;
constant NODE_JUMP_CONDITIONAL: integer = 12;
constant NODE_TARGET: integer = 13;
constant NODE_JUMP: integer = 14;
constant NODE_GLOBAL: integer = 15;
constant NODE_CONSTANT: integer = 16;

constant NODE_SIZE: integer = 48;

function tokens_get_id(tokens: *, index: integer): integer {
    variable index_pointer = @cast_*integer(+(tokens, *(index, TOKEN_SIZE)));
    return integer->(index_pointer);
};

function tokens_get_id2(tokens: *AutoBuffer, index: integer): integer {
    return autobuffer_get_integer(tokens, integer*(index, TOKEN_SIZE));
};

function tokens_get_pointer2(tokens: *AutoBuffer, index: integer): * {
    return autobuffer_get(tokens, integer*(index, TOKEN_SIZE));
};

function tokens_get_pointer(tokens: *, index: integer): * {
    variable index_pointer = @cast_*(+(tokens, *(index, TOKEN_SIZE)));
    return index_pointer;
};

function increment_integer_pointer(pointer: *integer, amount: integer) {
    integer<-(pointer, @cast_integer(+(integer->(pointer), amount)));
};

function decrement_integer_pointer(pointer: *integer, amount: integer) {
    integer<-(pointer, @cast_integer(-(integer->(pointer), amount)));
};

function append_node(nodes: *AutoBuffer, nodes_index: *integer, id: integer): * {
    variable to_return = autobuffer_get(nodes, integer*(integer->(nodes_index), NODE_SIZE));

    integer<-(@cast_*integer(to_return), id);

    increment_integer_pointer(nodes_index, 1);

    return to_return;
};

function parse_constant(tokens: *AutoBuffer, index_pointer: *integer, nodes: *AutoBuffer, nodes_index: *integer, allocator: *BumpAllocator) {
    variable index = integer->(index_pointer);
    variable name_token_pointer = tokens_get_pointer2(tokens, integer+(index, 1));
    variable name = *->(@cast_**(+(name_token_pointer, 8)));
    variable type_token_pointer = tokens_get_pointer2(tokens, integer+(index, 3));
    variable type = *->(@cast_**(+(type_token_pointer, 8)));
    variable value_token_pointer = tokens_get_pointer2(tokens, integer+(index, 5));
    variable value = any_8->(@cast_*any_8(+(value_token_pointer, 8)));

    variable global_node = append_node(nodes, nodes_index, NODE_CONSTANT);
    *<-(@cast_**(+(global_node, 8)), name);
    *<-(@cast_**(+(global_node, 16)), type);
    any_8<-(@cast_*any_8(+(global_node, 24)), value);

    increment_integer_pointer(index_pointer, 7);
};

function parse_global(tokens: *AutoBuffer, index_pointer: *integer, nodes: *AutoBuffer, nodes_index: *integer, allocator: *BumpAllocator) {
    variable index = integer->(index_pointer);
    variable name_token_pointer = tokens_get_pointer2(tokens, integer+(index, 1));
    variable name = *->(@cast_**(+(name_token_pointer, 8)));
    variable type_token_pointer = tokens_get_pointer2(tokens, integer+(index, 3));
    variable type = *->(@cast_**(+(type_token_pointer, 8)));

    variable global_node = append_node(nodes, nodes_index, NODE_GLOBAL);
    *<-(@cast_**(+(global_node, 8)), name);
    *<-(@cast_**(+(global_node, 16)), type);

    increment_integer_pointer(index_pointer, 5);
};

function parse_structure(tokens: *AutoBuffer, index_pointer: *integer, nodes: *AutoBuffer, nodes_index: *integer, allocator: *BumpAllocator) {
    variable index = integer->(index_pointer);
    variable name_token_pointer = autobuffer_get(tokens, integer*(integer+(index, 1), TOKEN_SIZE));
    variable name = *->(@cast_**(+(name_token_pointer, 8)));

    variable member_names_pointer = bump_allocate(allocator, 40);
    variable member_types_pointer = bump_allocate(allocator, 40);
    variable member_index = 0;

    index = integer+(index, 3);

    variable seen_name = false;

    while !(=(tokens_get_id2(tokens, index), TOKEN_CLOSED_CURLY_BRACKETS)) {
        variable id = tokens_get_id2(tokens, index);

        if =(id, TOKEN_NAME) {
            if >(member_index, 4) {
                println("member_names_pointer overflows buffer");
            };

            variable token_pointer = tokens_get_pointer2(tokens, index);
            variable name_name = *->(@cast_**(+(token_pointer, 8)));

            if seen_name {
                array8_set(member_types_pointer, member_index, name_name);
                member_index = integer+(member_index, 1);
            };

            if !(seen_name) {
                array8_set(member_names_pointer, member_index, name_name);
            };

            seen_name = !(seen_name);
        };

        index = integer+(index, 1);
    };

    variable structure_node = append_node(nodes, nodes_index, NODE_STRUCTURE);
    *<-(@cast_**(+(structure_node, 8)), name);
    *<-(@cast_**(+(structure_node, 16)), member_names_pointer);
    *<-(@cast_**(+(structure_node, 24)), member_types_pointer);

    index = integer+(index, 2);

    integer<-(index_pointer, index);
};

function parse_function(tokens: *AutoBuffer, index_pointer: *integer, nodes: *AutoBuffer, nodes_index: *integer, allocator: *BumpAllocator) {
    variable index = integer->(index_pointer);

    variable name_token_pointer = tokens_get_pointer2(tokens, integer+(index, 1));
    variable name = *->(@cast_**(+(name_token_pointer, 8)));

    variable function_node = append_node(nodes, nodes_index, NODE_FUNCTION);
    *<-(@cast_**(+(function_node, 8)), name);

    index = @cast_integer(+(index, 3));

    variable parameter_names_pointer = bump_allocate(allocator, 40);
    variable parameter_types_pointer = bump_allocate(allocator, 40);
    variable returns_pointer = bump_allocate(allocator, 40);

    variable parameters_index = 0;
    variable parameters_index2 = 0;
    while !(=(tokens_get_id2(tokens, index), TOKEN_CLOSED_PARENTHESIS)) {
        variable id = tokens_get_id2(tokens, index);

        if =(id, TOKEN_NAME) {
            if >(parameters_index2, 4) {
                println("parameters_names_pointer overflows buffer");
            };

            variable token_name = *->(@cast_**(+(tokens_get_pointer2(tokens, index), 8)));

            variable done_anything = false;
            if =(%(parameters_index, 2), 0) {
                array8_set(parameter_names_pointer, parameters_index2, token_name);
                done_anything = true;
            };

            if !(done_anything) {
                array8_set(parameter_types_pointer, parameters_index2, token_name);
                parameters_index2 = @cast_integer(+(parameters_index2, 1));
            };

            parameters_index = @cast_integer(+(parameters_index, 1));
        };

        index = @cast_integer(+(index, 1));
    };
    
    index = @cast_integer(+(index, 1));

    variable returns_index = 0;
    while &&(!(=(tokens_get_id2(tokens, index), TOKEN_OPEN_CURLY_BRACKETS)), !(=(tokens_get_id2(tokens, index), TOKEN_SEMICOLON))) {
        variable id = tokens_get_id2(tokens, index);

        if =(id, TOKEN_NAME) {
            if >(returns_index, 4) {
                println("returns_pointer overflows buffer");
            };
            variable token_name = *->(@cast_**(+(tokens_get_pointer2(tokens, index), 8)));

            array8_set(returns_pointer, returns_index, token_name);
        };

        index = @cast_integer(+(index, 1));
    };

    variable has_body = =(tokens_get_id2(tokens, index), TOKEN_OPEN_CURLY_BRACKETS);

    *<-(@cast_**(+(function_node, 16)), parameter_names_pointer);
    *<-(@cast_**(+(function_node, 24)), parameter_types_pointer);
    *<-(@cast_**(+(function_node, 32)), returns_pointer);

    index = @cast_integer(+(index, 1));

    if has_body {
        while !(=(tokens_get_id2(tokens, index), TOKEN_CLOSED_CURLY_BRACKETS)) {
            parse_statement(tokens, &(index), nodes, nodes_index, allocator);
        };

        index = integer+(index, 2);
    };

    if !(=(nodes_get_id2(nodes, integer-(integer->(nodes_index), 1)), NODE_RETURN)) {
        if has_body {
            variable _ = append_node(nodes, nodes_index, NODE_RETURN);
        };
    };

    variable _ = append_node(nodes, nodes_index, NODE_ENDFUNCTION);

    integer<-(index_pointer, index);
};

function parse_expression(tokens: *AutoBuffer, index_pointer: *integer, nodes: *AutoBuffer, nodes_index: *integer, allocator: *BumpAllocator) {
    variable index = integer->(index_pointer);

    if =(tokens_get_id2(tokens, index), TOKEN_NAME) {
        variable done_anything_name = false;
        if =(tokens_get_id2(tokens, @cast_integer(+(index, 1))), TOKEN_OPEN_PARENTHESIS) {
            variable function_name = *->(@cast_**(+(tokens_get_pointer2(tokens, index), 8)));

            index = @cast_integer(+(index, 2));

            while !(=(tokens_get_id2(tokens, index), TOKEN_CLOSED_PARENTHESIS)) {
                variable done_anything_loop = false;

                if =(tokens_get_id2(tokens, index), TOKEN_COMMA) {
                    index = @cast_integer(+(index, 1));
                    done_anything_loop = true;
                };

                if !(done_anything_loop) {
                    parse_expression(tokens, &(index), nodes, nodes_index, allocator);
                };
            };

            index = @cast_integer(+(index, 1));

            variable is_pointer = false;
            if string=(function_name, "&") {
                variable invoke_pointer = append_node(nodes, nodes_index, NODE_POINTER);
                is_pointer = true;
            };
            if !(is_pointer) {
                variable invoke_pointer = append_node(nodes, nodes_index, NODE_INVOKE);
                *<-(@cast_**(+(invoke_pointer, 8)), function_name);
            };

            done_anything_name = true;
        };

        if !(done_anything_name) {
            variable retrieve_name = *->(@cast_**(+(tokens_get_pointer2(tokens, index), 8)));
            variable retrieve_pointer = append_node(nodes, nodes_index, NODE_RETRIEVE);
            *<-(@cast_**(+(retrieve_pointer, 8)), retrieve_name);

            index = @cast_integer(+(index, 1));
        };
    };

    if =(tokens_get_id2(tokens, index), TOKEN_STRING) {
        variable string_value = *->(@cast_**(+(tokens_get_pointer2(tokens, index), 8)));
        variable string_pointer = append_node(nodes, nodes_index, NODE_STRING);
        *<-(@cast_**(+(string_pointer, 8)), string_value);

        index = @cast_integer(+(index, 1));
    };

    if =(tokens_get_id2(tokens, index), TOKEN_INTEGER) {
        variable integer_value = integer->(@cast_*integer(+(tokens_get_pointer2(tokens, index), 8)));
        variable integer_pointer = append_node(nodes, nodes_index, NODE_INTEGER);
        integer<-(@cast_*integer(+(integer_pointer, 8)), integer_value);

        index = @cast_integer(+(index, 1));
    };

    if =(tokens_get_id2(tokens, index), TOKEN_BOOLEAN) {
        variable boolean_value = any_1->(@cast_*any_1(+(tokens_get_pointer2(tokens, index), 8)));
        variable integer_pointer = append_node(nodes, nodes_index, NODE_BOOLEAN);
        any_1<-(@cast_*any_1(+(integer_pointer, 8)), boolean_value);

        index = @cast_integer(+(index, 1));
    };

    integer<-(index_pointer, index);
};

function get_target_id(): integer {
    variable return_ = target_id;
    target_id = integer+(target_id, 1);

    return return_;
};

function parse_statement(tokens: *AutoBuffer, index_pointer: *integer, nodes: *AutoBuffer, nodes_index: *integer, allocator: *BumpAllocator) {
    variable done_anything = false;

    if =(tokens_get_id2(tokens, integer->(index_pointer)), TOKEN_KEYWORD) {
        if string=(*->(@cast_**(+(tokens_get_pointer2(tokens, integer->(index_pointer)), 8))), "variable") {
            variable variable_name = *->(@cast_**(+(tokens_get_pointer2(tokens, integer+(integer->(index_pointer), 1)), 8)));
            variable index = integer->(index_pointer);
            index = integer+(index, 1);

            variable names: any_40;
            variable types: any_40;

            variable name_index = 0;
            variable seen_name = false;
            variable running = true;
            variable parse_expression = false;
            while running {
                variable id = tokens_get_id2(tokens, index);
                if =(id, TOKEN_COMMA) {
                    name_index = integer+(name_index, 1);
                    seen_name = false;
                };

                if =(id, TOKEN_NAME) {
                    variable name_value = *->(@cast_**(+(tokens_get_pointer2(tokens, index), 8)));
                    if seen_name {
                        array8_set(&(types), name_index, name_value);
                    };

                    if !(seen_name) {
                        array8_set(&(names), name_index, name_value);
                        array8_set(&(types), name_index, "");
                        seen_name = true;
                    };
                };

                index = integer+(index, 1);

                if =(tokens_get_id2(tokens, index), TOKEN_NAME) {
                    if string=(*->(@cast_**(+(tokens_get_pointer2(tokens, index), 8))), "=") {
                        running = false;
                        parse_expression = true;
                    };
                };
                if =(tokens_get_id2(tokens, index), TOKEN_SEMICOLON) {
                    running = false;
                    parse_expression = false;
                };
            };

            variable i = 0;
            while !(=(array8_get(&(names), i), 0)) {
                variable node = append_node(nodes, nodes_index, NODE_DECLARE);
                *<-(@cast_**(+(node, 8)), @cast_*(array8_get(&(names), i)));
                *<-(@cast_**(+(node, 16)), @cast_*(array8_get(&(types), i)));

                i = integer+(i, 1);
            };

            if parse_expression {
                index = integer+(index, 1);
                //TODO
                parse_expression(tokens, &(index), nodes, nodes_index, allocator);

                variable i = 0;
                while !(=(array8_get(&(names), i), 0)) {
                    variable node = append_node(nodes, nodes_index, NODE_ASSIGN);
                    *<-(@cast_**(+(node, 8)), @cast_*(array8_get(&(names), i)));

                    i = integer+(i, 1);
                };
            };

            integer<-(index_pointer, index);
        };
    };
    if =(tokens_get_id2(tokens, integer->(index_pointer)), TOKEN_KEYWORD) {
        if string=(*->(@cast_**(+(tokens_get_pointer2(tokens, integer->(index_pointer)), 8))), "return") {
            increment_integer_pointer(index_pointer, 1);
            parse_expression(tokens, index_pointer, nodes, nodes_index, allocator);

            variable node = append_node(nodes, nodes_index, NODE_RETURN);
        };
    };
    if =(tokens_get_id2(tokens, integer->(index_pointer)), TOKEN_KEYWORD) {
        if string=(*->(@cast_**(+(tokens_get_pointer2(tokens, integer->(index_pointer)), 8))), "if") {
            increment_integer_pointer(index_pointer, 1);

            variable target = get_target_id();

            parse_expression(tokens, index_pointer, nodes, nodes_index, allocator);
            variable conditional_jump = append_node(nodes, nodes_index, NODE_JUMP_CONDITIONAL);
            any_8<-(@cast_*any_8(+(conditional_jump, 8)), target);
            any_1<-(@cast_*any_1(+(conditional_jump, 16)), byte(0));

            increment_integer_pointer(index_pointer, 1);

            while !(=(tokens_get_id2(tokens, integer->(index_pointer)), TOKEN_CLOSED_CURLY_BRACKETS)) {
                parse_statement(tokens, index_pointer, nodes, nodes_index, allocator);
            };

            variable target_node = append_node(nodes, nodes_index, NODE_TARGET);
            any_8<-(@cast_*any_8(+(target_node, 8)), target);
 
            increment_integer_pointer(index_pointer, 1);
        };
    };
    if =(tokens_get_id2(tokens, integer->(index_pointer)), TOKEN_KEYWORD) {
        if string=(*->(@cast_**(+(tokens_get_pointer2(tokens, integer->(index_pointer)), 8))), "while") {
            increment_integer_pointer(index_pointer, 1);

            variable target1 = get_target_id();

            variable target2 = get_target_id();

            variable target_node1 = append_node(nodes, nodes_index, NODE_TARGET);
            any_8<-(@cast_*any_8(+(target_node1, 8)), target1);

            parse_expression(tokens, index_pointer, nodes, nodes_index, allocator);
            variable conditional_jump = append_node(nodes, nodes_index, NODE_JUMP_CONDITIONAL);
            any_8<-(@cast_*any_8(+(conditional_jump, 8)), target2);
            any_1<-(@cast_*any_1(+(conditional_jump, 16)), byte(0));

            increment_integer_pointer(index_pointer, 1);

            while !(=(tokens_get_id2(tokens, integer->(index_pointer)), TOKEN_CLOSED_CURLY_BRACKETS)) {
                parse_statement(tokens, index_pointer, nodes, nodes_index, allocator);
            };

            variable jump_node = append_node(nodes, nodes_index, NODE_JUMP);
            any_8<-(@cast_*any_8(+(jump_node, 8)), target1);

            variable target_node2 = append_node(nodes, nodes_index, NODE_TARGET);
            any_8<-(@cast_*any_8(+(target_node2, 8)), target2);
 
            increment_integer_pointer(index_pointer, 1);
        };
    };
    if &&(=(tokens_get_id2(tokens, integer->(index_pointer)), TOKEN_NAME), =(tokens_get_id2(tokens, integer+(integer->(index_pointer), 1)), TOKEN_NAME)) {
        variable names: any_40;
        variable name_index = 0;

        variable index = integer->(index_pointer);
        while !(string=(*->(@cast_**(+(tokens_get_pointer2(tokens, index), 8))), "=")) {
            if >(name_index, 4) {
                println("names overflows buffer");
            };

            variable name = *->(@cast_**(+(tokens_get_pointer2(tokens, index), 8)));
            stack8_push(&(names), &(name_index), name);
            index = integer+(index, 1);
        };

        index = integer+(index, 1);

        parse_expression(tokens, &(index), nodes, nodes_index, allocator);

        variable i = 0;
        while !(=(array8_get(&(names), i), 0)) {
            variable assign_node = append_node(nodes, nodes_index, NODE_ASSIGN);
            *<-(@cast_**(+(assign_node, 8)), @cast_*(array8_get(&(names), i)));
            i = integer+(i, 1);
        };

        integer<-(index_pointer, index);
    };

    if !(done_anything) {
        parse_expression(tokens, index_pointer, nodes, nodes_index, allocator);
        increment_integer_pointer(index_pointer, 1);
    };
};

function parse(tokens: *AutoBuffer, tokens_count: integer, nodes: *AutoBuffer, nodes_index, *integer, allocator: *BumpAllocator) {
    variable index = 0;
    
    while <(index, tokens_count) {
        variable id = autobuffer_get_integer(tokens, integer*(index, TOKEN_SIZE));

        if =(id, TOKEN_KEYWORD) {
            variable keyword = autobuffer_get_*(tokens, integer+(integer*(index, TOKEN_SIZE), 8));

            if string=(keyword, "function") {
                parse_function(tokens, &(index), nodes, nodes_index, allocator);
            };

            if string=(keyword, "structure") {
                parse_structure(tokens, &(index), nodes, nodes_index, allocator);
            };

            if string=(keyword, "global") {
                parse_global(tokens, &(index), nodes, nodes_index, allocator);
            };

            if string=(keyword, "constant") {
                parse_constant(tokens, &(index), nodes, nodes_index, allocator);
            };
        };
    };
};

function get_size_linux_x86-64(type: *, nodes: *AutoBuffer, node_count: integer): integer {
    if string=(type, "integer") {
        return 8;
    };
    if string=(type, "boolean") {
        return 1;
    };
    if string_length=(type, "*", 1) {
        return 8;
    };
    if string_length=(type, "any", 3) {
        return to_number(@cast_*(+(type, 4)));
    };

    variable i = 0;
    while <(i, node_count) {
        if =(nodes_get_id2(nodes, i), NODE_STRUCTURE) {
            variable pointer = nodes_get_pointer2(nodes, i);
            variable name = *->(@cast_**(+(pointer, 8)));
            variable member_types = *->(@cast_**(+(pointer, 24)));
            if string=(type, name) {
                return get_size_multiple_linux_x86-64(member_types, 999, nodes, node_count);
            };
        };
        i = integer+(i, 1);
    };

    print("unknown type ");
    println(type);

    return 0;
};

function get_size_multiple_linux_x86-64(array: *, count: integer, nodes: *AutoBuffer, node_count: integer): integer {
    variable total = 0;

    variable i = 0;
    while <(i, count) {
        if =(array8_get(array, i), 0) {
            return total;
        };
        total = integer+(total, get_size_linux_x86-64(@cast_*(array8_get(array, i)), nodes, node_count));
        i = integer+(i, 1);
    };

    return total;
};

function get_size_multiple_reversed_linux_x86-64(array: *, count: integer, nodes: *AutoBuffer, node_count: integer): integer {
    variable i = array8_length(array);

    i = @cast_integer(-(i, 1));

    variable total = 0;

    while >(+(array, i), +(array, count)) {
        total = integer+(total, get_size_linux_x86-64(@cast_*(array8_get(array, i)), nodes, node_count));
        i = integer-(i, 1);
    };

    return total;
};

function is_type(wanted: *, given: *, nodes: *AutoBuffer, node_count: integer): boolean {
    if string=(wanted, given) {
        return true;
    };

    if string_length=(wanted, "any_", 4) {
        variable size = to_number(@cast_*(+(wanted, 4)));
        return =(size, get_size_linux_x86-64(given, nodes, node_count));
    };

    return false;
};

function type_check(nodes: *AutoBuffer, node_count: integer, allocator: *BumpAllocator) {
    variable stack: any_64;
    variable stack_pointer: integer;

    variable functions: any_512;
    variable function_argument_names: any_512;
    variable function_arguments: any_512;
    variable function_returns: any_512;
    variable index = 0;

    variable globals: any_512;
    variable global_types: any_512;
    variable global_index: integer;

    variable constants: any_512;
    variable constant_types: any_512;
    variable constant_index: integer;

    variable i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id2(nodes, i);
        variable pointer = nodes_get_pointer2(nodes, i);

        if =(id, NODE_FUNCTION) {
            variable function_name = *->(@cast_**(+(pointer, 8)));
            array8_set(&(functions), index, function_name);
            variable function_argument_names2 = *->(@cast_**(+(pointer, 16)));
            array8_set(&(function_argument_names), index, function_argument_names2);
            variable function_arguments2 = *->(@cast_**(+(pointer, 24)));
            array8_set(&(function_arguments), index, function_arguments2);
            variable function_returns2 = *->(@cast_**(+(pointer, 32)));
            array8_set(&(function_returns), index, function_returns2);

            if >(index, 63) {
                println("functions overflows buffer");
            };

            index = integer+(index, 1);
        };

        if =(id, NODE_GLOBAL) {
            variable global_name = *->(@cast_**(+(pointer, 8)));
            variable global_type = *->(@cast_**(+(pointer, 16)));

            array8_set(&(globals), global_index, global_name);
            array8_set(&(global_types), global_index, global_type);

            if >(global_index, 63) {
                println("globals overflows buffer");
            };

            global_index = integer+(global_index, 1);
        };

        if =(id, NODE_CONSTANT) {
            variable constant_name = *->(@cast_**(+(pointer, 8)));
            variable constant_type = *->(@cast_**(+(pointer, 16)));

            array8_set(&(constants), constant_index, constant_name);
            array8_set(&(constant_types), constant_index, constant_type);

            if >(constant_index, 63) {
                println("constants overflows buffer");
            };

            constant_index = integer+(global_index, 1);
        };

        i = integer+(i, 1);
    };

    variable current_function: *;

    variable variable_names: any_128;
    variable variable_types: any_128;
    variable variable_declares: any_128;
    variable variable_index = 0;

    i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id2(nodes, i);
        variable pointer = nodes_get_pointer2(nodes, i);
        variable done_anything = false;

        if >(stack_pointer, 7) {
            println("stack buffer overflows");
        };

        if =(id, NODE_FUNCTION) {
            variable function_name = *->(@cast_**(+(pointer, 8)));
            current_function = function_name;
            variable_index = 0;
            done_anything = true;
        };
        if =(id, NODE_INTEGER) {
            stack8_push(&(stack), &(stack_pointer), "integer");
            done_anything = true;
        };
        if =(id, NODE_BOOLEAN) {
            stack8_push(&(stack), &(stack_pointer), "boolean");
            done_anything = true;
        };
        if =(id, NODE_STRING) {
            stack8_push(&(stack), &(stack_pointer), "*");
            done_anything = true;
        };
        if =(id, NODE_INVOKE) {
            variable function_name = *->(@cast_**(+(pointer, 8)));

            variable matched_internal = false;

            if string_length=(function_name, "@cast_", 6) {
                variable _ = stack8_pop(&(stack), &(stack_pointer));
                stack8_push(&(stack), &(stack_pointer), @cast_*(+(function_name, 6)));
                matched_internal = true;
            };

            if !(matched_internal) {
                variable found_function = false;
                variable j = 0;
                while <(j, index) {
                    if string=(@cast_*(array8_get(&(functions), j)), function_name) {
                        variable arguments = @cast_*(array8_get(&(function_arguments), j));
                        variable returns = @cast_*(array8_get(&(function_returns), j));

                        variable length = array8_length(arguments);
                        variable k = 0;
                        while !(=(array8_get(arguments, k), 0)) {
                            variable given = @cast_*(stack8_pop(&(stack), &(stack_pointer)));
                            variable wanted = @cast_*(array8_get(arguments, @cast_integer(-(-(length, k), 1))));
                            if !(is_type(wanted, given, nodes, node_count)) {
                                print("TYPECHECK: ");
                                print(current_function);
                                print(": Invoke of ");
                                print(function_name);
                                print(" wants '");
                                print(wanted);
                                print("', given '");
                                print(given);
                                println("'");
                                sys_exit(1);
                            };

                            k = integer+(k, 1);
                        };

                        variable k = 0;
                        while !(=(array8_get(returns, k), 0)) {
                            variable return_value = @cast_*(array8_get(returns, k));
                            stack8_push(&(stack), &(stack_pointer), return_value);

                            k = integer+(k, 1);
                        };
                        
                        found_function = true;
                    };
                    j = integer+(j, 1);
                };

                if !(found_function) {
                    print("TYPECHECK: ");
                    print(current_function);
                    print(": Invoke target '");
                    print(function_name);
                    println("' not found");
                    sys_exit(1);
                };
            };

            done_anything = true;
        };
        if =(id, NODE_DECLARE) {
            variable variable_name = *->(@cast_**(+(pointer, 8)));
            variable variable_type = *->(@cast_**(+(pointer, 16)));

            array8_set(&(variable_names), variable_index, variable_name);
            array8_set(&(variable_types), variable_index, variable_type);
            array8_set(&(variable_declares), variable_index, pointer);
            variable_index = integer+(variable_index, 1);

            if >(variable_index, 15) {
                println("type_check variable_index overflows buffer");
            };

            done_anything = true;
        };
        if =(id, NODE_ASSIGN) {
            variable variable_name = *->(@cast_**(+(pointer, 8)));
            variable variable_type = stringarraymap_get(&(variable_names), &(variable_types), variable_name, variable_index);
            variable popped_stack = @cast_*(stack8_pop(&(stack), &(stack_pointer)));

            if !(=(variable_type, 0)) {
                if string=(variable_type, "") {
                    variable variable_index2 = stringarraymap_get_index(&(variable_names), variable_name, variable_index);
                    array8_set(&(variable_types), variable_index2, popped_stack);
                    variable_type = stringarraymap_get(&(variable_names), &(variable_types), variable_name, variable_index);

                    variable variable_declare = stringarraymap_get(&(variable_names), &(variable_declares), variable_name, variable_index);

                    *<-(@cast_**(+(variable_declare, 16)), variable_type);
                };

                if !(string=(variable_type, popped_stack)) {
                    print("TYPECHECK: ");
                    print(current_function);
                    print(": Assign of ");
                    print(variable_name);
                    print(" wants '");
                    print(variable_type);
                    print("', given '");
                    print(popped_stack);
                    println("'");
                    sys_exit(1);
                };
            };

            if =(variable_type, 0) {
                variable_type = stringarraymap_get(&(globals), &(global_types), variable_name, global_index);

                if !(string=(variable_type, popped_stack)) {
                    print("TYPECHECK: ");
                    print(current_function);
                    print(": Assign of ");
                    print(variable_name);
                    print(" wants '");
                    print(variable_type);
                    print("', given '");
                    print(popped_stack);
                    println("'");
                    sys_exit(1);
                };
            };

            done_anything = true;
        };
        if =(id, NODE_RETRIEVE) {
            variable variable_name = *->(@cast_**(+(pointer, 8)));
            variable variable_type = stringarraymap_get(&(variable_names), &(variable_types), variable_name, variable_index);
            if !(=(variable_type, 0)) {
                stack8_push(&(stack), &(stack_pointer), variable_type);
            };

            if =(variable_type, 0) {
                variable function_argument_names2 = stringarraymap_get(&(functions), &(function_argument_names), current_function, index);
                variable function_arguments2 = stringarraymap_get(&(functions), &(function_arguments), current_function, index);

                variable_type = stringarraymap_get(function_argument_names2, function_arguments2, variable_name, array8_length(function_arguments2));

                if !(=(variable_type, 0)) {
                    stack8_push(&(stack), &(stack_pointer), variable_type);
                };

                if =(variable_type, 0) {
                    variable_type = stringarraymap_get(&(globals), &(global_types), variable_name, global_index);
                    if !(=(variable_type, 0)) {
                        stack8_push(&(stack), &(stack_pointer), variable_type);
                    };

                    if =(variable_type, 0) {
                        variable_type = stringarraymap_get(&(constants), &(constant_types), variable_name, constant_index);

                        if !(=(variable_type, 0)) {
                            stack8_push(&(stack), &(stack_pointer), variable_type);
                        };

                        if =(variable_type, 0) {
                            println("cannot find way to access variable");
                        };
                    };
                };
            };

            done_anything = true;
        };
        if =(id, NODE_RETURN) {
            variable function_returns2 = stringarraymap_get(&(functions), &(function_returns), current_function, index);

            variable j = 0;
            while !(=(array8_get(function_returns2, j), 0)) {
                variable function_return = @cast_*(array8_get(function_returns2, j));
                variable stack_popped = @cast_*(stack8_pop(&(stack), &(stack_pointer)));
                
                if !(is_type(function_return, stack_popped, nodes, node_count)) {
                    print("TYPECHECK: ");
                    print(current_function);
                    print(": Return wants '");
                    print(function_return);
                    print("', given '");
                    print(stack_popped);
                    println("'");
                    sys_exit(1);
                };

                j = integer+(j, 1);
            };

            done_anything = true;
        };
        if =(id, NODE_POINTER) {
            variable popped = @cast_*(stack8_pop(&(stack), &(stack_pointer)));
            variable allocated = bump_allocate(allocator, integer+(length(popped), 2));
            copy("*", allocated, 1);
            copy(popped, @cast_*(+(allocated, 1)), length(popped));
            stack8_push(&(stack), &(stack_pointer), allocated);
            done_anything = true;
        };
        if =(id, NODE_JUMP_CONDITIONAL) {
            variable popped = @cast_*(stack8_pop(&(stack), &(stack_pointer)));
            if !(string=(popped, "boolean")) {
                print("TYPECHECK: ");
                print(current_function);
                print(": If wants 'boolean', given '");
                print(stack_popped);
                println("'");
                sys_exit(1);
            };
            done_anything = true;
        };
        if =(id, NODE_JUMP) {
            done_anything = true;
        };
        if =(id, NODE_TARGET) {
            done_anything = true;
        };
        if =(id, NODE_ENDFUNCTION) {
            done_anything = true;
        };
        if =(id, NODE_STRUCTURE) {
            done_anything = true;
        };
        if =(id, NODE_GLOBAL) {
            done_anything = true;
        };
        if =(id, NODE_CONSTANT) {
            done_anything = true;
        };

        if !(done_anything) {
            print("Unhandled ");
            @print_integer(id);
        };

        i = integer+(i, 1);
    };
};

function stringarraymap_get(keys: *, values: *, wanted: *, size: integer): * {
    variable j = 0;
    while <(j, size) {
        if string=(@cast_*(array8_get(keys, j)), wanted) {
            return @cast_*(array8_get(values, j));
        };
        j = integer+(j, 1);
    };

    return @cast_*(0);
};

function stringarraymap_get_index(keys: *, wanted: *, size: integer): integer {
    variable j = 0;
    while <(j, size) {
        if string=(@cast_*(array8_get(keys, j)), wanted) {
            return j;
        };
        j = integer+(j, 1);
    };

    return 999;
};

function push_string(buffer: *, buffer_index_pointer: *integer, string: *) {
    variable length = length(string);
    variable buffer_index = integer->(buffer_index_pointer);

    variable i = 0;
    while <(i, length) {
        any_1<-(@cast_*any_1(+(buffer, +(buffer_index, i))), @cast_any_1(any_1->(@cast_*any_1(+(string, i)))));
        i = @cast_integer(+(i, 1));
    };

    increment_integer_pointer(buffer_index_pointer, length);
};

function push_string_with_newline(buffer: *, buffer_index_pointer: *integer, string: *) {
    push_string(buffer, buffer_index_pointer, string);
    variable new_line = 10;
    push_string(buffer, buffer_index_pointer, &(new_line));
};

function push_character(buffer: *, buffer_index_pointer: *integer, character: any_1) {
    push_string(buffer, buffer_index_pointer, &(character));
};

function push_integer(buffer: *, buffer_index_pointer: *integer, integer: integer) {
    variable integer_buffer: any_8;
    integer_to_string(integer, &(integer_buffer));
    push_string(buffer, buffer_index_pointer, &(integer_buffer));
};

function nodes_get_id2(nodes: *AutoBuffer, index: integer): integer {
    return autobuffer_get_integer(nodes, integer*(index, NODE_SIZE));
};

function nodes_get_pointer2(nodes: *AutoBuffer, index: integer): * {
    return autobuffer_get(nodes, integer*(index, NODE_SIZE));
};

function output_linux_x86-64(nodes: *AutoBuffer, node_count: integer, name: *, allocator: *BumpAllocator) {
    variable buffer: any_4096;
    variable buffer_index = 0;

    variable data_buffer: any_1024;
    variable data_buffer_index = 0;

    variable bss_buffer: any_1024;
    variable bss_buffer_index = 0;

    push_string_with_newline(&(buffer), &(buffer_index), "format ELF64 executable");
    push_string_with_newline(&(buffer), &(buffer_index), "entry start");
    push_string_with_newline(&(buffer), &(buffer_index), "segment readable executable");
    push_string_with_newline(&(buffer), &(buffer_index), "start:");
    push_string_with_newline(&(buffer), &(buffer_index), "lea rax, [rsp+8]");
    push_string_with_newline(&(buffer), &(buffer_index), "push rax");
    push_string_with_newline(&(buffer), &(buffer_index), "call main");
    push_string_with_newline(&(buffer), &(buffer_index), "mov rax, 60");
    push_string_with_newline(&(buffer), &(buffer_index), "mov rdi, 0");
    push_string_with_newline(&(buffer), &(buffer_index), "syscall");

    variable functions: any_512;
    variable function_argument_names: any_512;
    variable function_arguments: any_512;
    variable function_returns: any_512;
    variable function_local_sizes: any_512;
    variable index = 0;

    variable globals: any_512;
    variable global_types: any_512;
    variable global_index = 0;

    variable constants: any_512;
    variable constant_types: any_512;
    variable constant_index = 0;

    variable memory_functions: any_512;
    variable memory_function_contents: any_512;
    variable memory_function_index = 0;

    variable i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id2(nodes, i);
        variable pointer = nodes_get_pointer2(nodes, i);

        if =(id, NODE_FUNCTION) {
            variable function_name = *->(@cast_**(+(pointer, 8)));
            array8_set(&(functions), index, function_name);
            variable function_argument_names2 = *->(@cast_**(+(pointer, 16)));
            array8_set(&(function_argument_names), index, function_argument_names2);
            variable function_arguments2 = *->(@cast_**(+(pointer, 24)));
            array8_set(&(function_arguments), index, function_arguments2);
            variable function_returns2 = *->(@cast_**(+(pointer, 32)));
            array8_set(&(function_returns), index, function_returns2);

            variable total = 16;
            variable j = i;
            while !(=(nodes_get_id2(nodes, j), NODE_ENDFUNCTION)) {
                variable id = nodes_get_id2(nodes, j);
                variable pointer = nodes_get_pointer2(nodes, j);
                
                if =(id, NODE_DECLARE) {
                    variable declare_type = *->(@cast_**(+(pointer, 16)));
                    total = integer+(total, get_size_linux_x86-64(declare_type, nodes, node_count));
                };

                j = integer+(j, 1);
            };

            array8_set(&(function_local_sizes), index, total);

            index = integer+(index, 1);
        };
        if =(id, NODE_GLOBAL) {
            variable global_name = *->(@cast_**(+(pointer, 8)));
            variable global_type = *->(@cast_**(+(pointer, 16)));

            array8_set(&(globals), global_index, global_name);
            array8_set(&(global_types), global_index, global_type);

            if >(index, 63) {
                println("globals overflows buffer");
            };

            global_index = integer+(global_index, 1);
        };
        if =(id, NODE_CONSTANT) {
            variable constant_name = *->(@cast_**(+(pointer, 8)));
            variable constant_type = *->(@cast_**(+(pointer, 16)));

            array8_set(&(constants), constant_index, constant_name);
            array8_set(&(constant_types), constant_index, constant_type);

            if >(index, 63) {
                println("constants overflows buffer");
            };

            constant_index = integer+(constant_index, 1);
        };
        if =(id, NODE_STRUCTURE) {
            variable structure_name = *->(@cast_**(+(nodes_get_pointer2(nodes, i), 8)));

            // Setter for whole value
            variable allocated = bump_allocate(allocator, integer+(length(structure_name), 3));
            copy(structure_name, allocated, length(structure_name));
            copy("<-", @cast_*(+(allocated, length(structure_name))), 2);

            array8_set(&(memory_functions), memory_function_index, allocated);

            variable allocated_contents = bump_allocate(allocator, 128);
            variable contents_index = 0;

            variable size = get_size_linux_x86-64(structure_name, nodes, node_count);

            push_string(allocated_contents, &(contents_index), "add rsp, ");
            push_integer(allocated_contents, &(contents_index), size);
            push_string_with_newline(allocated_contents, &(contents_index), "");
            push_string_with_newline(allocated_contents, &(contents_index), "mov rax, [rsp]");
            push_string(allocated_contents, &(contents_index), "sub rsp, ");
            push_integer(allocated_contents, &(contents_index), size);
            push_string_with_newline(allocated_contents, &(contents_index), "");

            variable j = 0;
            while <(j, size) {
                variable done_anything_structure = false;

                if >(-(size, j), 7) {
                    push_string(allocated_contents, &(contents_index), "mov rbx, [rsp+");
                    push_integer(allocated_contents, &(contents_index), j);
                    push_string_with_newline(allocated_contents, &(contents_index), "]");

                    push_string(allocated_contents, &(contents_index), "mov [rax+");
                    push_integer(allocated_contents, &(contents_index), j);
                    push_string_with_newline(allocated_contents, &(contents_index), "], rbx");

                    j = integer+(j, 8);
                    done_anything_structure = true;
                };
                if &&(>(-(size, j), 3), !(done_anything_structure)) {
                    push_string(allocated_contents, &(contents_index), "mov ebx, [rsp+");
                    push_integer(allocated_contents, &(contents_index), j);
                    push_string_with_newline(allocated_contents, &(contents_index), "]");

                    push_string(allocated_contents, &(contents_index), "mov [rax+");
                    push_integer(allocated_contents, &(contents_index), j);
                    push_string_with_newline(allocated_contents, &(contents_index), "], ebx");

                    j = integer+(j, 4);
                    done_anything_structure = true;
                };
                if &&(>(-(size, j), 1), !(done_anything_structure)) {
                    push_string(allocated_contents, &(contents_index), "mov bx, [rsp+");
                    push_integer(allocated_contents, &(contents_index), j);
                    push_string_with_newline(allocated_contents, &(contents_index), "]");

                    push_string(allocated_contents, &(contents_index), "mov [rax+");
                    push_integer(allocated_contents, &(contents_index), j);
                    push_string_with_newline(allocated_contents, &(contents_index), "], bx");

                    j = integer+(j, 2);
                    done_anything_structure = true;
                };
                if &&(>(-(size, j), 0), !(done_anything_structure)) {
                    push_string(allocated_contents, &(contents_index), "mov bl, [rsp+");
                    push_integer(allocated_contents, &(contents_index), j);
                    push_string_with_newline(allocated_contents, &(contents_index), "]");

                    push_string(allocated_contents, &(contents_index), "mov [rax+");
                    push_integer(allocated_contents, &(contents_index), j);
                    push_string_with_newline(allocated_contents, &(contents_index), "], bl");

                    j = integer+(j, 1);
                    done_anything_structure = true;
                };
            };

            push_string(allocated_contents, &(contents_index), "add rsp, ");
            push_integer(allocated_contents, &(contents_index), integer+(size, 8));
            push_string_with_newline(allocated_contents, &(contents_index), "");

            array8_set(&(memory_function_contents), memory_function_index, allocated_contents);

            memory_function_index = integer+(memory_function_index, 1);

            // Getter for whole value
            variable allocated = bump_allocate(allocator, integer+(length(structure_name), 3));
            copy(structure_name, allocated, length(structure_name));
            copy("->", @cast_*(+(allocated, length(structure_name))), 2);

            array8_set(&(memory_functions), memory_function_index, allocated);

            variable allocated_contents = bump_allocate(allocator, 128);
            variable contents_index = 0;

            push_string_with_newline(allocated_contents, &(contents_index), "pop rax");
            push_string(allocated_contents, &(contents_index), "sub rsp, ");
            push_integer(allocated_contents, &(contents_index), size);
            push_string_with_newline(allocated_contents, &(contents_index), "");

            variable k = 0;
            while <(k, size) {
                variable done_anything_structure = false;

                if >(-(size, k), 7) {
                    push_string(allocated_contents, &(contents_index), "mov rbx, [rax+");
                    push_integer(allocated_contents, &(contents_index), k);
                    push_string_with_newline(allocated_contents, &(contents_index), "]");

                    push_string(allocated_contents, &(contents_index), "mov [rsp+");
                    push_integer(allocated_contents, &(contents_index), k);
                    push_string_with_newline(allocated_contents, &(contents_index), "], rbx");

                    k = integer+(k, 8);
                    done_anything_structure = true;
                };
                if &&(>(-(size, k), 3), !(done_anything_structure)) {
                    push_string(allocated_contents, &(contents_index), "mov ebx, [rax+");
                    push_integer(allocated_contents, &(contents_index), k);
                    push_string_with_newline(allocated_contents, &(contents_index), "]");

                    push_string(allocated_contents, &(contents_index), "mov [rsp+");
                    push_integer(allocated_contents, &(contents_index), k);
                    push_string_with_newline(allocated_contents, &(contents_index), "], ebx");

                    k = integer+(k, 4);
                    done_anything_structure = true;
                };
                if &&(>(-(size, k), 1), !(done_anything_structure)) {
                    push_string(allocated_contents, &(contents_index), "mov bx, [rax+");
                    push_integer(allocated_contents, &(contents_index), k);
                    push_string_with_newline(allocated_contents, &(contents_index), "]");

                    push_string(allocated_contents, &(contents_index), "mov [rsp+");
                    push_integer(allocated_contents, &(contents_index), k);
                    push_string_with_newline(allocated_contents, &(contents_index), "], bx");

                    k = integer+(k, 2);
                    done_anything_structure = true;
                };
                if &&(>(-(size, k), 0), !(done_anything_structure)) {
                    push_string(allocated_contents, &(contents_index), "mov bl, [rax+");
                    push_integer(allocated_contents, &(contents_index), k);
                    push_string_with_newline(allocated_contents, &(contents_index), "]");

                    push_string(allocated_contents, &(contents_index), "mov [rsp+");
                    push_integer(allocated_contents, &(contents_index), k);
                    push_string_with_newline(allocated_contents, &(contents_index), "], bl");

                    k = integer+(k, 1);
                    done_anything_structure = true;
                };
            };

            array8_set(&(memory_function_contents), memory_function_index, allocated_contents);

            memory_function_index = integer+(memory_function_index, 1);

            variable member_names = *->(@cast_**(+(nodes_get_pointer2(nodes, i), 16)));
            variable member_types = *->(@cast_**(+(nodes_get_pointer2(nodes, i), 24)));

            variable j = 0;
            while !(=(array8_get(member_names, j), 0)) {
                variable member_name = @cast_*(array8_get(member_names, j));
                variable member_type = @cast_*(array8_get(member_types, j));

                // Setter for individual members
                variable allocated = bump_allocate(allocator, integer+(length(structure_name), integer+(length(member_name), 3)));
                copy(structure_name, allocated, length(structure_name));
                copy("<-", @cast_*(+(allocated, length(structure_name))), 2);
                copy(member_name, @cast_*(+(allocated, +(length(structure_name), 2))), length(member_name));

                array8_set(&(memory_functions), memory_function_index, allocated);

                variable allocated_contents = bump_allocate(allocator, 128);
                variable contents_index = 0;

                variable size = get_size_linux_x86-64(member_type, nodes, node_count);
                variable location = get_size_multiple_linux_x86-64(member_types, j, nodes, node_count);

                push_string(allocated_contents, &(contents_index), "add rsp, ");
                push_integer(allocated_contents, &(contents_index), size);
                push_string_with_newline(allocated_contents, &(contents_index), "");
                push_string_with_newline(allocated_contents, &(contents_index), "mov rax, [rsp]");
                push_string(allocated_contents, &(contents_index), "sub rsp, ");
                push_integer(allocated_contents, &(contents_index), size);
                push_string_with_newline(allocated_contents, &(contents_index), "");

                variable k = 0;
                while <(k, size) {
                    variable done_anything_structure = false;

                    if >(-(size, k), 7) {
                        push_string(allocated_contents, &(contents_index), "mov rbx, [rsp+");
                        push_integer(allocated_contents, &(contents_index), k);
                        push_string_with_newline(allocated_contents, &(contents_index), "]");

                        push_string(allocated_contents, &(contents_index), "mov [rax+");
                        push_integer(allocated_contents, &(contents_index), integer+(k, location));
                        push_string_with_newline(allocated_contents, &(contents_index), "], rbx");

                        k = integer+(k, 8);
                        done_anything_structure = true;
                    };
                    if &&(>(-(size, k), 3), !(done_anything_structure)) {
                        push_string(allocated_contents, &(contents_index), "mov ebx, [rsp+");
                        push_integer(allocated_contents, &(contents_index), k);
                        push_string_with_newline(allocated_contents, &(contents_index), "]");

                        push_string(allocated_contents, &(contents_index), "mov [rax+");
                        push_integer(allocated_contents, &(contents_index), integer+(k, location));
                        push_string_with_newline(allocated_contents, &(contents_index), "], ebx");

                        k = integer+(k, 4);
                        done_anything_structure = true;
                    };
                    if &&(>(-(size, k), 1), !(done_anything_structure)) {
                        push_string(allocated_contents, &(contents_index), "mov bx, [rsp+");
                        push_integer(allocated_contents, &(contents_index), k);
                        push_string_with_newline(allocated_contents, &(contents_index), "]");

                        push_string(allocated_contents, &(contents_index), "mov [rax+");
                        push_integer(allocated_contents, &(contents_index), integer+(k, location));
                        push_string_with_newline(allocated_contents, &(contents_index), "], bx");

                        k = integer+(k, 2);
                        done_anything_structure = true;
                    };
                    if &&(>(-(size, k), 0), !(done_anything_structure)) {
                        push_string(allocated_contents, &(contents_index), "mov bl, [rsp+");
                        push_integer(allocated_contents, &(contents_index), k);
                        push_string_with_newline(allocated_contents, &(contents_index), "]");

                        push_string(allocated_contents, &(contents_index), "mov [rax+");
                        push_integer(allocated_contents, &(contents_index), integer+(k, location));
                        push_string_with_newline(allocated_contents, &(contents_index), "], bl");

                        k = integer+(k, 1);
                        done_anything_structure = true;
                    };
                };

                push_string(allocated_contents, &(contents_index), "add rsp, ");
                push_integer(allocated_contents, &(contents_index), integer+(size, 8));
                push_string_with_newline(allocated_contents, &(contents_index), "");

                array8_set(&(memory_function_contents), memory_function_index, allocated_contents);

                memory_function_index = integer+(memory_function_index, 1);

                // Getter for indivudal members
                variable allocated = bump_allocate(allocator, integer+(length(structure_name), integer+(length(member_name), 3)));
                copy(structure_name, allocated, length(structure_name));
                copy("->", @cast_*(+(allocated, length(structure_name))), 2);
                copy(member_name, @cast_*(+(allocated, +(length(structure_name), 2))), length(member_name));

                array8_set(&(memory_functions), memory_function_index, allocated);

                variable allocated_contents = bump_allocate(allocator, 128);
                variable contents_index = 0;

                variable size = get_size_linux_x86-64(member_type, nodes, node_count);
                variable location = get_size_multiple_linux_x86-64(member_types, j, nodes, node_count);

                push_string_with_newline(allocated_contents, &(contents_index), "pop rax");
                push_string(allocated_contents, &(contents_index), "sub rsp, ");
                push_integer(allocated_contents, &(contents_index), size);
                push_string_with_newline(allocated_contents, &(contents_index), "");

                variable k = 0;
                while <(k, size) {
                    variable done_anything_structure = false;

                    if >(-(size, k), 7) {
                        push_string(allocated_contents, &(contents_index), "mov rbx, [rax+");
                        push_integer(allocated_contents, &(contents_index), integer+(k, location));
                        push_string_with_newline(allocated_contents, &(contents_index), "]");

                        push_string(allocated_contents, &(contents_index), "mov [rsp+");
                        push_integer(allocated_contents, &(contents_index), k);
                        push_string_with_newline(allocated_contents, &(contents_index), "], rbx");

                        k = integer+(k, 8);
                        done_anything_structure = true;
                    };
                    if &&(>(-(size, k), 3), !(done_anything_structure)) {
                        push_string(allocated_contents, &(contents_index), "mov ebx, [rax+");
                        push_integer(allocated_contents, &(contents_index), integer+(k, location));
                        push_string_with_newline(allocated_contents, &(contents_index), "]");

                        push_string(allocated_contents, &(contents_index), "mov [rsp+");
                        push_integer(allocated_contents, &(contents_index), k);
                        push_string_with_newline(allocated_contents, &(contents_index), "], ebx");

                        k = integer+(k, 4);
                        done_anything_structure = true;
                    };
                    if &&(>(-(size, k), 1), !(done_anything_structure)) {
                        push_string(allocated_contents, &(contents_index), "mov bx, [rax+");
                        push_integer(allocated_contents, &(contents_index), integer+(k, location));
                        push_string_with_newline(allocated_contents, &(contents_index), "]");

                        push_string(allocated_contents, &(contents_index), "mov [rsp+");
                        push_integer(allocated_contents, &(contents_index), k);
                        push_string_with_newline(allocated_contents, &(contents_index), "], bx");

                        k = integer+(k, 2);
                        done_anything_structure = true;
                    };
                    if &&(>(-(size, k), 0), !(done_anything_structure)) {
                        push_string(allocated_contents, &(contents_index), "mov bl, [rax+");
                        push_integer(allocated_contents, &(contents_index), integer+(k, location));
                        push_string_with_newline(allocated_contents, &(contents_index), "]");

                        push_string(allocated_contents, &(contents_index), "mov [rsp+");
                        push_integer(allocated_contents, &(contents_index), k);
                        push_string_with_newline(allocated_contents, &(contents_index), "], bl");

                        k = integer+(k, 1);
                        done_anything_structure = true;
                    };
                };

                array8_set(&(memory_function_contents), memory_function_index, allocated_contents);

                memory_function_index = integer+(memory_function_index, 1);

                j = integer+(j, 1);
            };
        };

        i = integer+(i, 1);
    };

    variable current_function: *;

    variable variable_names: any_128;
    variable variable_types: any_128;
    variable variable_index = 0;

    variable program_constant_index = 0;

    variable i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id2(nodes, i);
        variable pointer = nodes_get_pointer2(nodes, i);

        variable done_anything = false;

        if =(id, NODE_FUNCTION) {
            variable next_id = nodes_get_id2(nodes, integer+(i, 1));

            if !(=(next_id, NODE_ENDFUNCTION)) {
                variable function_name = *->(@cast_**(+(pointer, 8)));
                push_string(&(buffer), &(buffer_index), function_name);
                push_string_with_newline(&(buffer), &(buffer_index), ":");
                push_string_with_newline(&(buffer), &(buffer_index), "push rbp");
                push_string_with_newline(&(buffer), &(buffer_index), "mov rbp, rsp");

                variable locals_size = @cast_integer(stringarraymap_get(&(functions), &(function_local_sizes), function_name, index));
                push_string(&(buffer), &(buffer_index), "sub rsp, ");
                //TODO: use max stack??
                push_integer(&(buffer), &(buffer_index), integer+(locals_size, 16));
                push_string_with_newline(&(buffer), &(buffer_index), "");

                current_function = function_name;

                variable_index = 0;
            };

            done_anything = true;
        };

        if =(id, NODE_INTEGER) {
            variable value = integer->(@cast_*integer(+(pointer, 8)));

            push_string(&(buffer), &(buffer_index), "push ");
            push_integer(&(buffer), &(buffer_index), value);
            push_string_with_newline(&(buffer), &(buffer_index), "");
            done_anything = true;
        };

        if =(id, NODE_BOOLEAN) {
            variable value = any_1->(@cast_*any_1(+(pointer, 8)));

            if @cast_boolean(value) {
                push_string_with_newline(&(buffer), &(buffer_index), "sub rsp, 1");
                push_string_with_newline(&(buffer), &(buffer_index), "mov [rsp], byte 1");
                done_anything = true;
            };

            if !(done_anything) {
                push_string_with_newline(&(buffer), &(buffer_index), "sub rsp, 1");
                push_string_with_newline(&(buffer), &(buffer_index), "mov [rsp], byte 0");
                done_anything = true;
            };
        };

        if =(id, NODE_INVOKE) {
            variable function_name = *->(@cast_**(+(pointer, 8)));

            variable done_anything_invoke = false;

            if !(=(stringarraymap_get(&(memory_functions), &(memory_function_contents), function_name, memory_function_index), 0)) {
                variable contents = stringarraymap_get(&(memory_functions), &(memory_function_contents), function_name, memory_function_index);
                push_string(&(buffer), &(buffer_index), contents);
                done_anything_invoke = true;
            };

            if string_length=(function_name, "@cast_", 6) {
                done_anything_invoke = true;
            };

            if string=(function_name, "=") {
                push_string_with_newline(&(buffer), &(buffer_index), "pop rax");
                push_string_with_newline(&(buffer), &(buffer_index), "pop rbx");
                push_string_with_newline(&(buffer), &(buffer_index), "cmp rax, rbx");
                push_string_with_newline(&(buffer), &(buffer_index), "mov rcx, 0");
                push_string_with_newline(&(buffer), &(buffer_index), "mov rbx, 1");
                push_string_with_newline(&(buffer), &(buffer_index), "cmove rcx, rbx");
                push_string_with_newline(&(buffer), &(buffer_index), "sub rsp, 1");
                push_string_with_newline(&(buffer), &(buffer_index), "mov [rsp], cl");
                done_anything_invoke = true;
            };

            if string=(function_name, "!") {
                push_string_with_newline(&(buffer), &(buffer_index), "mov al, [rsp]");
                push_string_with_newline(&(buffer), &(buffer_index), "add rsp, 1");
                push_string_with_newline(&(buffer), &(buffer_index), "cmp al, 0");
                push_string_with_newline(&(buffer), &(buffer_index), "mov cx, 0");
                push_string_with_newline(&(buffer), &(buffer_index), "mov bx, 1");
                push_string_with_newline(&(buffer), &(buffer_index), "cmove cx, bx");
                push_string_with_newline(&(buffer), &(buffer_index), "sub rsp, 1");
                push_string_with_newline(&(buffer), &(buffer_index), "mov [rsp], cl");
                done_anything_invoke = true;
            };
            
            if string=(function_name, "+") {
                push_string_with_newline(&(buffer), &(buffer_index), "pop rax");
                push_string_with_newline(&(buffer), &(buffer_index), "pop rbx");
                push_string_with_newline(&(buffer), &(buffer_index), "add rax, rbx");
                push_string_with_newline(&(buffer), &(buffer_index), "push rax");
                done_anything_invoke = true;
            };

            if string=(function_name, "@syscall3") {
                push_string_with_newline(&(buffer), &(buffer_index), "pop rdx");
                push_string_with_newline(&(buffer), &(buffer_index), "pop rsi");
                push_string_with_newline(&(buffer), &(buffer_index), "pop rdi");
                push_string_with_newline(&(buffer), &(buffer_index), "pop rax");
                push_string_with_newline(&(buffer), &(buffer_index), "syscall");
                done_anything_invoke = true;
            };

            if !(done_anything_invoke) {
                push_string(&(buffer), &(buffer_index), "call ");
                push_string_with_newline(&(buffer), &(buffer_index), function_name);
            };
            done_anything = true;
        };

        if =(id, NODE_STRING) {
            variable string_value = *->(@cast_**(+(pointer, 8)));
            variable string_id = program_constant_index;
            program_constant_index = @cast_integer(+(program_constant_index, 1));

            variable id_string: any_8;
            integer_to_string(string_id, &(id_string));

            push_string(&(buffer), &(buffer_index), "push _");
            push_string_with_newline(&(buffer), &(buffer_index), &(id_string));

            push_string(&(data_buffer), &(data_buffer_index), "_");
            push_string(&(data_buffer), &(data_buffer_index), &(id_string));
            push_string(&(data_buffer), &(data_buffer_index), ": db ");
            push_character(&(data_buffer), &(data_buffer_index), byte(34));
            push_string(&(data_buffer), &(data_buffer_index), string_value);
            push_character(&(data_buffer), &(data_buffer_index), byte(34));
            push_string_with_newline(&(data_buffer), &(data_buffer_index), ", 0");

            done_anything = true;
        };

        if =(id, NODE_DECLARE) {
            variable variable_name = *->(@cast_**(+(pointer, 8)));
            variable variable_type = *->(@cast_**(+(pointer, 16)));

            array8_set(&(variable_names), variable_index, variable_name);
            array8_set(&(variable_types), variable_index, variable_type);
            variable_index = integer+(variable_index, 1);
            if >(variable_index, 15) {
                println("type_check variable_index overflows buffer");
            };

            done_anything = true;
        };

        if =(id, NODE_ASSIGN) {
            variable variable_name = *->(@cast_**(+(pointer, 8)));
            variable variable_type = stringarraymap_get(&(variable_names), &(variable_types), variable_name, variable_index);

            if !(=(variable_type, 0)) {
                variable size = get_size_linux_x86-64(variable_type, nodes, node_count);
                variable location = get_size_multiple_linux_x86-64(&(variable_types), stringarraymap_get_index(&(variable_names), variable_name, variable_index), nodes, node_count);

                variable j = 0;
                while <(j, size) {
                    variable done_anything_assign = false;

                    if >(-(size, j), 7) {
                        push_string(&(buffer), &(buffer_index), "mov rax, [rsp+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "]");

                        push_string(&(buffer), &(buffer_index), "mov [rbp-");
                        push_integer(&(buffer), &(buffer_index), @cast_integer(-(+(size, location), j)));
                        push_string_with_newline(&(buffer), &(buffer_index), "], rax");

                        j = integer+(j, 8);
                        done_anything_assign = true;
                    };
                    if &&(>(-(size, j), 3), !(done_anything_assign)) {
                        push_string(&(buffer), &(buffer_index), "mov eax, [rsp+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "]");

                        push_string(&(buffer), &(buffer_index), "mov [rbp-");
                        push_integer(&(buffer), &(buffer_index), @cast_integer(-(+(size, location), j)));
                        push_string_with_newline(&(buffer), &(buffer_index), "], eax");

                        j = integer+(j, 4);
                        done_anything_assign = true;
                    };
                    if &&(>(-(size, j), 1), !(done_anything_assign)) {
                        push_string(&(buffer), &(buffer_index), "mov ax, [rsp+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "]");

                        push_string(&(buffer), &(buffer_index), "mov [rbp-");
                        push_integer(&(buffer), &(buffer_index), @cast_integer(-(+(size, location), j)));
                        push_string_with_newline(&(buffer), &(buffer_index), "], ax");

                        j = integer+(j, 2);
                        done_anything_assign = true;
                    };
                    if &&(>(-(size, j), 0), !(done_anything_assign)) {
                        push_string(&(buffer), &(buffer_index), "mov al, [rsp+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "]");

                        push_string(&(buffer), &(buffer_index), "mov [rbp-");
                        push_integer(&(buffer), &(buffer_index), @cast_integer(-(+(size, location), j)));
                        push_string_with_newline(&(buffer), &(buffer_index), "], al");

                        j = integer+(j, 1);
                        done_anything_assign = true;
                    };
                };


                push_string(&(buffer), &(buffer_index), "add rsp, ");
                push_integer(&(buffer), &(buffer_index), size);
                push_string_with_newline(&(buffer), &(buffer_index), "");
            };

            if =(variable_type, 0) {
                variable_type = stringarraymap_get(&(globals), &(global_types), variable_name, global_index);
                variable size = get_size_linux_x86-64(variable_type, nodes, node_count);

                variable j = 0;
                while <(j, size) {
                    variable done_anything_assign = false;

                    if >(-(size, j), 7) {
                        push_string(&(buffer), &(buffer_index), "mov rax, [rsp+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "]");

                        push_string(&(buffer), &(buffer_index), "mov [");
                        push_string(&(buffer), &(buffer_index), global_name);
                        push_string(&(buffer), &(buffer_index), "+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "], rax");

                        j = integer+(j, 8);
                        done_anything_assign = true;
                    };
                    if &&(>(-(size, j), 3), !(done_anything_assign)) {
                        push_string(&(buffer), &(buffer_index), "mov eax, [rsp+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "]");

                        push_string(&(buffer), &(buffer_index), "mov [");
                        push_string(&(buffer), &(buffer_index), global_name);
                        push_string(&(buffer), &(buffer_index), "+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "], eax");

                        j = integer+(j, 4);
                        done_anything_assign = true;
                    };
                    if &&(>(-(size, j), 1), !(done_anything_assign)) {
                        push_string(&(buffer), &(buffer_index), "mov ax, [rsp+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "]");

                        push_string(&(buffer), &(buffer_index), "mov [");
                        push_string(&(buffer), &(buffer_index), global_name);
                        push_string(&(buffer), &(buffer_index), "+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "], ax");

                        j = integer+(j, 2);
                        done_anything_assign = true;
                    };
                    if &&(>(-(size, j), 0), !(done_anything_assign)) {
                        push_string(&(buffer), &(buffer_index), "mov al, [rsp+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "]");

                        push_string(&(buffer), &(buffer_index), "mov [");
                        push_string(&(buffer), &(buffer_index), global_name);
                        push_string(&(buffer), &(buffer_index), "+");
                        push_integer(&(buffer), &(buffer_index), j);
                        push_string_with_newline(&(buffer), &(buffer_index), "], al");

                        j = integer+(j, 1);
                        done_anything_assign = true;
                    };
                };


                push_string(&(buffer), &(buffer_index), "add rsp, ");
                push_integer(&(buffer), &(buffer_index), size);
                push_string_with_newline(&(buffer), &(buffer_index), "");
            };

            done_anything = true;
        };

        if =(id, NODE_RETRIEVE) {
            variable next_id = nodes_get_id2(nodes, integer+(i, 1));

            variable variable_name = *->(@cast_**(+(pointer, 8)));
            variable variable_type = stringarraymap_get(&(variable_names), &(variable_types), variable_name, variable_index);
            if !(=(variable_type, 0)) {
                variable size = get_size_linux_x86-64(variable_type, nodes, node_count);
                variable location = get_size_multiple_linux_x86-64(&(variable_types), stringarraymap_get_index(&(variable_names), variable_name, variable_index), nodes, node_count);

                variable is_pointer = false;
                if =(next_id, NODE_POINTER) {
                    push_string(&(buffer), &(buffer_index), "lea rax, [rbp-");
                    push_integer(&(buffer), &(buffer_index), integer+(size, location));
                    push_string_with_newline(&(buffer), &(buffer_index), "]");
                    push_string_with_newline(&(buffer), &(buffer_index), "push rax");

                    is_pointer = true;
                };

                if !(is_pointer) {
                    push_string(&(buffer), &(buffer_index), "sub rsp, ");
                    push_integer(&(buffer), &(buffer_index), size);
                    push_string_with_newline(&(buffer), &(buffer_index), "");

                    variable j = 0;
                    while <(j, size) {
                        variable done_anything_assign = false;

                        if >(-(size, j), 7) {
                            push_string(&(buffer), &(buffer_index), "mov rax, [rbp-");
                            push_integer(&(buffer), &(buffer_index), @cast_integer(-(+(size, location), j)));
                            push_string_with_newline(&(buffer), &(buffer_index), "]");

                            push_string(&(buffer), &(buffer_index), "mov [rsp+");
                            push_integer(&(buffer), &(buffer_index), j);
                            push_string_with_newline(&(buffer), &(buffer_index), "], rax");

                            j = integer+(j, 8);
                            done_anything_assign = true;
                        };
                        if &&(>(-(size, j), 3), !(done_anything_assign)) {
                            push_string(&(buffer), &(buffer_index), "mov eax, [rbp-");
                            push_integer(&(buffer), &(buffer_index), @cast_integer(-(+(size, location), j)));
                            push_string_with_newline(&(buffer), &(buffer_index), "]");

                            push_string(&(buffer), &(buffer_index), "mov [rsp+");
                            push_integer(&(buffer), &(buffer_index), j);
                            push_string_with_newline(&(buffer), &(buffer_index), "], eax");

                            j = integer+(j, 4);
                            done_anything_assign = true;
                        };
                        if &&(>(-(size, j), 1), !(done_anything_assign)) {
                            push_string(&(buffer), &(buffer_index), "mov ax, [rbp-");
                            push_integer(&(buffer), &(buffer_index), @cast_integer(-(+(size, location), j)));
                            push_string_with_newline(&(buffer), &(buffer_index), "]");

                            push_string(&(buffer), &(buffer_index), "mov [rsp+");
                            push_integer(&(buffer), &(buffer_index), j);
                            push_string_with_newline(&(buffer), &(buffer_index), "], ax");

                            j = integer+(j, 2);
                            done_anything_assign = true;
                        };
                        if &&(>(-(size, j), 0), !(done_anything_assign)) {
                            push_string(&(buffer), &(buffer_index), "mov al, [rbp-");
                            push_integer(&(buffer), &(buffer_index), @cast_integer(-(+(size, location), j)));
                            push_string_with_newline(&(buffer), &(buffer_index), "]");

                            push_string(&(buffer), &(buffer_index), "mov [rsp+");
                            push_integer(&(buffer), &(buffer_index), j);
                            push_string_with_newline(&(buffer), &(buffer_index), "], al");

                            j = integer+(j, 1);
                            done_anything_assign = true;
                        };
                    };
                };

            };
            
            if =(variable_type, 0) {
                variable function_argument_names2 = stringarraymap_get(&(functions), &(function_argument_names), current_function, index);
                variable function_arguments2 = stringarraymap_get(&(functions), &(function_arguments), current_function, index);

                variable_type = stringarraymap_get(function_argument_names2, function_arguments2, variable_name, array8_length(function_arguments2));

                if !(=(variable_type, 0)) {
                    variable size = get_size_linux_x86-64(variable_type, nodes, node_count);
                    variable location = get_size_multiple_reversed_linux_x86-64(function_arguments2, stringarraymap_get_index(function_argument_names2, variable_name, array8_length(function_argument_names2)), nodes, node_count);

                    variable is_pointer = false;
                    if =(next_id, NODE_POINTER) {
                        push_string(&(buffer), &(buffer_index), "lea rax, [rbp+");
                        push_integer(&(buffer), &(buffer_index), integer+(16, location));
                        push_string_with_newline(&(buffer), &(buffer_index), "]");
                        push_string_with_newline(&(buffer), &(buffer_index), "push rax");

                        is_pointer = true;
                    };

                    if !(is_pointer) {
                        push_string(&(buffer), &(buffer_index), "sub rsp, ");
                        push_integer(&(buffer), &(buffer_index), size);
                        push_string_with_newline(&(buffer), &(buffer_index), "");

                        variable j = 0;
                        while <(j, size) {
                            if >(-(size, j), 7) {
                                push_string(&(buffer), &(buffer_index), "mov rax, [rbp+");
                                push_integer(&(buffer), &(buffer_index), @cast_integer(+(+(16, location), j)));
                                push_string_with_newline(&(buffer), &(buffer_index), "]");

                                push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                push_integer(&(buffer), &(buffer_index), j);
                                push_string_with_newline(&(buffer), &(buffer_index), "], rax");

                                j = integer+(j, 8);
                                done_anything_assign = true;
                            };
                            if &&(>(-(size, j), 3), !(done_anything_assign)) {
                                push_string(&(buffer), &(buffer_index), "mov eax, [rbp+");
                                push_integer(&(buffer), &(buffer_index), @cast_integer(+(+(16, location), j)));
                                push_string_with_newline(&(buffer), &(buffer_index), "]");

                                push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                push_integer(&(buffer), &(buffer_index), j);
                                push_string_with_newline(&(buffer), &(buffer_index), "], eax");

                                j = integer+(j, 4);
                                done_anything_assign = true;
                            };
                            if &&(>(-(size, j), 1), !(done_anything_assign)) {
                                push_string(&(buffer), &(buffer_index), "mov ax, [rbp+");
                                push_integer(&(buffer), &(buffer_index), @cast_integer(+(+(16, location), j)));
                                push_string_with_newline(&(buffer), &(buffer_index), "]");

                                push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                push_integer(&(buffer), &(buffer_index), j);
                                push_string_with_newline(&(buffer), &(buffer_index), "], ax");

                                j = integer+(j, 2);
                                done_anything_assign = true;
                            };
                            if &&(>(-(size, j), 0), !(done_anything_assign)) {
                                push_string(&(buffer), &(buffer_index), "mov al, [rbp=");
                                push_integer(&(buffer), &(buffer_index), @cast_integer(+(+(16, location), j)));
                                push_string_with_newline(&(buffer), &(buffer_index), "]");

                                push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                push_integer(&(buffer), &(buffer_index), j);
                                push_string_with_newline(&(buffer), &(buffer_index), "], al");

                                j = integer+(j, 1);
                                done_anything_assign = true;
                            };
                        };
                    };
                };

                if =(variable_type, 0) {
                    variable_type = stringarraymap_get(&(globals), &(global_types), variable_name, global_index);

                    if !(=(variable_type, 0)) {
                        variable global_name = bump_allocate(allocator, integer+(length(variable_name), 1));
                        copy("_", global_name, 1);
                        copy(variable_name, @cast_*(+(global_name, 1)), length(variable_name));

                        variable size = get_size_linux_x86-64(variable_type, nodes, node_count);

                        variable is_pointer = false;
                        if =(next_id, NODE_POINTER) {
                            push_string(&(buffer), &(buffer_index), "lea rax, [");
                            push_string(&(buffer), &(buffer_index), global_name);
                            push_string_with_newline(&(buffer), &(buffer_index), "]");
                            push_string_with_newline(&(buffer), &(buffer_index), "push rax");

                            is_pointer = true;
                        };

                        if !(is_pointer) {
                            push_string(&(buffer), &(buffer_index), "sub rsp, ");
                            push_integer(&(buffer), &(buffer_index), size);
                            push_string_with_newline(&(buffer), &(buffer_index), "");

                            variable j = 0;
                            while <(j, size) {
                                if >(-(size, j), 7) {
                                    push_string(&(buffer), &(buffer_index), "mov rax, [");
                                    push_string(&(buffer), &(buffer_index), global_name);
                                    push_string(&(buffer), &(buffer_index), "+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                                    push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "], rax");

                                    j = integer+(j, 8);
                                    done_anything_assign = true;
                                };
                                if &&(>(-(size, j), 3), !(done_anything_assign)) {
                                    push_string(&(buffer), &(buffer_index), "mov eax, [");
                                    push_string(&(buffer), &(buffer_index), global_name);
                                    push_string(&(buffer), &(buffer_index), "+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                                    push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "], eax");

                                    j = integer+(j, 4);
                                    done_anything_assign = true;
                                };
                                if &&(>(-(size, j), 1), !(done_anything_assign)) {
                                    push_string(&(buffer), &(buffer_index), "mov ax, [");
                                    push_string(&(buffer), &(buffer_index), global_name);
                                    push_string(&(buffer), &(buffer_index), "+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                                    push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "], ax");

                                    j = integer+(j, 2);
                                    done_anything_assign = true;
                                };
                                if &&(>(-(size, j), 0), !(done_anything_assign)) {
                                    push_string(&(buffer), &(buffer_index), "mov al, [");
                                    push_string(&(buffer), &(buffer_index), global_name);
                                    push_string(&(buffer), &(buffer_index), "+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                                    push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "], al");

                                    j = integer+(j, 1);
                                    done_anything_assign = true;
                                };
                            };
                        };
                    };

                    if =(variable_type, 0) {
                        variable_type = stringarraymap_get(&(constants), &(constant_types), variable_name, constant_index);

                        variable global_name = bump_allocate(allocator, integer+(length(variable_name), 1));
                        copy("_", global_name, 1);
                        copy(variable_name, @cast_*(+(global_name, 1)), length(variable_name));

                        variable size = get_size_linux_x86-64(variable_type, nodes, node_count);

                        variable is_pointer = false;
                        if =(next_id, NODE_POINTER) {
                            push_string(&(buffer), &(buffer_index), "lea rax, [");
                            push_string(&(buffer), &(buffer_index), global_name);
                            push_string_with_newline(&(buffer), &(buffer_index), "]");
                            push_string_with_newline(&(buffer), &(buffer_index), "push rax");

                            is_pointer = true;
                        };

                        if !(is_pointer) {
                            push_string(&(buffer), &(buffer_index), "sub rsp, ");
                            push_integer(&(buffer), &(buffer_index), size);
                            push_string_with_newline(&(buffer), &(buffer_index), "");

                            variable j = 0;
                            while <(j, size) {
                                if >(-(size, j), 7) {
                                    push_string(&(buffer), &(buffer_index), "mov rax, [");
                                    push_string(&(buffer), &(buffer_index), global_name);
                                    push_string(&(buffer), &(buffer_index), "+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                                    push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "], rax");

                                    j = integer+(j, 8);
                                    done_anything_assign = true;
                                };
                                if &&(>(-(size, j), 3), !(done_anything_assign)) {
                                    push_string(&(buffer), &(buffer_index), "mov eax, [");
                                    push_string(&(buffer), &(buffer_index), global_name);
                                    push_string(&(buffer), &(buffer_index), "+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                                    push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "], eax");

                                    j = integer+(j, 4);
                                    done_anything_assign = true;
                                };
                                if &&(>(-(size, j), 1), !(done_anything_assign)) {
                                    push_string(&(buffer), &(buffer_index), "mov ax, [");
                                    push_string(&(buffer), &(buffer_index), global_name);
                                    push_string(&(buffer), &(buffer_index), "+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                                    push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "], ax");

                                    j = integer+(j, 2);
                                    done_anything_assign = true;
                                };
                                if &&(>(-(size, j), 0), !(done_anything_assign)) {
                                    push_string(&(buffer), &(buffer_index), "mov al, [");
                                    push_string(&(buffer), &(buffer_index), global_name);
                                    push_string(&(buffer), &(buffer_index), "+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                                    push_string(&(buffer), &(buffer_index), "mov [rsp+");
                                    push_integer(&(buffer), &(buffer_index), j);
                                    push_string_with_newline(&(buffer), &(buffer_index), "], al");

                                    j = integer+(j, 1);
                                    done_anything_assign = true;
                                };
                            };
                        };
                    };

                };
                
            };

            done_anything = true;
        };

        if =(id, NODE_RETURN) {
            variable arguments_size = get_size_multiple_linux_x86-64(stringarraymap_get(&(functions), &(function_arguments), current_function, index), 999, nodes, node_count);
            variable returns_size = get_size_multiple_linux_x86-64(stringarraymap_get(&(functions), &(function_returns), current_function, index), 999, nodes, node_count);
            variable returns_size_rounded = returns_size;
            if !(=(%(returns_size_rounded, 8), 0)) {
                returns_size_rounded = integer+(returns_size_rounded, @cast_integer(-(8, %(returns_size, 8))));
            };

            variable j = 8;
            variable k = integer+(returns_size, 8);

            push_string_with_newline(&(buffer), &(buffer_index), "mov rcx, [rbp+8]");
            push_string_with_newline(&(buffer), &(buffer_index), "mov rdx, [rbp]");

            returns_size = integer+(returns_size, 8);

            while <(j, returns_size) {
                variable done_anything_assign = false;

                if >(-(returns_size, j), 7) {
                    k = @cast_integer(-(k, 8));
                    push_string(&(buffer), &(buffer_index), "mov rax, [rsp+");
                    push_integer(&(buffer), &(buffer_index), @cast_integer(-(-(returns_size, j), 8)));
                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                    push_string(&(buffer), &(buffer_index), "mov [rbp+");
                    push_integer(&(buffer), &(buffer_index), @cast_integer(+(+(24, -(-(arguments_size, returns_size), j)), returns_size_rounded)));
                    push_string_with_newline(&(buffer), &(buffer_index), "], rax");

                    j = integer+(j, 8);
                    done_anything_assign = true;
                };
                if &&(>(-(returns_size, j), 3), !(done_anything_assign)) {
                    k = @cast_integer(-(k, 4));
                    push_string(&(buffer), &(buffer_index), "mov eax, [rsp+");
                    push_integer(&(buffer), &(buffer_index), @cast_integer(-(-(returns_size, j), 4)));
                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                    push_string(&(buffer), &(buffer_index), "mov [rbp+");
                    push_integer(&(buffer), &(buffer_index), @cast_integer(+(+(24, -(-(arguments_size, returns_size), j)), returns_size_rounded)));
                    push_string_with_newline(&(buffer), &(buffer_index), "], eax");

                    j = integer+(j, 4);
                    done_anything_assign = true;
                };
                if &&(>(-(returns_size, j), 1), !(done_anything_assign)) {
                    k = @cast_integer(-(k, 2));
                    push_string(&(buffer), &(buffer_index), "mov ax, [rsp+");
                    push_integer(&(buffer), &(buffer_index), @cast_integer(-(-(returns_size, j), 2)));
                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                    push_string(&(buffer), &(buffer_index), "mov [rbp+");
                    push_integer(&(buffer), &(buffer_index), @cast_integer(+(+(24, -(-(arguments_size, returns_size), j)), returns_size_rounded)));
                    push_string_with_newline(&(buffer), &(buffer_index), "], ax");

                    j = integer+(j, 2);
                    done_anything_assign = true;
                };
                if &&(>(-(returns_size, j), 0), !(done_anything_assign)) {
                    k = @cast_integer(-(k, 1));
                    push_string(&(buffer), &(buffer_index), "mov al, [rsp+");
                    push_integer(&(buffer), &(buffer_index), @cast_integer(-(-(returns_size, j), 1)));
                    push_string_with_newline(&(buffer), &(buffer_index), "]");

                    push_string(&(buffer), &(buffer_index), "mov [rbp+");
                    push_integer(&(buffer), &(buffer_index), @cast_integer(+(+(24, -(-(arguments_size, returns_size), j)), returns_size_rounded)));
                    push_string_with_newline(&(buffer), &(buffer_index), "], al");

                    j = integer+(j, 1);
                    done_anything_assign = true;
                };
            };

            returns_size = @cast_integer(-(returns_size, 8));

            push_string_with_newline(&(buffer), &(buffer_index), "mov rsp, rbp");
            push_string(&(buffer), &(buffer_index), "add rsp, ");
            push_integer(&(buffer), &(buffer_index), integer+(16, @cast_integer(-(arguments_size, returns_size))));
            push_string_with_newline(&(buffer), &(buffer_index), "");
            push_string_with_newline(&(buffer), &(buffer_index), "push rdx");
            push_string_with_newline(&(buffer), &(buffer_index), "pop rbp");
            push_string_with_newline(&(buffer), &(buffer_index), "push rcx");
            push_string_with_newline(&(buffer), &(buffer_index), "ret");
                
            done_anything = true;
        };

        if =(id, NODE_POINTER) {
            done_anything = true;
        };

        if =(id, NODE_JUMP_CONDITIONAL) {
            variable target = integer->(@cast_*integer(+(pointer, 8)));
            variable conditional = any_1->(@cast_*any_1(+(pointer, 16)));
            push_string_with_newline(&(buffer), &(buffer_index), "mov al, [rsp]");
            push_string_with_newline(&(buffer), &(buffer_index), "add rsp, 1");

            if @cast_boolean(conditional) {
                push_string_with_newline(&(buffer), &(buffer_index), "cmp al, 1");
                done_anything = true;
            };

            if !(done_anything) {
                push_string_with_newline(&(buffer), &(buffer_index), "cmp al, 0");
                done_anything = true;
            };

            push_string(&(buffer), &(buffer_index), "je target_");
            push_integer(&(buffer), &(buffer_index), target);
            push_string_with_newline(&(buffer), &(buffer_index), "");
        };

        if =(id, NODE_JUMP) {
            variable target = integer->(@cast_*integer(+(pointer, 8)));

            push_string(&(buffer), &(buffer_index), "jmp target_");
            push_integer(&(buffer), &(buffer_index), target);
            push_string_with_newline(&(buffer), &(buffer_index), "");

            done_anything = true;
        };

        if =(id, NODE_TARGET) {
            variable target = integer->(@cast_*integer(+(pointer, 8)));
            push_string(&(buffer), &(buffer_index), "target_");
            push_integer(&(buffer), &(buffer_index), target);
            push_string_with_newline(&(buffer), &(buffer_index), ":");

            done_anything = true;
        };

        if =(id, NODE_ENDFUNCTION) {
            done_anything = true;
        };

        if =(id, NODE_STRUCTURE) {
            done_anything = true;
        };

        if =(id, NODE_GLOBAL) {
            variable name2 = *->(@cast_**(+(pointer, 8)));
            variable type = *->(@cast_**(+(pointer, 16)));
            variable global_name = bump_allocate(allocator, integer+(length(name2), 1));
            copy("_", global_name, 1);
            copy(name2, @cast_*(+(global_name, 1)), length(name2));
            
            variable size = get_size_linux_x86-64(type, nodes, node_count);

            push_string(&(bss_buffer), &(bss_buffer_index), global_name);
            push_string(&(bss_buffer), &(bss_buffer_index), ": rb ");
            push_integer(&(bss_buffer), &(bss_buffer_index), size);
            push_string_with_newline(&(bss_buffer), &(bss_buffer_index), "");
            
            done_anything = true;
        };

        if =(id, NODE_CONSTANT) {
            variable name3 = *->(@cast_**(+(pointer, 8)));
            variable type2 = *->(@cast_**(+(pointer, 16)));
            //TODO: reassigning locals should warn
            variable value2 = any_8->(@cast_*any_8(+(pointer, 24)));

            variable global_name = bump_allocate(allocator, integer+(length(name3), 1));
            copy("_", global_name, 1);
            copy(name3, @cast_*(+(global_name, 1)), length(name3));
            
            variable size = get_size_linux_x86-64(type, nodes, node_count);

            push_string(&(data_buffer), &(data_buffer_index), global_name);
            push_string(&(data_buffer), &(data_buffer_index), ": dq ");
            push_integer(&(data_buffer), &(data_buffer_index), @cast_integer(value2));
            push_string_with_newline(&(data_buffer), &(data_buffer_index), "");
            
            done_anything = true;
        };

        if !(done_anything) {
            print("Unhandled ");
            @print_integer(id);
        };

        i = @cast_integer(+(i, 1));
    };

    push_string_with_newline(&(buffer), &(buffer_index), "segment readable");
    push_string(&(buffer), &(buffer_index), &(data_buffer));

    push_string_with_newline(&(buffer), &(buffer_index), "segment readable writable");
    push_string(&(buffer), &(buffer_index), &(bss_buffer));

    if >(buffer_index, 4096) {
        println("buffer overflows");
        exit(0);
    };

    variable asm_output: any_32;
    variable asm_output_length: integer = 0;
    push_string(&(asm_output), &(asm_output_length), "build/");
    push_string(&(asm_output), &(asm_output_length), name);
    push_string(&(asm_output), &(asm_output_length), ".asm");

    variable asm_output_descriptor = sys_open(&(asm_output), @cast_integer(+(+(O_WRONLY, O_CREAT), O_TRUNC)), 388);
    sys_write(asm_output_descriptor, &(buffer), length(&(buffer)));
    sys_close(asm_output_descriptor);

    variable id = sys_fork();
    if =(id, 0) {
        variable arguments_buffer: any_48;

        array8_set(&(arguments_buffer), 0, "/bin/fasm");
        array8_set(&(arguments_buffer), 1, &(asm_output));

        variable binary_output: any_48;
        variable binary_output_length = 0;
        push_string(&(binary_output), &(binary_output_length), "build/");
        push_string(&(binary_output), &(binary_output_length), name);

        array8_set(&(arguments_buffer), 2, &(binary_output));
        array8_set(&(arguments_buffer), 3, "-m");
        array8_set(&(arguments_buffer), 4, "131072");

        variable _ = sys_execve("/bin/fasm", &(arguments_buffer), @cast_**(0));
    };

    variable _ = @syscall5(247, 1, id, 0, 4, 0);
};

function string_length=(string1: *, string2: *, length: integer): boolean {
    variable i = 0;
    while <(i, length) {
        variable string1_character = *1(@cast_*(+(string1, i)));
        variable string2_character = *1(@cast_*(+(string2, i)));

        if !(=1(string1_character, string2_character)) {
            return false;
        };

        i = @cast_integer(+(i, 1));
    };

    return true;
};

function string=(string1: *, string2: *): boolean {
    variable string1_length = length(string1);
    variable string2_length = length(string2);

    if !(=(string1_length, string2_length)) {
        return false;
    };

    return string_length=(string1, string2, string1_length);
};

function length(string: *): integer {
    variable length = 0;

    while !(=1(byte(0), *1(+(string, length)))) {
        length = @cast_integer(+(length, 1));
    };

    return length;
};

function integer+(value1: integer, value2: integer): integer {
    return @cast_integer(+(value1, value2));
};

function integer-(value1: integer, value2: integer): integer {
    return @cast_integer(-(value1, value2));
};

function integer*(value1: integer, value2: integer): integer {
    return @cast_integer(*(value1, value2));
};

function copy(from: *, to: *, size: integer) {
    variable i = 0;

    while <(i, size) {
        any_1<-(@cast_*any_1(+(to, i)), any_1->(@cast_*any_1(+(from, i))));
        i = @cast_integer(+(i, 1));
    };
};

function print(string: *) {
    sys_write(STDOUT, string, length(string));
};

function println(string: *) {
    print(string);

    variable new_line: integer = 10;
    sys_write(STDOUT, &(new_line), 1);
};

function get_contents(name: *): * {
    variable descriptor = sys_open(name, O_RDONLY, 0);

    variable stat: Stat;
    sys_fstat(descriptor, &(stat));

    variable contents = brk_allocate(integer+(Stat->size(&(stat)), 1));

    sys_read(descriptor, contents, Stat->size(&(stat)));

    return contents;
};

function exit(code: integer) {
    sys_exit(code);
};

structure BumpAllocator {
    memory: any_131072;
    location: integer;
    count: integer;
};

function bump_allocate(bump_allocator: *BumpAllocator, size: integer): * {
    variable pointer = @cast_*(+(&(BumpAllocator->memory(bump_allocator)), BumpAllocator->location(bump_allocator)));
    BumpAllocator<-location(bump_allocator, @cast_integer(+(BumpAllocator->location(bump_allocator), size)));
    BumpAllocator<-count(bump_allocator, @cast_integer(+(BumpAllocator->count(bump_allocator), 1)));

    if >(BumpAllocator->location(bump_allocator), 131072) {
        println("bump_allocate overflows buffer");
    };

    return pointer;
};

function bump_free(bump_allocator: *BumpAllocator) {
    BumpAllocator<-count(bump_allocator, @cast_integer(-(BumpAllocator->count(bump_allocator), 1)));
    if =(BumpAllocator->count(bump_allocator), 0) {
        BumpAllocator<-location(bump_allocator, 0);
    };
};

function array8_set(array: *, index: integer, value: any_8) {
    variable index_pointer = @cast_*any_8(+(array, *(index, 8)));
    any_8<-(index_pointer, value);
};

function array8_get(array: *, index: integer): any_8 {
    variable index_pointer = @cast_*any_8(+(array, *(index, 8)));
    return any_8->(index_pointer);
};

function array8_length(array: *): integer {
    variable k = 0;
    while !(=(array8_get(array, k), 0)) {
        k = integer+(k, 1);
    };
    return k;
};

function stack8_push(stack: *, stack_pointer: *integer, value: any_8) {
    variable index_pointer = @cast_*any_8(+(stack, *(integer->(stack_pointer), 8)));
    any_8<-(index_pointer, value);
    increment_integer_pointer(stack_pointer, 1);
};

function stack8_pop(stack: *, stack_pointer: *integer): any_8 {
    decrement_integer_pointer(stack_pointer, 1);
    variable index_pointer = @cast_*any_8(+(stack, *(integer->(stack_pointer), 8)));
    return any_8->(index_pointer);
};

function brk_allocate(size: integer): * {
    variable current_break = sys_brk(@cast_*(0));
    variable _ = sys_brk(@cast_*(+(current_break, size)));
    return current_break;
};

structure AutoBuffer {
    buffer: *;
    size: integer;
    increment: integer;
};

function autobuffer_new(size: integer): AutoBuffer {
    variable auto_buffer: AutoBuffer;

    AutoBuffer<-size(&(auto_buffer), size);
    AutoBuffer<-increment(&(auto_buffer), size);

    variable allocated = brk_allocate(size);
    AutoBuffer<-buffer(&(auto_buffer), allocated);

    return auto_buffer;
};

function autobuffer_reset(buffer: *AutoBuffer) {
    variable i = 0;
    while <(i, AutoBuffer->size(buffer)) {
        any_1<-(@cast_*any_1(+(AutoBuffer->buffer(buffer), i)), byte(0));
        i = integer+(i, 1);
    };
};

function autobuffer_set_boolean(buffer: *AutoBuffer, value: boolean, to: integer) {
    autobuffer_set(buffer, &(value), to, 1);
};

function autobuffer_set_any_1(buffer: *AutoBuffer, value: any_1, to: integer) {
    autobuffer_set(buffer, &(value), to, 1);
};

function autobuffer_set_*(buffer: *AutoBuffer, value: *, to: integer) {
    autobuffer_set(buffer, &(value), to, 8);
};

function autobuffer_set_integer(buffer: *AutoBuffer, value: integer, to: integer) {
    autobuffer_set(buffer, &(value), to, 8);
};

function autobuffer_set(buffer: *AutoBuffer, from: *, to: integer, size: integer) {
    variable to_pointer = @cast_*(+(AutoBuffer->buffer(buffer), to));

    while >(+(to, size), AutoBuffer->size(buffer)) {
        variable previous_buffer = AutoBuffer->buffer(buffer);
        variable previous_size = AutoBuffer->size(buffer);
        variable new_buffer_size = @cast_integer(+(AutoBuffer->size(buffer), AutoBuffer->increment(buffer)));
        variable allocated = brk_allocate(new_buffer_size);
        AutoBuffer<-buffer(buffer, allocated);
        AutoBuffer<-size(buffer, new_buffer_size);
        copy(previous_buffer, allocated, previous_size);

        to_pointer = @cast_*(+(AutoBuffer->buffer(buffer), to));
    };

    copy(from, to_pointer, size);
};

function autobuffer_get(buffer: *AutoBuffer, location: integer): * {
    return @cast_*(+(AutoBuffer->buffer(buffer), location));
};

function autobuffer_get_integer(buffer: *AutoBuffer, location: integer): integer {
    return integer->(@cast_*integer(autobuffer_get(buffer, location)));
};

function autobuffer_get_*(buffer: *AutoBuffer, location: integer): * {
    return *->(@cast_**(autobuffer_get(buffer, location)));
};
