define is_type = function(wanted: *, given: *, nodes: *Nodes, program_data: *ProgramData): boolean {
    if string=(wanted, given) {
        return true;
    };

    if string=(wanted, "*") {
        if string_length=(given, "*", 1) {
            return true;
        };
    };

    if string_length=(wanted, "*", 1) {
        if string_length=(given, "*", 1) {
            return is_type(+(wanted, 1), +(given, 1), nodes, program_data);
        };
    };

    variable define_types = &(ProgramData.>define_types(program_data));

    variable defined = *.cast(hashmap_string_get(define_types, given));
    if !(=(defined, 0)) {
        if string=(defined, wanted) {
            return true;
        };
    };

    defined = *.cast(hashmap_string_get(define_types, wanted));
    if !(=(defined, 0)) {
        if string=(defined, given) {
            return true;
        };
    };

    if string_length=(wanted, "global[", 7) {
        return string_length=(+(wanted, 7), given, -(length(wanted), 8));
    };

    if string_length=(given, "global[", 7) {
        variable given_substring = substring_brk_allocate(given, 7, -(length(given), 1));
        return is_type(given_substring, wanted, nodes, program_data);
    };

    if |(&&(string=(wanted, "*structure[_:any_8]"), string=(given, "structure[_:any_8]")), &&(string=(given, "structure[_:any_8]"), string=(wanted, "*structure[_:any_8]"))) {
        return true;
    };

    if string_length=(wanted, "any_", 4) {
        variable size = to_number(*.cast(+(wanted, 4)));
        // TODO: don't use linux stuff directly
        return =(size, get_size_linux_x86-64(given, nodes, program_data));
    };

    return false;
};

define is_signed = function(type: *, nodes: *Nodes): whole_8 {
    variable cached_signedness = whole_8.cast(hashmap_string_get2(&(cached_signedness_map), type));
    if !(=(cached_signedness, 999)) {
        return cached_signedness;
    };

    if string_length=(type, "*", 1) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };

    if string_length=(type, "whole", 5) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "any", 3) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "integer", 7) {
        hashmap_string_put(&(cached_signedness_map), type, 1);
        return 1;
    };

    variable node_count = Nodes.>index(nodes);
    variable i = 0;
    while <(i, node_count) {
        if =(nodes_get_id(nodes, i), NODE_STRUCTURE) {
            variable pointer = NodeStructureData.*cast(nodes_get_pointer_data(nodes, i));
            variable name = NodeStructureData.>name(pointer);

            if !(=(name, 0)) {
                variable member_types = NodeStructureData.>item_types(pointer);
                if string=(type, name) {
                    variable is_signed2 = is_signed(*.cast(array8_get(member_types, 0)), nodes);
                    hashmap_string_put(&(cached_signedness_map), type, is_signed2);
                    return is_signed2;
                };
            };
        };
        i = +(i, 1);
    };

    hashmap_string_put(&(cached_signedness_map), type, 0);
    return 0;
};

define print_node_error_beginning = function(nodes: *Nodes, location: whole_8) {
    variable location_data = nodes_get_location_data(nodes, location);
    print("[ERROR] ");
    print(NodeLocationData.>file(location_data));
    print(":");
    print_whole_8(NodeLocationData.>row(location_data));
    print(":");
    print_whole_8(NodeLocationData.>column(location_data));
    print(": ");
};

define ProgramData = structure {
    define_types: HashMap;
    define_values: HashMap;
    structure_datas: AutoBufferStack8;
    structure_member_types: AutoBuffer;
    structure_member_names: AutoBuffer;
    function_locations: AutoBuffer;
    function_argument_types: AutoBuffer;
    function_argument_names: AutoBuffer;
    function_return_types: AutoBuffer;
    internal_function_argument_types: HashMap;
    internal_function_argument_names: HashMap;
    internal_function_return_types: HashMap;
    global_types: AutoBuffer;
};

define module_stack = global(AutoBufferStack8);

define process = function(nodes: *Nodes): ProgramData {
    variable node_count = Nodes.>index(nodes);

    module_stack = autobuffer_stack8_new(32);

    variable program_data = ProgramData.>0();

    ProgramData.<internal_function_argument_types(&(program_data), hashmap_new(1024));
    ProgramData.<internal_function_argument_names(&(program_data), hashmap_new(1024));
    ProgramData.<internal_function_return_types(&(program_data), hashmap_new(1024));

    ProgramData.<define_types(&(program_data), hashmap_new(512));
    ProgramData.<define_values(&(program_data), hashmap_new(512));

    ProgramData.<function_locations(&(program_data), autobuffer_new(1024));
    ProgramData.<function_argument_types(&(program_data), autobuffer_new(1024));
    ProgramData.<function_argument_names(&(program_data), autobuffer_new(1024));
    ProgramData.<function_return_types(&(program_data), autobuffer_new(1024));

    ProgramData.<structure_datas(&(program_data), autobuffer_stack8_new(1024));
    ProgramData.<structure_member_types(&(program_data), autobuffer_new(1024));
    ProgramData.<structure_member_names(&(program_data), autobuffer_new(1024));

    ProgramData.<global_types(&(program_data), autobuffer_new(512));

    setup_process(nodes, &(program_data));

    variable current_function_id = 0;

    variable variable_scopes_types_map = autobuffer_new(64);
    variable variable_scope_types_pointer = 0;
    variable variable_scopes_declares_map = autobuffer_new(64);
    variable variable_scope_declares_pointer = 0;

    variable stack = autobuffer_new(64);
    variable stack_pointer = 0;

    variable if_blocks = autobuffer_new(64);
    variable if_block_pointer = 0;
    variable if_block_results = autobuffer_new(64);

    variable function_id = 0;

    variable has_main = false;

    variable i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            variable function_name = NodeFunctionData.>name(NodeFunctionData.*cast(pointer_data));

            if =(function_name, 0) {
                current_function_id = function_id;
                function_id = +(function_id, 1);
            };

            stack_pointer = 0;
        } else if =(id, NODE_NUMBER) {
            process_number(&(stack), &(stack_pointer), pointer_data);
        } else if =(id, NODE_BOOLEAN) {
            autobuffer_stack8_legacy_push(&(stack), &(stack_pointer), "boolean");
        } else if =(id, NODE_STRING) {
            autobuffer_stack8_legacy_push(&(stack), &(stack_pointer), "*");
        } else if =(id, NODE_INVOKE) {
            process_invoke(nodes, i, &(stack), &(stack_pointer), &(program_data), pointer_data);
        } else if =(id, NODE_DECLARE) {
            variable declare_data = NodeDeclareData.*cast(pointer_data);
            variable variable_name = NodeDeclareData.>name(declare_data);
            variable variable_type = NodeDeclareData.>type(declare_data);

            hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), -(variable_scope_types_pointer, 1))), variable_name, variable_type);
            hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_declares_map), -(variable_scope_declares_pointer, 1))), variable_name, i);
        } else if =(id, NODE_ASSIGN) {
            process_assign(nodes, i, &(stack), &(stack_pointer), &(program_data), variable_scopes_types_map, variable_scope_types_pointer, variable_scopes_declares_map, pointer_data);
        } else if =(id, NODE_RETRIEVE) {
            process_retrieve(nodes, i, &(stack), &(stack_pointer), variable_scopes_types_map, variable_scope_types_pointer, &(program_data), current_function_id);
        } else if =(id, NODE_RETURN) {
            process_return(nodes, i, &(stack), &(stack_pointer), &(program_data), current_function_id);
        } else if =(id, NODE_POINTER) {
            process_pointer(nodes, i, &(stack), &(stack_pointer));
        } else if =(id, NODE_JUMP_CONDITIONAL) {
            process_jump_conditional(nodes, i, &(stack), &(stack_pointer));
        } else if =(id, NODE_SCOPE) {
            variable new_hashmap = hashmap_new(512);
            variable allocated = brk_allocate(24);
            HashMap.<(HashMap.*cast(allocated), new_hashmap);
            autobuffer_stack8_legacy_push(&(variable_scopes_types_map), &(variable_scope_types_pointer), allocated);

            variable new_hashmap = hashmap_new(512);
            variable allocated = brk_allocate(24);
            HashMap.<(HashMap.*cast(allocated), new_hashmap);
            autobuffer_stack8_legacy_push(&(variable_scopes_declares_map), &(variable_scope_declares_pointer), allocated);
        } else if =(id, NODE_ENDSCOPE) {
            variable _ = autobuffer_stack8_legacy_pop(&(variable_scopes_types_map), &(variable_scope_types_pointer));
            variable _ = autobuffer_stack8_legacy_pop(&(variable_scopes_declares_map), &(variable_scope_declares_pointer));
        } else if =(id, NODE_STARTIFBLOCK) {
            autobuffer_stack8_legacy_push(&(if_blocks), &(if_block_pointer), stack_pointer);
        } else if =(id, NODE_ENDIFBLOCK) {
            process_end_if(nodes, i, &(stack), &(stack_pointer), &(if_blocks), &(if_block_results), &(if_block_pointer), pointer_data);
        } else if =(id, NODE_DEFINE) {
            variable define_node_data = NodeDefineData.*cast(pointer_data);
            if string=(NodeDefineData.>name(define_node_data), "main") {
                has_main = true;
            };
        } else if =(id, NODE_ENDDEFINE) {
        } else if =(id, NODE_JUMP) {
        } else if =(id, NODE_TARGET) {
        } else if =(id, NODE_ENDFUNCTION) {
        } else if =(id, NODE_STRUCTURE) {
        } else if =(id, NODE_GLOBAL) {
        } else if =(id, NODE_MODULE) {
        } else if =(id, NODE_ENDMODULE) {
        } else if =(id, NODE_SKIP) {
        } else if =(id, NODE_ENDSTATEMENT) {
            if !(=(stack_pointer, 0)) {
                print_node_error_beginning(nodes, i);
                println("Statement end has extra stack values");
                while !(=(stack_pointer, 0)) {
                    println(*.cast(autobuffer_stack8_legacy_pop(&(stack), &(stack_pointer))));
                };
                exit(1);

            };
        } else {
            print("Unhandled ");
            print_whole_8(id);
            println("");
        };

        i = +(i, 1);
    };
    
    if !(has_main) {
        println("[ERROR] No 'main' function defined");
        exit(1);
    };

    return program_data;
};

//define process_structure = function(program_data: *ProgramData, structure_data: *NodeStructureData) {
//    variable structure_name = NodeStructureData.>name(structure_data);
//
//    if =(structure_name, 0) {
//        structure_name = get_structure_string_type(structure_data);
//        NodeStructureData.<name(structure_data, structure_name);
//
//        variable structure_member_types = &(ProgramData.>structure_member_types(program_data));
//        variable structure_member_names = &(ProgramData.>structure_member_names(program_data));
//
//        autobuffer_array8_set(structure_member_types, define_structure_index, NodeStructureData.>item_types(structure_data));
//        autobuffer_array8_set(structure_member_names, define_structure_index, NodeStructureData.>item_names(structure_data));
//    };
//};

define process_number = function(stack: *AutoBuffer, stack_pointer: *whole_8, pointer_data: *) {
    variable number_data = NodeNumberData.*cast(pointer_data);

    variable number_type = autobuffer_buffer_new(16);

    if =(NodeNumberData.>type(number_data), 0) {
        autobuffer_buffer_push_string(&(number_type), "whole_");
    } else {
        autobuffer_buffer_push_string(&(number_type), "integer_");
    };

    autobuffer_buffer_string_push_whole_8(&(number_type), NodeNumberData.>size(number_data));

    autobuffer_stack8_legacy_push(stack, stack_pointer, AutoBuffer.>buffer(&(AutoBufferBuffer.>autobuffer(&(number_type)))));
};

define process_jump_conditional = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8) {
    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        println("Conditional jump ran out of stack values");
        exit(1);
    };

    variable popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    if !(string=(popped, "boolean")) {
        print_node_error_beginning(nodes, nodes_index);
        print("Conditional Jump (if/while) wants 'boolean', given '");
        print(popped);
        println("'");
        exit(1);
    };
};

define process_pointer = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8) {
    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        println("Pointer ran out of stack values");
        exit(1);
    };

    variable popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    autobuffer_stack8_legacy_push(stack, stack_pointer, concatenate2_brk_allocate("*", popped));
};

define process_return = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, current_function_id: whole_8) {
    variable function_return_types = &(ProgramData.>function_return_types(program_data));
    variable function_return_types_specific = *.cast(autobuffer_array8_get(function_return_types, current_function_id));

    variable temp = array8_length(function_return_types_specific);
    variable j = -(temp, 1);
    while <(j, temp) {
        variable function_return = *.cast(array8_get(function_return_types_specific, j));

        if =(whole_8.>(stack_pointer), 0) {
            print_node_error_beginning(nodes, nodes_index);
            println("Return ran out of stack values");
            exit(1);
        };

        variable stack_popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
        
        if !(is_type(function_return, stack_popped, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Return wants '");
            print(function_return);
            print("', given '");
            print(stack_popped);
            println("'");
            exit(1);
        };

        j = -(j, 1);
    };

    if !(=(whole_8.>(stack_pointer), 0)) {
        print_node_error_beginning(nodes, nodes_index);
        println("Return has extra stack values");
        exit(1);
    };
};

define process_end_if = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, if_blocks: *AutoBuffer, if_block_results: *AutoBuffer, if_block_pointer: *whole_8, pointer_data: *) {
    variable end_if_data = NodeEndIfBlockData.*cast(pointer_data);
    variable end_if_id = NodeEndIfBlockData.>id(end_if_data);
    variable is_last = NodeEndIfBlockData.>is_last(end_if_data);

    variable start_stack = whole_8.cast(autobuffer_stack8_legacy_pop(if_blocks, if_block_pointer));
    variable previous_results = *.cast(autobuffer_array8_get(if_block_results, end_if_id));

    variable size = *(8, -(whole_8.>(stack_pointer), start_stack));
    if =(previous_results, 0) {
        previous_results = brk_allocate(+(8, size));
        variable array = autobuffer_get_size(stack, *(8, start_stack), size);
        copy(array, previous_results, size);

        autobuffer_array8_set(if_block_results, end_if_id, previous_results);

        if !(is_last) {
            variable j = 0;
            while <(j, /(size, 8)) {
                variable _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);

                j = +(j, 1);
            };
        };
    } else {
        variable array = autobuffer_get_size(stack, *(8, start_stack), size);
        variable previous_array = previous_results;

        variable max_size = size;
        if >(*(array8_length(previous_array), 8), size) {
            size = *(array8_length(previous_array), 8);
        };

        variable j = 0;
        while <(j, /(size, 8)) {
            variable previous_value = *.cast(array8_get(previous_array, j));
            variable value = *.cast(array8_get(array, j));

            variable error = false;

            if =(value, 0) {
                error = true;
            } else if =(previous_value, 0) {
                error = true;
            } else if !(string=(value, previous_value)) {
                error = true;
            } else {
                if !(is_last) {
                    variable _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);
                };
            };

            if error {
                print_node_error_beginning(nodes, nodes_index);
                println("If does not have matching branch results");
                exit(1);
            };

            j = +(j, 1);
        };
    };
};

define process_assign = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, variable_scopes_declares_map: AutoBuffer, pointer_data: *) {
    variable assign_data = NodeAssignData.*cast(pointer_data);
    variable variable_name = NodeAssignData.>name(assign_data);

    variable scope_index, variable_type = get_variable_info(variable_scopes_types_map, variable_scope_types_pointer, variable_name);

    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        println("Assign ran out of stack values");
        exit(1);
    };

    variable popped_stack = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if !(=(variable_type, 0)) {
        if string=(variable_type, "") {
            variable_type = popped_stack;

            hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name, popped_stack);

            variable variable_declare_node_index = hashmap_string_get(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_declares_map), scope_index)), variable_name);
            variable variable_declare_node = NodeDeclareData.*cast(nodes_get_pointer_data(nodes, whole_8.cast(variable_declare_node_index)));
            NodeDeclareData.<type(variable_declare_node, variable_type);
        };

        if !(is_type(variable_type, popped_stack, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Assign of ");
            print(variable_name);
            print(" wants '");
            print(variable_type);
            print("', given '");
            print(popped_stack);
            println("'");
            exit(1);
        };
        return;
    };

    variable define_values = &(ProgramData.>define_values(program_data));

    variable global_id = whole_8.cast(hashmap_string_get2(define_values, variable_name));
    if !(=(global_id, 999)) {
        variable global_types = &(ProgramData.>global_types(program_data));
        variable_type = *.cast(autobuffer_array8_get(global_types, global_id));
    };

    if !(=(variable_type, 0)) {
        if !(is_type(variable_type, popped_stack, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Assign of ");
            print(variable_name);
            print(" wants '");
            print(variable_type);
            print("', given '");
            print(popped_stack);
            println("'");
            exit(1);
        };
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Assign target '");
        print(variable_name);
        println("' not found");
        exit(1);
    };
};

define get_variable_info = function(variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, variable_name: *): whole_8, * {
    variable scope_index = -(variable_scope_types_pointer, 1);
    variable variable_type = *.cast(0);
    while &&(=(variable_type, 0), <(scope_index, variable_scope_types_pointer)) {
        variable_type = *.cast(hashmap_string_get(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name));
        scope_index = -(scope_index, 1);
    };
    scope_index = +(scope_index, 1);

    return scope_index, variable_type;
};

define process_invoke_pointer = function(nodes: *Nodes, nodes_index: whole_8,  stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, pointer_data: *) {
    variable function_type = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if string_length=(function_type, "*function[", 10) {
        variable arguments_buffer, returns_buffer = get_arguments_from_function_type(function_type);

        variable k = integer_8.cast(array8_length(arguments_buffer));
        while >(k, 0_integer_8) {
            k = -(k, 1_integer_8);

            if =(whole_8.>(stack_pointer), 0) {
                print_node_error_beginning(nodes, nodes_index);
                print("Invoke of '");
                if =(nodes_get_id(nodes, -(nodes_index, 1)), NODE_RETRIEVE) {
                    variable previous_node_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(nodes_index, 1)));
                    print(NodeRetrieveData.>name(previous_node_data));
                } else {
                    print("unknown");
                };
                println("' ran out of stack values");
                exit(1);
            };

            variable given = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
            variable wanted = *.cast(array8_get(arguments_buffer, whole_8.cast(k)));

            if !(is_type(wanted, given, nodes, program_data)) {
                print_node_error_beginning(nodes, nodes_index);
                print("Invoke of '");

                if =(nodes_get_id(nodes, -(nodes_index, 1)), NODE_RETRIEVE) {
                    variable previous_node_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(nodes_index, 1)));
                    print(NodeRetrieveData.>name(previous_node_data));
                } else {
                    print("unknown");
                };

                print("' wants '");
                print(wanted);
                print("', given '");
                print(given);
                println("'");
                exit(1);
            };
        };

        variable k = 0;
        while <(k, array8_length(returns_buffer)) {
            autobuffer_stack8_legacy_push(stack, stack_pointer, array8_get(returns_buffer, k));
            k = +(k, 1);
        };
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Attempting to invoke non function pointer '");
        print(function_type);
        println("'");
        exit(1);
    };
};

define get_arguments_from_function_type = function(function_type: *): *, * {
    variable arguments_buffer = autobuffer_new(64);
    variable arguments_buffer_index = 0;

    variable current_buffer = autobuffer_buffer_new(64);

    variable inner = 0;
    variable j = 10;
    while |(!(=(whole_1.>(whole_1.*cast(+(function_type, j))), ASCII_COLON)), >(inner, 0)) {
        variable character = whole_1.>(whole_1.*cast(+(function_type, j)));
        if &&(|(=(character, ASCII_CLOSED_BRACKET), =(character, ASCII_COMMA)), =(inner, 0)) {
            autobuffer_array8_set(&(arguments_buffer), arguments_buffer_index, autobuffer_buffer_get_buffer_pointer(&(current_buffer)));
            arguments_buffer_index = +(arguments_buffer_index, 1);

            current_buffer = autobuffer_buffer_new(64);
        } else {
            autobuffer_buffer_push_whole_1(&(current_buffer), character);
        };

        if =(character, ASCII_OPEN_BRACKET) {
            inner = +(inner, 1);
        } else if =(character, ASCII_CLOSED_BRACKET) {
            inner = -(inner, 1);
        };
        j = +(j, 1);
    };
    if >(AutoBufferBuffer.>index(&(current_buffer)), 0) {
        autobuffer_array8_set(&(arguments_buffer), arguments_buffer_index, autobuffer_buffer_get_buffer_pointer(&(current_buffer)));
    };

    variable returns_buffer = autobuffer_new(64);
    variable returns_buffer_index = 0;

    variable inner = 0;
    current_buffer = autobuffer_buffer_new(64);

    j = +(j, 1);

    while |(!(=(whole_1.>(whole_1.*cast(+(function_type, j))), ASCII_CLOSED_BRACKET)), >(inner, 0)) {
        variable character = whole_1.>(whole_1.*cast(+(function_type, j)));
        if &&(|(=(character, ASCII_COLON), =(character, ASCII_COMMA)), =(inner, 0)) {
            variable return_ = autobuffer_buffer_get_buffer_pointer(&(current_buffer));

            autobuffer_array8_set(&(returns_buffer), returns_buffer_index, return_);
            returns_buffer_index = +(returns_buffer_index, 1);

            current_buffer = autobuffer_buffer_new(64);
        } else {
            autobuffer_buffer_push_whole_1(&(current_buffer), character);
        };

        if =(character, ASCII_OPEN_BRACKET) {
            inner = +(inner, 1);
        } else if =(character, ASCII_CLOSED_BRACKET) {
            inner = -(inner, 1);
        };
        j = +(j, 1);
    };

    if >(AutoBufferBuffer.>index(&(current_buffer)), 0) {
        autobuffer_array8_set(&(returns_buffer), returns_buffer_index, autobuffer_buffer_get_buffer_pointer(&(current_buffer)));
    };

    return AutoBuffer.>buffer(&(arguments_buffer)), AutoBuffer.>buffer(&(returns_buffer));
};

define process_retrieve = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, program_data: *ProgramData, current_function_id: whole_8) {
    variable retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, nodes_index));
    variable variable_name = NodeRetrieveData.>name(retrieve_data);

    if &&(string_length=(variable_name, "any_", 4), &&(=(nodes_get_id(nodes, +(nodes_index, 1)), NODE_INVOKE), NodeInvokeData.>has_specifier(NodeInvokeData.*cast(nodes_get_pointer_data(nodes, +(nodes_index, 1)))))) {
        autobuffer_stack8_legacy_push(stack, stack_pointer, variable_name);
        return;
    };

    variable scope_index, variable_type = get_variable_info(variable_scopes_types_map, variable_scope_types_pointer, variable_name);

    if !(=(variable_type, 0)) {
        autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
        return;
    };

    variable function_argument_types = &(ProgramData.>function_argument_types(program_data));
    variable function_argument_names = &(ProgramData.>function_argument_names(program_data));

    variable function_argument_names_specific = *.cast(autobuffer_array8_get(function_argument_names, current_function_id));
    variable function_argument_types_specific = *.cast(autobuffer_array8_get(function_argument_types, current_function_id));

    variable_type = stringarray_get(function_argument_names_specific, function_argument_types_specific, variable_name, array8_length(function_argument_types_specific));
    if !(=(variable_type, 0)) {
        autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
        return;
    };

    variable define_values = &(ProgramData.>define_values(program_data));

    if NodeRetrieveData.>using_module(retrieve_data) {
        variable prepended_to_name = "";
        variable modules_index = +(nodes_index, 1);
        while =(nodes_get_id(nodes, modules_index), NODE_RETRIEVE) {
            variable retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, modules_index));
            variable is_module = NodeRetrieveData.>is_module(retrieve_data);

            if !(is_module) {
                break;
            };

            variable retrieve_name = NodeRetrieveData.>name(retrieve_data);
            variable module_id = whole_8.cast(hashmap_string_get2(define_values, retrieve_name));
            variable module_id_buffer = any_24.>0();

            whole_8_to_string(module_id, &(module_id_buffer));

            prepended_to_name = concatenate2_brk_allocate(prepended_to_name, &(module_id_buffer));

            nodes_set_skip(nodes, modules_index);
            modules_index = +(modules_index, 1);
        };

        variable_name = concatenate2_brk_allocate(prepended_to_name, variable_name);
        NodeRetrieveData.<name(retrieve_data, variable_name);
    };

    variable define_types = &(ProgramData.>define_types(program_data));

    variable_type = *.cast(hashmap_string_get(define_types, variable_name));

    if !(=(variable_type, 0)) {
        autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
        return;
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Retrieve target '");
        print(variable_name);
        println("' not found");
        exit(1);
    };
};

define process_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, pointer_data: *) {
    variable invoke_data = NodeInvokeData.*cast(pointer_data);
    variable is_pointer = NodeInvokeData.>is_pointer(invoke_data);

    if is_pointer {
        process_invoke_pointer(nodes, nodes_index, stack, stack_pointer, program_data, pointer_data);
        return;
    };

    variable has_specifier = NodeInvokeData.>has_specifier(invoke_data);
    variable function_name = NodeInvokeData.>name(invoke_data);

    if &&(!(has_specifier), string=(function_name, "+")) {
        process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "+");
    } else if &&(!(has_specifier), string=(function_name, "-")) {
        process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "-");
    } else if &&(!(has_specifier), string=(function_name, "*")) {
        process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "*");
    } else if &&(!(has_specifier), string=(function_name, "/")) {
        process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "/");
    } else if &&(!(has_specifier), string=(function_name, "%")) {
        process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "%");
    } else if &&(!(has_specifier), string=(function_name, "=")) {
        process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "=");
    } else if &&(!(has_specifier), string=(function_name, ">")) {
        process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, ">");
    } else if &&(!(has_specifier), string=(function_name, "<")) {
        process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "<");
    } else if &&(has_specifier, |(string=(function_name, "cast"), string=(function_name, "*cast"))) {
        process_cast(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data);
    } else {
        process_internal_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data);
    };
};

define process_cast = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, invoke_data: *NodeInvokeData) {
    variable function_name = NodeInvokeData.>name(invoke_data);

    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        println("Cast ran out of stack values");
        exit(1);
    };

    variable to_push = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if string=(function_name, "*cast") {
        to_push = concatenate2_brk_allocate("*", to_push);
    };

    variable popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if !(=(get_size_linux_x86-64(popped, nodes, program_data), get_size_linux_x86-64(to_push, nodes, program_data))) {
        print_node_error_beginning(nodes, nodes_index);
        print("Cast wants equal sized types, given '");
        print(popped);
        print("' and casts to '");
        print(to_push);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, to_push);

    nodes_set_skip(nodes, -(nodes_index, 1));
};

define process_internal_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, invoke_data: *NodeInvokeData) {
    variable function_name = NodeInvokeData.>name(invoke_data);
    variable has_specifier = NodeInvokeData.>has_specifier(invoke_data);
    variable found_function = false;

    if has_specifier {
        variable popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

        function_name = concatenate2_brk_allocate(popped, function_name);
        NodeInvokeData.<name(invoke_data, function_name);
        NodeInvokeData.<has_specifier(invoke_data, false);

        nodes_set_skip(nodes, -(nodes_index, 1));
    };

    variable internal_function_argument_types = &(ProgramData.>internal_function_argument_types(program_data));
    variable internal_function_return_types = &(ProgramData.>internal_function_return_types(program_data));

    if =(hashmap_string_get(internal_function_argument_types, function_name), 0) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke target '");
        print(function_name);
        println("' not found");
        exit(1);
    };

    variable arguments = *.cast(hashmap_string_get(internal_function_argument_types, function_name));
    variable returns = *.cast(hashmap_string_get(internal_function_return_types, function_name));

    variable length = array8_length(arguments);
    variable k = 0;
    while <(k, length) {
        if =(whole_8.>(stack_pointer), 0) {
            print_node_error_beginning(nodes, nodes_index);
            print("Invoke of '");
            print(function_name);
            println("' ran out of stack values");
            exit(1);
        };

        variable given = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
        variable wanted = *.cast(array8_get(arguments, -(-(length, k), 1)));
        if !(is_type(wanted, given, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Invoke of '");
            print(function_name);
            print("' wants '");
            print(wanted);
            print("', given '");
            print(given);
            println("'");
            exit(1);
        };

        k = +(k, 1);
    };

    variable k = 0;
    while !(=(array8_get(returns, k), 0)) {
        variable return_value = *.cast(array8_get(returns, k));
        autobuffer_stack8_legacy_push(stack, stack_pointer, return_value);

        k = +(k, 1);
    };
};

define process_math_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, invoke_data: *NodeInvokeData, math_name: *) {
    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(math_name);
        println("' ran out of stack values");
        exit(1);
    };

    variable first = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    variable second = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    // removed signdness check -- probably need to add it back
    if !(=(get_size_linux_x86-64(first, nodes, program_data), get_size_linux_x86-64(second, nodes, program_data))) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(math_name);
        print("' wants matching arguments, given '");
        print(first);
        print("' and '");
        print(second);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, second);

    variable new_+_name = autobuffer_new(16);
    autobuffer_set(&(new_+_name), concatenate2_brk_allocate(math_name, "_"), 0, 2);
    autobuffer_set(&(new_+_name), first, 2, length(first));

    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
};

define process_comparison_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, invoke_data: *NodeInvokeData, comparison_name: *) {
    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(comparison_name);
        println("' ran out of stack values");
        exit(1);
    };

    variable first = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    variable second = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if !(=(get_size_linux_x86-64(first, nodes, program_data), get_size_linux_x86-64(second, nodes, program_data))) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(comparison_name);
        print("' has incompatable arguments, given '");
        print(first);
        print("' and '");
        print(second);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, "boolean");

    variable new_+_name = autobuffer_new(16);
    autobuffer_set(&(new_+_name), concatenate2_brk_allocate(comparison_name, "_"), 0, 2);
    autobuffer_set(&(new_+_name), first, 2, length(first));

    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
};

define setup_process = function(nodes: *Nodes, program_data: *ProgramData) {
    variable node_count = Nodes.>index(nodes);

    variable declared_function_id = 0;
    variable declared_structure_id = 0;
    variable declared_global_id = 0;
    variable declared_module_id = 0;

    variable i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            variable function_data = NodeFunctionData.*cast(pointer_data);
            variable function_name = NodeFunctionData.>name(function_data);
            
            if !(=(function_name, 0)) {
                variable internal_function_argument_types = &(ProgramData.>internal_function_argument_types(program_data));
                variable internal_function_argument_names = &(ProgramData.>internal_function_argument_names(program_data));
                variable internal_function_return_types = &(ProgramData.>internal_function_return_types(program_data));

                hashmap_string_put(internal_function_argument_types, function_name, NodeFunctionData.>argument_types(function_data));
                hashmap_string_put(internal_function_argument_names, function_name, NodeFunctionData.>argument_names(function_data));
                hashmap_string_put(internal_function_return_types, function_name, NodeFunctionData.>returns(function_data));
            } else {
                // probably should check for duplicate functions
                variable function_locations = &(ProgramData.>function_locations(program_data));
                variable function_argument_names = &(ProgramData.>function_argument_names(program_data));
                variable function_argument_types = &(ProgramData.>function_argument_types(program_data));
                variable function_return_types = &(ProgramData.>function_return_types(program_data));

                autobuffer_array8_set(function_locations, declared_function_id, i);
                autobuffer_array8_set(function_argument_types, declared_function_id, NodeFunctionData.>argument_types(function_data));
                autobuffer_array8_set(function_argument_names, declared_function_id, NodeFunctionData.>argument_names(function_data));
                autobuffer_array8_set(function_return_types, declared_function_id, NodeFunctionData.>returns(function_data));
                declared_function_id = +(declared_function_id, 1);
            };
        };

        if =(id, NODE_STRUCTURE) {
            variable structure_data = NodeStructureData.*cast(pointer_data);

            if =(NodeStructureData.>name(structure_data), 0) {
                variable structure_member_types = &(ProgramData.>structure_member_types(program_data));
                variable structure_members_names = &(ProgramData.>structure_member_names(program_data));
                autobuffer_array8_set(structure_member_types, declared_structure_id, NodeStructureData.>item_types(structure_data));
                autobuffer_array8_set(structure_members_names, declared_structure_id, NodeStructureData.>item_names(structure_data));

                variable structure_name = get_structure_string_type(structure_data);
                NodeStructureData.<name(structure_data, structure_name);

                declared_structure_id = +(declared_structure_id, 1);
            };

            variable structure_datas = &(ProgramData.>structure_datas(program_data));
            autobuffer_stack8_push(structure_datas, structure_data);
        };

        if =(id, NODE_GLOBAL) {
            variable global_data = NodeGlobalData.*cast(pointer_data);
            variable global_name = NodeGlobalData.>name(global_data);
            variable global_type = NodeGlobalData.>type(global_data);

            variable global_types = &(ProgramData.>global_types(program_data));
            autobuffer_array8_set(global_types, declared_global_id, global_type);
            declared_global_id = +(declared_global_id, 1);
        };

        if =(id, NODE_MODULE) {
            declared_module_id = +(declared_module_id, 1);
        };

        if =(id, NODE_DEFINE) {
            variable define_data = NodeDefineData.*cast(pointer_data);
            variable define_name = NodeDefineData.>name(define_data);
            variable define_type = NodeDefineData.>type(define_data);

            variable define_value: any_8;
            if string_length=(define_type, "*function", 9) {
                define_value = declared_function_id;

                variable new_define_name = "";

                variable i = 0;
                while <(i, AutoBufferStack8.>index(&(module_stack))) {
                    variable module_id = whole_8.cast(autobuffer_stack8_get(&(module_stack), i));
                    variable module_id_buffer = any_24.>0();
                    whole_8_to_string(module_id, &(module_id_buffer));

                    new_define_name = concatenate2_brk_allocate(&(module_id_buffer), new_define_name);
                    i = +(i, 1);
                };

                define_name = concatenate2_brk_allocate(new_define_name, define_name);
                
                NodeDefineData.<name(define_data, define_name);
            } else if string_length=(define_type, "structure", 9) {
                define_value = declared_structure_id;
            } else if string_length=(define_type, "global", 6) {
                define_value = declared_global_id;
            } else if string_length=(define_type, "module", 6) {
                define_value = declared_module_id;
                autobuffer_stack8_push(&(module_stack), declared_module_id);
            } else {
                define_value = NodeNumberData.>value(NodeNumberData.*cast(nodes_get_pointer_data(nodes, +(i, 1))));
            };

            variable define_types = &(ProgramData.>define_types(program_data));
            hashmap_string_put(define_types, define_name, define_type);

            variable define_values = &(ProgramData.>define_values(program_data));
            hashmap_string_put(define_values, define_name, define_value);
        };

        if =(id, NODE_ENDDEFINE) {
            variable define_data = NodeEndDefineData.*cast(pointer_data);
            variable define_type = NodeEndDefineData.>type(define_data);

            if =(define_type, 0) {
            } else if string=(define_type, "module") {
                variable _ = autobuffer_stack8_pop(&(module_stack));
            };
        };

        i = +(i, 1);
    };

};
