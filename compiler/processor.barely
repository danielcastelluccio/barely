// TODO: Currently using a define to define a type as another will result in two equal types, I would prefer them to be unique, but is that really a good idea?
define is_type = function(wanted: *, given: *, nodes: *Nodes.Nodes, program_data: *ProgramData): boolean {
    if string=(wanted, given) {
        return true;
    };

    if string=(wanted, "") {
        return true;
    };

    if string_length=(wanted, "*", 1) {
        if string_length=(given, "*", 1) {
            return is_type(wanted + 1, given + 1, nodes, program_data);
        };
    };

    if string_length=(wanted, "any_", 4) {
        declare size = string_to_whole_8(wanted + 4);
        declare size_function = program_data.get_size;
        return size == size_function(given, nodes, program_data);
    };

    return false;
};

define is_signed = function(type: *, nodes: *Nodes.Nodes): whole_8 {
    declare cached_signedness = whole_8.cast(hashmap_string_get2(&cached_signedness_map, type));
    if !(cached_signedness == 999) {
        return cached_signedness;
    };

    if string_length=(type, "*", 1) {
        hashmap_string_put(&cached_signedness_map, type, 0);
        return 0;
    };

    if string_length=(type, "whole_", 6) {
        hashmap_string_put(&cached_signedness_map, type, 0);
        return 0;
    };
    if string_length=(type, "any_", 4) {
        hashmap_string_put(&cached_signedness_map, type, 0);
        return 0;
    };
    if string_length=(type, "integer_", 8) {
        hashmap_string_put(&cached_signedness_map, type, 1);
        return 1;
    };

    // Assuming all structures are unsigned?

    //declare node_count = nodes.index;
    //declare i = 0;
    //while i < node_count {
    //    if =(Nodes.get_id(nodes, i), Node.STRUCTURE) {
    //        declare pointer = Node.StructureData.pcast(Nodes.get_pointer_data(nodes, i));
    //        declare name = Node.StructureData.>name(pointer);

    //        if !(=(name, 0)) {
    //            declare member_types = Node.StructureData.>item_types(pointer);
    //            if string=(type, name) {
    //                declare is_signed2 = is_signed(*.cast(array8_get(member_types, 0)), nodes);
    //                hashmap_string_put(&cached_signedness_map, type, is_signed2);
    //                return is_signed2;
    //            };
    //        };
    //    };
    //    i = i + 1;
    //};

    hashmap_string_put(&cached_signedness_map, type, 0);
    return 0;
};

define print_node_error_beginning = function(nodes: *Nodes.Nodes, location: whole_8) {
    declare location_data = Nodes.get_location_data(nodes, location);
    print("[ERROR] ");
    print(location_data.file);
    print(":");
    print_whole_8(location_data.row);
    print(":");
    print_whole_8(location_data.column);
    print(": ");
};

define ProgramData = structure {
    define_types: HashMap;
    define_values: HashMap;
    define_or_declares: HashMap;
    structure_datas: AutoBufferStack8;
    structure_member_types: AutoBuffer;
    structure_member_names: AutoBuffer;
    function_datas: AutoBuffer;
    function_locations: AutoBuffer;
    function_argument_types: AutoBuffer;
    function_argument_names: AutoBuffer;
    function_return_types: AutoBuffer;
    function_return_types2: AutoBuffer;
    internal_function_argument_types: HashMap;
    internal_function_argument_names: HashMap;
    internal_function_return_types: HashMap;
    global_types: AutoBuffer;

    // possible should be in a separate structure
    get_size: *function[*,*Nodes.Nodes,*ProgramData:whole_8];
};

define process = function(nodes: *Nodes.Nodes, size_function: *function[*,*Nodes.Nodes,*ProgramData:whole_8]): ProgramData {
    declare node_count = nodes.index;

    declare module_stack = autobuffer_stack8_new(32);

    declare program_data = ProgramData.>0();

    program_data.internal_function_argument_types = hashmap_new(1024);
    program_data.internal_function_argument_names = hashmap_new(1024);
    program_data.internal_function_return_types = hashmap_new(1024);

    program_data.define_types = hashmap_new(512);
    program_data.define_values = hashmap_new(512);
    program_data.define_or_declares = hashmap_new(512);

    program_data.function_locations = autobuffer_new(1024);
    program_data.function_datas = autobuffer_new(1024);
    program_data.function_argument_types = autobuffer_new(1024);
    program_data.function_argument_names = autobuffer_new(1024);
    program_data.function_return_types = autobuffer_new(1024);
    program_data.function_return_types2 = autobuffer_new(1024);

    program_data.structure_datas = autobuffer_stack8_new(1024);
    program_data.structure_member_types = autobuffer_new(1024);
    program_data.structure_member_names = autobuffer_new(1024);

    program_data.global_types = autobuffer_new(512);

    program_data.get_size = size_function;

    setup_process(nodes, &program_data);

    declare current_function_id = 0;

    declare variable_scopes_types_map = autobuffer_new(64);
    declare variable_scope_types_pointer = 0;
    declare variable_scopes_declares_map = autobuffer_new(64);
    declare variable_scope_declares_pointer = 0;

    declare stack = autobuffer_new(64);
    declare stack_pointer = 0;

    declare if_blocks = autobuffer_new(64);
    declare if_block_pointer = 0;
    declare if_block_results = autobuffer_new(64);

    declare function_id = 0;

    declare has_main = false;
    declare declared_function_id = 0;
    declare declared_module_id = 0;

    declare declared_function_id = 0;
    declare declared_module_id = 0;

    declare in_function = false;

    declare i = 0;
    while i < node_count {
        declare id = Nodes.get_id(nodes, i);
        declare pointer_data = Nodes.get_pointer_data(nodes, i);

        if id == Node.FUNCTION {
            declare function_name = Node.FunctionData.pcast(pointer_data).name;

            if function_name == NULL {
                current_function_id = function_id;
                function_id = function_id + 1;
            };
            in_function = true;

            stack_pointer = 0;
        } else if id == Node.NUMBER {
            process_number(&module_stack, &stack, &stack_pointer, pointer_data);
        } else if id == Node.BOOLEAN {
            autobuffer_stack8_legacy_push(&stack, &stack_pointer, "boolean");
        } else if id == Node.STRING {
            autobuffer_stack8_legacy_push(&stack, &stack_pointer, "*");
        } else if id == Node.INVOKE {
            process_invoke(nodes, i, &module_stack, &stack, &stack_pointer, &program_data, pointer_data);
        } else if id == Node.INVOKE_INTERNAL {
            process_invoke_internal(nodes, i, &module_stack, &stack, &stack_pointer, &program_data, pointer_data);
        } else if id == Node.DECLARE {
            declare declare_data = Node.DeclareData.pcast(pointer_data);
            declare variable_name = declare_data.name;
            declare variable_type_names = declare_data.type;

            if in_function {
                hashmap_string_put(HashMap.pcast(autobuffer_array8_get(&variable_scopes_types_map, variable_scope_types_pointer - 1)), variable_name, variable_type_names);
                hashmap_string_put(HashMap.pcast(autobuffer_array8_get(&variable_scopes_declares_map, variable_scope_declares_pointer - 1)), variable_name, i);
            };
        } else if id == Node.ASSIGN {
            process_assign(nodes, &i, &module_stack, &stack, &stack_pointer, &program_data, variable_scopes_types_map, variable_scope_types_pointer, variable_scopes_declares_map, pointer_data);
        } else if id == Node.RETRIEVE {
            if in_function {
                process_retrieve(nodes, &i, &module_stack, &stack, &stack_pointer, variable_scopes_types_map, variable_scope_types_pointer, &program_data, current_function_id);
            };
        } else if id == Node.RETURN {
            process_return(nodes, i, &stack, &stack_pointer, &program_data, &module_stack, current_function_id);
        } else if id == Node.JUMP_CONDITIONAL {
            process_jump_conditional(nodes, i, &program_data, &stack, &stack_pointer);
        } else if id == Node.SCOPE {
            declare new_hashmap = hashmap_new(512);
            declare allocated = HashMap.pcast(brk_allocate(24));
            allocated.* = new_hashmap;
            autobuffer_stack8_legacy_push(&variable_scopes_types_map, &variable_scope_types_pointer, allocated);

            declare new_hashmap = hashmap_new(512);
            declare allocated = HashMap.pcast(brk_allocate(24));
            allocated.* = new_hashmap;
            autobuffer_stack8_legacy_push(&variable_scopes_declares_map, &variable_scope_declares_pointer, allocated);
        } else if id == Node.ENDSCOPE {
            declare _ = autobuffer_stack8_legacy_pop(&variable_scopes_types_map, &variable_scope_types_pointer);
            declare _ = autobuffer_stack8_legacy_pop(&variable_scopes_declares_map, &variable_scope_declares_pointer);
        } else if id == Node.STARTIFBLOCK {
            autobuffer_stack8_legacy_push(&if_blocks, &if_block_pointer, stack_pointer);
        } else if id == Node.ENDIFBLOCK {
            process_end_if(nodes, i, &stack, &stack_pointer, &if_blocks, &if_block_results, &if_block_pointer, pointer_data, &program_data);
        } else if id == Node.DEFINE {
            declare define_node_data = Node.DefineData.pcast(pointer_data);
            if string=(define_node_data.name, "main") {
                has_main = true;
            };
        } else if id == Node.ENDDEFINE {
        } else if id == Node.MODULE {
            autobuffer_stack8_push(&module_stack, declared_module_id);
            declared_module_id = declared_module_id + 1;
        } else if id == Node.ENDMODULE {
            declare _ = autobuffer_stack8_pop(&module_stack);
        } else if id == Node.JUMP {
        } else if id == Node.TARGET {
        } else if id == Node.ENDFUNCTION {
            in_function = false;
        } else if id == Node.STRUCTURE {
        } else if id == Node.SKIP {
        } else if id == Node.ENDSTATEMENT {
            if !(stack_pointer == 0) {
                print_node_error_beginning(nodes, i);
                println("Statement end has extra stack values");
                exit(1);

            };
        } else {
            print("Unhandled ");
            print_whole_8(id);
            println("");
        };

        i = i + 1;
    };
    
    if !(has_main) {
        println("[ERROR] No 'main' function defined");
        exit(1);
    };

    return program_data;
};

define is_define = function(type: *): boolean {
    if string_length=(type, "any_", 4) {
        return false;
    };
    if string_length=(type, "whole_", 6) {
        return false;
    };
    if string_length=(type, "integer_", 8) {
        return false;
    };
    if string_length=(type, "boolean", 6) {
        return false;
    };
    if string_length=(type, "*function[", 10) {
        return false;
    };
    if string=(type, "*") {
        return false;
    };
    return true;
};

define process_number = function(module_stack: *AutoBufferStack8, stack: *AutoBuffer, stack_pointer: *whole_8, pointer_data: *) {
    declare number_data = Node.NumberData.pcast(pointer_data);

    declare coersion = number_data.coersion;
    if coersion == NULL {
        coersion = "whole_8";
    } else {
        coersion = expand_module_name_array(coersion, 0, &module_id_map, &module_references_map, module_stack, create_previous_results_list());
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, coersion);
};

define process_jump_conditional = function(nodes: *Nodes.Nodes, nodes_index: whole_8, program_data: *ProgramData, stack: *AutoBuffer, stack_pointer: *whole_8) {
    if stack_pointer.* == 0 {
        print_node_error_beginning(nodes, nodes_index);
        println("Conditional jump ran out of stack values");
        exit(1);
    };

    declare popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    if !is_type(popped, "boolean", nodes, program_data) {
        print_node_error_beginning(nodes, nodes_index);
        print("Conditional Jump (if/while) wants 'boolean', given '");
        print(popped);
        println("'");
        exit(1);
    };
};

define process_return = function(nodes: *Nodes.Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, module_stack: *AutoBufferStack8, current_function_id: whole_8) {
    declare function_return_types = &program_data.function_return_types;
    declare function_return_types_specific = *.cast(autobuffer_array8_get(function_return_types, current_function_id));

    declare function_return_types2 = &program_data.function_return_types2;
    declare function_return_types2_specific = *.cast(autobuffer_array8_get(function_return_types2, current_function_id));

    declare temp = array8_length(function_return_types2_specific);
    declare j = temp - 1;
    while j < temp {
        declare function_return = *.cast(array8_get(function_return_types2_specific, j));
        function_return = expand_module_name_array(function_return, 0, &module_id_map, &module_references_map, module_stack, create_previous_results_list());

        if stack_pointer == 0 {
            print_node_error_beginning(nodes, nodes_index);
            println("Return ran out of stack values");
            exit(1);
        };

        declare stack_popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
        
        if !is_type(function_return, stack_popped, nodes, program_data) {
            print_node_error_beginning(nodes, nodes_index);
            print("Return wants '");
            print(function_return);
            print("', given '");
            print(stack_popped);
            println("'");
            exit(1);
        };

        j = j - 1;
    };

    if stack_pointer.* > 0 {
        print_node_error_beginning(nodes, nodes_index);
        println("Return has extra stack values");
        exit(1);
    };
};

define process_end_if = function(nodes: *Nodes.Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, if_blocks: *AutoBuffer, if_block_results: *AutoBuffer, if_block_pointer: *whole_8, pointer_data: *, program_data: *ProgramData) {
    declare end_if_data = Node.EndIfBlockData.pcast(pointer_data);
    declare end_if_id = end_if_data.id;
    declare is_last = end_if_data.is_last;
    declare is_bare_else = end_if_data.is_bare_else;

    declare start_stack = whole_8.cast(autobuffer_stack8_legacy_pop(if_blocks, if_block_pointer));
    declare previous_results = *.cast(autobuffer_array8_get(if_block_results, end_if_id));

    declare size = 8 * (stack_pointer.* - start_stack);
    if previous_results == NULL {
        previous_results = brk_allocate(8 + size);
        declare array = autobuffer_get_size(stack, 8 * start_stack, size);
        copy(array, previous_results, size);

        autobuffer_array8_set(if_block_results, end_if_id, previous_results);

        if !is_last {
            declare j = 0;
            while j < size / 8 {
                declare _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);

                j = j + 1;
            };
        } else if (!is_bare_else) && (size > 0) {
            print_node_error_beginning(nodes, nodes_index);
            println("If expression resulting in a value requires an 'else' condition");
            exit(1);
        };
    } else {
        declare array = autobuffer_get_size(stack, 8 * start_stack, size);
        declare previous_array = previous_results;

        declare max_size = size;
        if (array8_length(previous_array) * 8) > size {
            size = array8_length(previous_array) * 8;
        };

        declare j = 0;
        while j < size / 8 {
            declare previous_value = *.cast(array8_get(previous_array, j));
            declare value = *.cast(array8_get(array, j));

            declare error = false;

            if value == NULL {
                error = true;
            } else if previous_value == NULL {
                error = true;
            } else if !is_type(value, previous_value, nodes, program_data) {
                if is_type(previous_value, value, nodes, program_data) {
                    array8_set(previous_array, j, previous_value);
                    array8_set(array, j, previous_value);
                } else {
                    error = true;
                };
            } else if !is_last {
                declare _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);
            };

            if error {
                print_node_error_beginning(nodes, nodes_index);
                print("If does not have matching branch results (");
                print(value);
                print(", ");
                print(previous_value);
                println(")");
                exit(1);
            };

            j = j + 1;
        };
    };
};

define process_assign = function(nodes: *Nodes.Nodes, nodes_index_in: *whole_8, module_stack: *AutoBufferStack8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, variable_scopes_declares_map: AutoBuffer, pointer_data: *) {
    declare nodes_index = nodes_index_in.*;
    declare assign_data = Node.AssignData.pcast(pointer_data);
    declare variable_name = assign_data.name;
    declare uses_previous = assign_data.uses_previous;

    if stack_pointer.* == 0 {
        print_node_error_beginning(nodes, nodes_index);
        println("Assign ran out of stack values");
        exit(1);
    };

    declare variable_type = *.>0();

    if uses_previous {
        declare peeked = *.cast(autobuffer_stack8_legacy_peek(stack, stack_pointer));

        declare top_define = *.>0();
        if string_length=(peeked, "module:", 7) {
            top_define = peeked + 7;
        };

        declare variable_name_new = expand_module_name_stack(variable_name, &module_id_map, &module_references_map, module_stack, top_define, create_previous_results_list());

        if !(string=(variable_name, variable_name_new)) {
            variable_name = variable_name_new;
            declare _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);
        } else {
            declare index = 0;
            declare variable_type_temp = *.cast(autobuffer_stack8_legacy_peek(stack, stack_pointer));
            if string_length=(variable_type_temp, "*", 1) {
                variable_type_temp = variable_type_temp + 1;
            } else {
                Nodes.set_id(nodes, nodes_index + index, Node.INVOKE_INTERNAL);
                declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, nodes_index + index);
                invoke_data.name = "&";
                invoke_data.uses_previous = false;
                index = index + 1;

                variable_type = concatenate2_brk_allocate("*", variable_type_temp);
                declare _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);
                autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
            };

            declare name = variable_type_temp;
            Nodes.set_id(nodes, nodes_index + index, Node.RETRIEVE);
            declare retrieve_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, nodes_index + index);
            retrieve_data.name = name;
            retrieve_data.coercion = *.>0();
            retrieve_data.uses_previous = false;
            index = index + 1;

            declare name = if string=(variable_name, "*") {
                "<2"
            } else {
                concatenate2_brk_allocate("<2", variable_name)
            };
            Nodes.set_id(nodes, nodes_index + index, Node.INVOKE_INTERNAL);
            declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, nodes_index + index);
            invoke_data.name = name;
            invoke_data.uses_previous = true;

            nodes_index_in.* = nodes_index_in.* - 1;
            return;
        };
    };

    declare scope_index, variable_type = get_variable_info(variable_scopes_types_map, variable_scope_types_pointer, variable_name);

    declare popped_stack = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if !(variable_type == NULL) {
        if string=(variable_type, "") {
            variable_type = create_size_one_array8_brk_allocate(popped_stack);

            hashmap_string_put(HashMap.pcast(autobuffer_array8_get(&variable_scopes_types_map, scope_index)), variable_name, variable_type);

            declare variable_declare_node_index = hashmap_string_get(HashMap.pcast(autobuffer_array8_get(&variable_scopes_declares_map, scope_index)), variable_name);
            declare variable_declare_node = Node.DeclareData.pcast(Nodes.get_pointer_data(nodes, whole_8.cast(variable_declare_node_index)));
            variable_declare_node.type = variable_type;
        };

        variable_type = expand_module_name_array(variable_type, 0, &module_id_map, &module_references_map, module_stack, create_previous_results_list());
        if !is_type(variable_type, popped_stack, nodes, program_data) {
            print_node_error_beginning(nodes, nodes_index);
            print("Assign of ");
            print(variable_name);
            print(" wants '");
            print(variable_type);
            print("', given '");
            print(popped_stack);
            println("'");
            exit(1);
        };
        return;
    };

    declare define_types = &program_data.define_types;
    declare define_values = &program_data.define_values;
    declare define_or_declares = &program_data.define_or_declares;

    variable_type = get_define_retrieve_type(define_types, define_values, variable_name);

    declare module_expanded_name = variable_name;
    if (stack_pointer.* > 0) && (variable_type == NULL) {
        declare peeked = *.cast(autobuffer_stack8_legacy_peek(stack, stack_pointer));
        if string_length=(peeked, "module:", 7) {
            declare top_define = peeked + 7;
            module_expanded_name = expand_module_name_stack(variable_name, &module_id_map, &module_references_map, module_stack, top_define, create_previous_results_list());
        };
    };

    declare global_id = whole_8.cast(hashmap_string_get2(define_values, module_expanded_name));
    if !(global_id == 999) {
        declare global_types = &program_data.global_types;
        variable_type = *.cast(autobuffer_array8_get(global_types, global_id));
    };

    declare define_or_declare = *.cast(hashmap_string_get(define_or_declares, module_expanded_name));
    if !(define_or_declare == NULL) {
        if string=(define_or_declare, "declare") {
            variable_type = *.cast(hashmap_string_get(define_types, module_expanded_name));
        };
    };

    if !(variable_type == NULL) {
        if !is_type(variable_type, popped_stack, nodes, program_data) {
            print_node_error_beginning(nodes, nodes_index);
            print("Assign of ");
            print(variable_name);
            print(" wants '");
            print(variable_type);
            print("', given '");
            print(popped_stack);
            println("'");
            exit(1);
        };
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Assign target '");
        print(variable_name);
        println("' not found");
        exit(1);
    };
};

define get_variable_info = function(variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, variable_name: *): whole_8, * {
    declare scope_index = variable_scope_types_pointer - 1;
    declare variable_type = *.cast(0);
    while (variable_type == NULL) && (scope_index < variable_scope_types_pointer) {
        declare scope_map = HashMap.pcast(autobuffer_array8_get(&variable_scopes_types_map, scope_index));
        variable_type = *.cast(hashmap_string_get(scope_map, variable_name));
        scope_index = scope_index - 1;
    };
    scope_index = scope_index + 1;

    return scope_index, variable_type;
};

define get_define_type = function(define_types: *HashMap, define_values: *HashMap, define_name: *): * {
    return *.cast(hashmap_string_get(define_types, define_name));
};

define get_define_retrieve_type_without_structure = function(define_types: *HashMap, define_values: *HashMap, define_name: *): * {
    declare define_type = get_define_type(define_types, define_values, define_name);
    if define_type == NULL {

    } else if string_length=(define_type, "global[", 7) {
        define_type = substring_brk_allocate(define_type, 7, length(define_type) - 1);
    } else if string_length=(define_type, "structure[", 10) {
        define_type = define_name;
    };

    return define_type;
};

define get_define_retrieve_type = function(define_types: *HashMap, define_values: *HashMap, define_name: *): * {
    declare define_type = get_define_type(define_types, define_values, define_name);
    if define_type == NULL {

    } else if string_length=(define_type, "global[", 7) {
        define_type = substring_brk_allocate(define_type, 7, length(define_type) - 1);
    };

    return define_type;
};

define get_value_of_define = function(define_types: *HashMap, define_values: *HashMap, define_name: *): any_8 {
    return *.cast(hashmap_string_get2(define_values, define_name));
};

define process_retrieve = function(nodes: *Nodes.Nodes, nodes_index_in: *whole_8, module_stack: *AutoBufferStack8, stack: *AutoBuffer, stack_pointer: *whole_8, variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, program_data: *ProgramData, current_function_id: whole_8) {
    declare nodes_index = nodes_index_in.*;
    declare retrieve_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, nodes_index);
    declare variable_name = retrieve_data.name;
    declare uses_previous = retrieve_data.uses_previous;
    declare coercion = retrieve_data.coercion;

    declare variable_type = *.>0();

    if uses_previous {
        declare peeked = *.cast(autobuffer_stack8_legacy_peek(stack, stack_pointer));

        declare top_define = *.>0();
        if string_length=(peeked, "module:", 7) {
            top_define = peeked + 7;
        };

        declare variable_name_new = expand_module_name_stack(variable_name, &module_id_map, &module_references_map, module_stack, top_define, create_previous_results_list());

        if !(string=(variable_name, variable_name_new)) {
            variable_name = variable_name_new;
            declare _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);
        } else {
            declare index = 0;
            declare variable_type_temp = *.cast(autobuffer_stack8_legacy_peek(stack, stack_pointer));
            if string_length=(variable_type_temp, "*", 1) {
                variable_type_temp = variable_type_temp + 1;
            } else {
                Nodes.set_id(nodes, nodes_index + index, Node.INVOKE_INTERNAL);
                declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, nodes_index + index);
                invoke_data.name = "&";
                invoke_data.uses_previous = false;
                index = index + 1;

                variable_type = concatenate2_brk_allocate("*", variable_type_temp);
                declare _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);
                autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
            };

            declare name = variable_type_temp;
            Nodes.set_id(nodes, nodes_index + index, Node.RETRIEVE);
            declare retrieve_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, nodes_index + index);
            retrieve_data.name = name;
            retrieve_data.coercion = *.>0();
            retrieve_data.uses_previous = false;
            index = index + 1;

            declare name = if string=(variable_name, "*") {
                ">"
            } else {
                concatenate2_brk_allocate(">", variable_name)
            };
            Nodes.set_id(nodes, nodes_index + index, Node.INVOKE_INTERNAL);
            declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, nodes_index + index);
            invoke_data.name = name;
            invoke_data.uses_previous = true;

            nodes_index_in.* = nodes_index_in.* - 1;
            return;
        };
    };

    declare scope_index, variable_type = get_variable_info(variable_scopes_types_map, variable_scope_types_pointer, variable_name);

    if !(variable_type == NULL) {
        variable_type = expand_module_name_array(variable_type, 0, &module_id_map, &module_references_map, module_stack, create_previous_results_list());
        if is_pointer(nodes, nodes_index + 1) {
            variable_type = concatenate2_brk_allocate("*", variable_type);
        };

        autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
        return;
    };

    declare function_argument_types = &program_data.function_argument_types;
    declare function_argument_names = &program_data.function_argument_names;

    declare function_argument_names_specific = *.cast(autobuffer_array8_get(function_argument_names, current_function_id));
    declare function_argument_types_specific = *.cast(autobuffer_array8_get(function_argument_types, current_function_id));

    variable_type = stringarray_get(function_argument_names_specific, function_argument_types_specific, variable_name, array8_length(function_argument_types_specific));
    if !(variable_type == NULL) {
        variable_type = expand_module_name_array(variable_type, 0, &module_id_map, &module_references_map, module_stack, create_previous_results_list());
        if is_pointer(nodes, nodes_index + 1) {
            variable_type = concatenate2_brk_allocate("*", variable_type);
        };
        autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
        return;
    };

    declare define_types = &program_data.define_types;
    declare define_values = &program_data.define_values;

    if string_length=(variable_name, "any_", 4) {
        autobuffer_stack8_legacy_push(stack, stack_pointer, concatenate2_brk_allocate("structure:", variable_name));
        return;
    };

    if string=(variable_name, "@current_module") {
        autobuffer_stack8_legacy_push(stack, stack_pointer, concatenate2_brk_allocate("module:", variable_name));
        return;
    };

    variable_type = get_define_retrieve_type(define_types, define_values, variable_name);

    if !(coercion == NULL) {
        variable_type = coercion;
    };

    if !(variable_type == NULL) {
        if string=(variable_type, "define") {
            declare value = *.cast(get_value_of_define(define_types, define_values, variable_name));
            declare reference = *.cast(hashmap_string_get(&module_references_map, variable_name));
            declare expanded = expand_module_name(reference, &module_id_map, &module_references_map, module_stack, create_previous_results_list());
            variable_name = expanded;
            variable_type = get_define_retrieve_type(define_types, define_values, variable_name);
        };
    };

    if is_pointer(nodes, nodes_index + 1) {
        variable_type = concatenate2_brk_allocate("*", variable_type);
    };

    if !(variable_type == NULL) {
        if string=(variable_type, "module") {
            autobuffer_stack8_legacy_push(stack, stack_pointer, concatenate2_brk_allocate("module:", variable_name));
            return;
        } else if string_length=(variable_type, "structure[", 10) {
            autobuffer_stack8_legacy_push(stack, stack_pointer, concatenate2_brk_allocate("structure:", variable_name));
            return;
        };
    };

    if !(variable_type == NULL) {
        autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Retrieve target '");
        print(variable_name);
        println("' not found");
        exit(1);
    };
};

define process_invoke = function(nodes: *Nodes.Nodes, nodes_index: whole_8, module_stack: *AutoBufferStack8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, pointer_data: *) {
    declare function_type = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if !string_length=(function_type, "*function[", 10) {
        declare define_types = &program_data.define_types;
        declare define_values = &program_data.define_values;
        function_type = get_define_retrieve_type(define_types, define_values, function_type);
    };

    if string_length=(function_type, "*function[", 10) {
        declare type = string_to_function_data(function_type);
        declare arguments_buffer = type.argument_types;
        declare returns_buffer = type.return_types;

        declare k = integer_8.cast(array8_length(arguments_buffer));
        while k > 0:integer_8 {
            k = k - 1:integer_8;

            if stack_pointer.* == 0 {
                print_node_error_beginning(nodes, nodes_index);
                print("Invoke of '");
                if Nodes.get_id(nodes, nodes_index - 1) == Node.RETRIEVE {
                    declare previous_node_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, nodes_index - 1);
                    print(previous_node_data.name);
                } else {
                    print("unknown");
                };
                println("' ran out of stack values");
                exit(1);
            };

            declare given = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
            declare wanted = *.cast(array8_get(arguments_buffer, whole_8.cast(k)));
            wanted = expand_type_array(wanted, module_stack);

            if !is_type(wanted, given, nodes, program_data) {
                print_node_error_beginning(nodes, nodes_index);
                print("Invoke of '");

                if =(Nodes.get_id(nodes, nodes_index - 1), Node.RETRIEVE) {
                    declare previous_node_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, nodes_index - 1);
                    print(previous_node_data.name);
                } else {
                    print("unknown");
                };

                print("' wants '");
                print(wanted);
                print("', given '");
                print(given);
                println("'");
                exit(1);
            };
        };

        declare k = 0;
        declare length = array8_length(returns_buffer);
        while k < length {
            declare return_ = *.cast(array8_get(returns_buffer, k));
            return_ = expand_type_array(return_, module_stack);

            autobuffer_stack8_legacy_push(stack, stack_pointer, return_);
            k = k + 1;
        };
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Attempting to invoke non function pointer '");
        print(function_type);
        println("'");
        exit(1);
    };
};

define process_invoke_internal = function(nodes: *Nodes.Nodes, nodes_index: whole_8, module_stack: *AutoBufferStack8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, pointer_data: *) {
    declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, nodes_index);
    declare function_name = invoke_data.name;
    declare is_single = !invoke_data.uses_previous;

    if is_single && string=(function_name, "+") {
        function_name = process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "+");
    } else if is_single && string=(function_name, "-") {
        function_name = process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "-");
    } else if is_single && string=(function_name, "*") {
        function_name = process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "*");
    } else if is_single && string=(function_name, "/") {
        function_name = process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "/");
    } else if is_single && string=(function_name, "%") {
        function_name = process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "%");
    } else if is_single && string=(function_name, "=") {
        function_name = process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "=");
    } else if is_single && string=(function_name, ">") {
        function_name = process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, ">");
    } else if is_single && string=(function_name, "<") {
        function_name = process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "<");
    } else if string=(function_name, "cast") || string=(function_name, "pcast") {
        process_cast(nodes, nodes_index, module_stack, stack, stack_pointer, program_data, invoke_data, function_name);
    } else if is_single && string=(function_name, "&") {
    } else {
        function_name = if !is_single {
            concatenate2_brk_allocate(*.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer)) + 10, function_name)
        } else {
            function_name
        };
        process_internal_invoke(nodes, nodes_index, stack, stack_pointer, program_data, module_stack, function_name);
    };

    invoke_data.name = function_name;
};

define expand_module_name_stack = function(name_in: *, module_id_map: *HashMap, module_references_map: *HashMap, module_stack: *AutoBufferStack8, top_define: *, previous_results_list: *AutoBufferStack8): * {
    declare name = name_in;
    declare pointer_count = 0;
    while (any_1.pcast(name + pointer_count).* == ASCII.ASTERISK) && (pointer_count < length(name)) {
         pointer_count = pointer_count + 1;
    };

    name  = name + pointer_count;

    if length(name) > 0 {
        declare current_module_id = if !(top_define == NULL) {
            if string=(top_define, "@current_module") {
                whole_8.cast(autobuffer_stack8_peek(module_stack))
            } else {
                whole_8.cast(hashmap_string_get2(module_id_map, top_define))
            }
        } else {
            999
        };

        if !(current_module_id == 999) {
            declare current_module_id_string = any_16.>0();
            whole_8_to_string(current_module_id, &current_module_id_string);
            name = concatenate2_brk_allocate(&current_module_id_string, name);
        };

        declare possible_reference = *.cast(hashmap_string_get2(module_references_map, name));
        if !(possible_reference == 999) {
            declare i = 0;
            while i < previous_results_list.index {
                if string=(*.cast(autobuffer_stack8_get(previous_results_list, i)), name) {
                    return name;
                };
                i = i + 1;
            };
            autobuffer_stack8_push(previous_results_list, name);

            name = expand_module_name(possible_reference, module_id_map, module_references_map, module_stack, previous_results_list);
        };
    };

    declare i = 0;
    while i < pointer_count {
        name = concatenate2_brk_allocate("*", name);
        i = i + 1;
    };

    return name;
};

define expand_module_name_array = function(name_array: *, resolvable_end: whole_8, module_id_map: *HashMap, module_references_map: *HashMap, module_stack: *AutoBufferStack8, previous_results_list: *AutoBufferStack8): * {
    if array8_length(name_array) == 1 {
        return *.cast(array8_get(name_array, 0));
    };

    declare name = *.cast(array8_get(name_array, 0));
    declare pointer_count = 0;
    while (any_1.pcast(name + pointer_count).* == ASCII.ASTERISK) && (pointer_count < length(name)) {
         pointer_count = pointer_count + 1;
    };

    // TODO: lol
    name = *.cast(array8_get(name_array, array8_length(name_array) - 1));

    declare current_module_id = 999;
    declare i = 0;
    declare is_first = true;
    while i < ((array8_length(name_array) - resolvable_end) - 1) {
        declare current_module = *.cast(array8_get(name_array, i));
        if is_first {
            current_module = current_module + pointer_count;
        };
        is_first = false;

        declare new_id = if string=(current_module, "@current_module") {
            whole_8.cast(autobuffer_stack8_peek(module_stack))
        } else if =(current_module_id, 999) {
            declare temp_id = whole_8.cast(hashmap_string_get2(module_id_map, current_module));

            if temp_id == 999 {
                declare temp_name = *.cast(hashmap_string_get2(module_references_map, current_module));
                temp_name = expand_module_name(temp_name, module_id_map, module_references_map, module_stack, create_previous_results_list());
                temp_id = whole_8.cast(hashmap_string_get2(module_id_map, temp_name));
            };
            temp_id
        } else {
            declare current_module_id_string = any_16.>0();
            whole_8_to_string(current_module_id, &current_module_id_string);

            declare current_module_full = concatenate2_brk_allocate(&current_module_id_string, current_module);
            declare temp_id = whole_8.cast(hashmap_string_get2(module_id_map, current_module_full));

            if temp_id == 999 {
                declare temp_name = *.cast(hashmap_string_get2(module_references_map, current_module_full));
                if temp_name == 999 {
                    return name;
                };

                temp_name = expand_module_name(temp_name, module_id_map, module_references_map, module_stack, create_previous_results_list());
                temp_id = whole_8.cast(hashmap_string_get2(module_id_map, temp_name));
            };
            temp_id
        };

        current_module_id = new_id;
        i = i + 1;
    };

    if !(current_module_id == 999) {
        declare current_module_id_string = any_16.>0();
        whole_8_to_string(current_module_id, &current_module_id_string);
        name = concatenate2_brk_allocate(&current_module_id_string, *.cast(array8_get(name_array, (array8_length(name_array) - resolvable_end) - 1)));
    } else {
        name = *.cast(array8_get(name_array, (array8_length(name_array) - resolvable_end) - 1));
    };

    declare possible_reference = *.cast(hashmap_string_get2(module_references_map, name));
    if !(possible_reference == 999) {
        declare i = 0;
        while i < previous_results_list.index {
            if string=(*.cast(autobuffer_stack8_get(previous_results_list, i)), name) {
                return name;
            };
            i = i + 1;
        };
        autobuffer_stack8_push(previous_results_list, name);

        name = expand_module_name(possible_reference, module_id_map, module_references_map, module_stack, previous_results_list);
    };

    if !is_first {
        declare i = 0;
        while i < pointer_count {
            name = concatenate2_brk_allocate("*", name);
            i = i + 1;
        };
    };

    return name;
};

define print_array8_string = function(array: *) {
    print("[");
    declare i = 0;
    while i < array8_length(array) {
        print(*.cast(array8_get(array, i)));
        print(", ");
        i = i + 1;
    };
    println("]");
};

define process_cast = function(nodes: *Nodes.Nodes, nodes_index: whole_8, module_stack: *AutoBufferStack8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, invoke_data: *Node.InvokeInternalData, function_name: *) {
    if stack_pointer.* == 0 {
        print_node_error_beginning(nodes, nodes_index);
        println("Cast ran out of stack values");
        exit(1);
    };

    declare to_push = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer)) + 10;

    if string=(function_name, "pcast") {
        to_push = concatenate2_brk_allocate("*", to_push);
    };

    declare popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    declare size_function = program_data.get_size;
    if !(size_function(popped, nodes, program_data) == size_function(to_push, nodes, program_data)) {
        print_node_error_beginning(nodes, nodes_index);
        print("Cast wants equal sized types, given '");
        print(popped);
        print("' and casts to '");
        print(to_push);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, to_push);

    Nodes.set_skip(nodes, nodes_index - 1);
};

define process_internal_invoke = function(nodes: *Nodes.Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, module_stack: *AutoBufferStack8, function_name: *) {
    declare found_function = false;

    declare internal_function_argument_types = &program_data.internal_function_argument_types;
    declare internal_function_return_types = &program_data.internal_function_return_types;

    if hashmap_string_get(internal_function_argument_types, function_name) == NULL {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke target '");
        print(function_name);
        println("' not found");
        exit(1);
    };

    declare arguments = *.cast(hashmap_string_get(internal_function_argument_types, function_name));
    declare returns = *.cast(hashmap_string_get(internal_function_return_types, function_name));

    declare arguments_length = array8_length(arguments);
    declare k = 0;
    while k < arguments_length {
        if stack_pointer.* == 0 {
            print_node_error_beginning(nodes, nodes_index);
            print("Invoke of '");
            print(function_name);
            println("' ran out of stack values");
            exit(1);
        };

        declare given = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
        declare wanted = *.cast(array8_get(arguments, (arguments_length - k) - 1));
        wanted = expand_type_array(wanted, module_stack);
        if !is_type(wanted, given, nodes, program_data) {
            print_node_error_beginning(nodes, nodes_index);
            print("Invoke of '");
            print(function_name);
            print("' wants '");
            print(wanted);
            print("', given '");
            print(given);
            println("'");
            exit(1);
        };

        k = k + 1;
    };

    declare k = 0;
    while !(array8_get(returns, k) == NULL) {
        declare return_value = *.cast(array8_get(returns, k));
        return_value = expand_type_array(return_value, module_stack);
        if is_pointer(nodes, nodes_index + 1) {
            return_value = concatenate2_brk_allocate("*", return_value);
        };

        autobuffer_stack8_legacy_push(stack, stack_pointer, return_value);

        k = k + 1;
    };
};

define process_math_invoke = function(nodes: *Nodes.Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, math_name: *): * {
    if stack_pointer.* < 2 {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(math_name);
        println("' ran out of stack values");
        exit(1);
    };

    declare first = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    declare second = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    declare size_function = program_data.get_size;
    if (!size_function(first, nodes, program_data) == size_function(second, nodes, program_data)) || (!is_signed(first, nodes) == is_signed(second, nodes)) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(math_name);
        print("' wants matching arguments, given '");
        print(first);
        print("' and '");
        print(second);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, second);

    declare define_types = &program_data.define_types;
    declare define_values = &program_data.define_values;

    if is_define(first) {
        first = get_define_retrieve_type_without_structure(define_types, define_values, first);
    };
    return concatenate3_brk_allocate(math_name, "_" first);
};

define process_comparison_invoke = function(nodes: *Nodes.Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, comparison_name: *): * {
    if stack_pointer.* == 0 {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(comparison_name);
        println("' ran out of stack values");
        exit(1);
    };

    declare first = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    declare second = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    declare size_function = program_data.get_size;
    if (!(size_function(first, nodes, program_data) == size_function(second, nodes, program_data))) || (!(is_signed(first, nodes) == is_signed(second, nodes))) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(comparison_name);
        print("' has incompatable arguments, given '");
        print(first);
        print("' and '");
        print(second);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, "boolean");

    declare define_types = &program_data.define_types;
    declare define_values = &program_data.define_values;

    if is_define(first) {
        first = get_define_retrieve_type_without_structure(define_types, define_values, first);
    };
    return concatenate3_brk_allocate(comparison_name, "_" first);
};

declare module_id_map: HashMap;
declare module_references_map: HashMap;
declare define_module_map: HashMap;

define setup_process = function(nodes: *Nodes.Nodes, program_data: *ProgramData) {
    declare node_count = nodes.index;

    declare module_stack = autobuffer_stack8_new(24);
    module_id_map = hashmap_new(64);
    module_references_map = hashmap_new(64);
    define_module_map = hashmap_new(64);

    declare define_types_stack = autobuffer_stack8_new(32);

    declare current_module_id = 0;

    declare declared_module_id = 0;

    declare in_function = false;

    declare i = 0;
    while i < node_count {
        declare id = Nodes.get_id(nodes, i);
        declare pointer_data = Nodes.get_pointer_data(nodes, i);

        declare next_id = Nodes.get_id(nodes, i + 1);

        if id == Node.DEFINE {
            declare define_data = Node.DefineData.pcast(pointer_data);
            declare define_name = define_data.name;

            hashmap_string_put(&define_module_map, define_name, whole_8.cast(autobuffer_stack8_peek(&module_stack)));

            if next_id == Node.MODULE {
                hashmap_string_put(&module_id_map, define_name, declared_module_id);
            };
        } else if id == Node.MODULE {
            autobuffer_stack8_push(&module_stack, declared_module_id);
            declared_module_id = declared_module_id + 1;
        } else if id == Node.ENDMODULE {
            declare _ = autobuffer_stack8_pop(&module_stack);
        };
        i = i + 1;
    };

    declare declared_function_id = 0;
    declare declared_structure_id = 0;
    declare declared_global_id = 0;
    declared_module_id = 0;

    declare define_types = &program_data.define_types;
    declare define_values = &program_data.define_values;
    declare define_or_declares = &program_data.define_or_declares;

    declare function_locations = &program_data.function_locations;
    declare function_datas = &program_data.function_datas;
    declare function_argument_names = &program_data.function_argument_names;
    declare function_argument_types = &program_data.function_argument_types;
    declare function_return_types = &program_data.function_return_types;
    declare function_return_types2 = &program_data.function_return_types2;

    declare internal_function_argument_types = &program_data.internal_function_argument_types;
    declare internal_function_argument_names = &program_data.internal_function_argument_names;
    declare internal_function_return_types = &program_data.internal_function_return_types;

    declare structure_datas = &program_data.structure_datas;
    declare structure_member_types = &program_data.structure_member_types;
    declare structure_members_names = &program_data.structure_member_names;

    declare global_types = &program_data.global_types;

    declare i = 0;
    while i < node_count {
        declare id = Nodes.get_id(nodes, i);
        declare pointer_data = Nodes.get_pointer_data(nodes, i);

        if id == Node.FUNCTION {
            declare function_data = Node.FunctionData.pcast(pointer_data);
            declare function_name = function_data.name;
            
            if !(function_name == NULL) {
                expand_function_data(function_data, &module_stack);

                hashmap_string_put(internal_function_argument_types, function_name, function_data.argument_types);
                hashmap_string_put(internal_function_argument_names, function_name, function_data.argument_names);
                hashmap_string_put(internal_function_return_types, function_name, function_data.return_types);
            } else {
                expand_function_data(function_data, &module_stack);

                autobuffer_array8_set(function_locations, declared_function_id, i);
                autobuffer_array8_set(function_datas, declared_function_id, function_data);
                autobuffer_array8_set(function_argument_types, declared_function_id, function_data.argument_types);
                autobuffer_array8_set(function_argument_names, declared_function_id, function_data.argument_names);
                autobuffer_array8_set(function_return_types2, declared_function_id, function_data.return_types);
                declared_function_id = declared_function_id + 1;
            };
            in_function = true;
        } else if id == Node.ENDFUNCTION {
            in_function = false;
        } else if id == Node.STRUCTURE {
            declare structure_data = Node.StructureData.pcast(pointer_data);

            if structure_data.name == NULL {
                autobuffer_array8_set(structure_member_types, declared_structure_id, structure_data.item_types);
                autobuffer_array8_set(structure_members_names, declared_structure_id, structure_data.item_names);

                // TODO: Depending on defines existing where it probably should not be.
                declare structure_name = #nodes_get_pointer_data(nodes, Node.DefineData, i - 1).name;
                structure_data.name = structure_name;

                declared_structure_id = declared_structure_id + 1;
            };

            autobuffer_stack8_push(structure_datas, structure_data);
        } else if id == Node.MODULE {
            autobuffer_stack8_push(&module_stack, declared_module_id);
            declared_module_id = declared_module_id + 1;
        } else if id == Node.ENDMODULE {
            declare _ = autobuffer_stack8_pop(&module_stack);
        } else if id == Node.DEFINE {
            declare define_data = Node.DefineData.pcast(pointer_data);
            declare define_name = define_data.name;
            declare define_type = define_data.type;

            // Calculate define_type
            if define_type == NULL {
                declare next_id = Nodes.get_id(nodes, i + 1);
                declare next_data = Nodes.get_pointer_data(nodes, i + 1);

                define_type = if next_id == Node.NUMBER {
                    declare number_data = Node.NumberData.pcast(next_data);
                    declare coersion = number_data.coersion;
                    if !(=(coersion, 0)) {
                        expand_module_name_array(coersion, 0, &module_id_map, &module_references_map, &module_stack, create_previous_results_list())
                    } else {
                        "whole_8"
                    }
                } else if next_id == Node.FUNCTION {
                    expand_function_data(Node.FunctionData.pcast(next_data), &module_stack);
                    function_data_to_string(&module_stack, Node.FunctionData.pcast(next_data))
                } else if next_id == Node.STRUCTURE {
                    structure_data_to_string(Node.StructureData.pcast(next_data))
                } else if next_id == Node.MODULE {
                    "module"
                } else if next_id == Node.RETRIEVE {
                    "define"
                } else {
                    print_node_error_beginning(nodes, i);
                    println("Unknown define type");
                    exit(1);
                    ""
                };

                define_data.type = define_type;
            } else {
                // TODO: Check to make sure type is valid
            };

            declare name = define_data.name;
            if module_stack.index > 0 {
                declare top_module = whole_8.cast(autobuffer_stack8_peek(&module_stack));
                declare top_module_string = any_16.>0();
                whole_8_to_string(top_module, &top_module_string);

                name = concatenate2_brk_allocate(&top_module_string, name);
            };

            declare previous_type = hashmap_string_get2(define_types, name);
            if !(previous_type == 999) {
                print_node_error_beginning(nodes, i);
                print("Duplicate definition '");
                print(name);
                println("'");
                exit(1);
            };

            hashmap_string_put(&define_module_map, name, whole_8.cast(autobuffer_stack8_peek(&module_stack)));

            if string=(define_type, "module") {
                hashmap_string_put(&module_id_map, name, declared_module_id);
            } else if string=(define_type, "define") {
                declare full_define = "";

                i = i + 1;
                declare j = 0;
                while |(Nodes.get_id(nodes, i + j) == Node.RETRIEVE, Nodes.get_id(nodes, i + j) == Node.SKIP) {
                    if Nodes.get_id(nodes, i + j) == Node.RETRIEVE {
                        declare retrieve_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, i + j);
                        declare retrieve_name = retrieve_data.name;

                        if string=(retrieve_name, "@current_module") {
                            declare top_module = whole_8.cast(autobuffer_stack8_peek(&module_stack));
                            declare top_module_string = any_16.>0();
                            whole_8_to_string(top_module, &top_module_string);

                            full_define = concatenate2_brk_allocate(full_define, &top_module_string);
                        } else {
                            full_define = concatenate3_brk_allocate(full_define, retrieve_name, ".");
                        };
                    };

                    j = j + 1;
                };

                full_define = substring_brk_allocate(full_define, 0, length(full_define) - 1);
                hashmap_string_put(&module_references_map, name, full_define);
            };

            define_name = get_define_name_with_module(&module_stack, define_name);
            define_data.name = define_name;

            declare define_value = if string_length=(define_type, "*function", 9) {
                declared_function_id
            } else if string_length=(define_type, "structure", 9) {
                declared_structure_id
            } else if string_length=(define_type, "global", 6) {
                declared_global_id
            } else if string_length=(define_type, "module", 6) {
                declared_module_id
            } else {
                #nodes_get_pointer_data(nodes, Node.NumberData, i + 1).value
            };

            autobuffer_stack8_push(&define_types_stack, define_type);

            hashmap_string_put(define_types, define_name, define_type);
            hashmap_string_put(define_values, define_name, define_value);
            hashmap_string_put(define_or_declares, define_name, "define");
        } else if id == Node.ENDDEFINE {
            declare _ = autobuffer_stack8_pop(&define_types_stack);
        } else if id == Node.DECLARE {
            if !in_function {
                declare declare_data = Node.DeclareData.pcast(pointer_data);
                declare declare_name = declare_data.name;
                declare declare_type = declare_data.type;
                declare_type = expand_module_name_array(declare_type, 0, &module_id_map, &module_references_map, &module_stack, create_previous_results_list());
                declare_name = get_define_name_with_module(&module_stack, declare_name);
                declare_data.name = declare_name;

                hashmap_string_put(define_types, declare_name, declare_type);
                hashmap_string_put(define_values, declare_name, declared_global_id);
                hashmap_string_put(define_or_declares, declare_name, "declare");
                autobuffer_array8_set(global_types, declared_global_id, declare_type);

                declared_global_id = declared_global_id + 1;
            };
        };

        i = i + 1;
    };
};

define expand_type_array = function(type: *, module_stack: *AutoBufferStack8): * {
    declare type_first = *.cast(array8_get(type, 0));
    return if string_length=(type_first, "*function[", 10) {
        declare function_data = string_to_function_data(type_first);
        expand_function_data(&function_data, module_stack);
        function_data_to_string(module_stack, &function_data)
    } else if string_length=(type_first, "**function[", 11) {
        declare function_data = string_to_function_data(type_first + 1);
        expand_function_data(&function_data, module_stack);
        function_data_to_string(module_stack, &function_data)
    } else {
        expand_module_name_array(type, 0, &module_id_map, &module_references_map, module_stack, create_previous_results_list())
    };
};

define expand_function_data = function(function_data: *Node.FunctionData, module_stack: *AutoBufferStack8) {
    declare j = 0;
    declare argument_types = function_data.argument_types;
    declare return_types = function_data.return_types;
    declare length = array8_length(argument_types);
    while j < length {
        declare argument = *.cast(array8_get(argument_types, j));
        declare expanded_argument = expand_type_array(argument, module_stack);
        array8_set(argument_types, j, create_size_one_array8_brk_allocate(expanded_argument));
        j = j + 1;
    };

    declare j = 0;
    declare length = array8_length(return_types);
    while j < length {
        declare return_ = *.cast(array8_get(return_types, j));
        declare expanded_return = expand_type_array(return_, module_stack);
        array8_set(return_types, j, create_size_one_array8_brk_allocate(expanded_return));
        j = j + 1;
    };
};

define expand_module_name = function(name_in: *, module_id_map: *HashMap, module_references_map: *HashMap, module_stack: *AutoBufferStack8, previous_results_list: *AutoBufferStack8): * {
    declare name = name_in;
    declare array = autobuffer_new(32);
    declare array_index = 0;
    declare buffer = autobuffer_buffer_new(64);

    declare i = 0;
    while i < length(name) {
        declare character = any_1.pcast(name + i).*;

        if character == ASCII.PERIOD {
            autobuffer_array8_set(&array, array_index, copy_string_brk_allocate(buffer.autobuffer.buffer));
            array_index = array_index + 1;
            autobuffer_buffer_reset(&buffer);
        } else {
            autobuffer_buffer_push_any_1(&buffer, character);
        };

        i = i + 1;
    };

    if length(buffer.autobuffer.buffer) > 0 {
        autobuffer_array8_set(&array, array_index, buffer.autobuffer.buffer);
        array_index = array_index + 1;
    };

    return expand_module_name_array(array.buffer, 0, module_id_map, module_references_map, module_stack, previous_results_list);
};

define create_previous_results_list = function(): *AutoBufferStack8 {
    declare new = autobuffer_stack8_new(32);
    declare allocated = AutoBufferStack8.pcast(brk_allocate(AutoBufferStack8.size()));
    allocated.* = new;
    return allocated;
};

define is_pointer = function(nodes: *Nodes.Nodes, index_in: whole_8): boolean {
    declare index = index_in;
    while true {
        declare id = Nodes.get_id(nodes, index);
        if id == Node.INVOKE_INTERNAL {
            declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, index);
            declare name = invoke_data.name;
            return string=(name, "&");
        } else if =(id, Node.SKIP) {
            
        } else {
            break;
        };

        index = index + 1;
    };
    return false;
};


define get_define_name_with_module = function(module_stack: *AutoBufferStack8, define_name: *): * {
    declare new_define_name = "";

    if module_stack.index > 0 {
        declare module_id = whole_8.cast(autobuffer_stack8_peek(module_stack));
        declare module_id_buffer = any_24.>0();
        whole_8_to_string(module_id, &module_id_buffer);

        new_define_name = copy_string_brk_allocate(&module_id_buffer);
    };

    return concatenate2_brk_allocate(new_define_name, define_name);
};
