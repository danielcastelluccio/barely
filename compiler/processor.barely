// TODO: Currently using a define to define a type as another will result in two equal types, I would prefer them to be unique, but is that really a good idea?
define is_type = function(wanted: *, given: *, nodes: *Nodes.Data, program_data: *ProgramData): boolean {
    if string=(wanted, given) {
        return true;
    };

    if string=(wanted, "") {
        return true;
    };

    if string_length=(wanted, "*", 1) {
        if string_length=(given, "*", 1) {
            return is_type(wanted + 1, given + 1, nodes, program_data);
        };
    };

    if string_length=(wanted, "any_", 4) {
        declare size = string_to_whole_8(wanted + 4);
        declare size_function = program_data.get_size;
        return size == size_function(given, nodes, program_data);
    };

    return false;
};

define is_signed = function(type: *, nodes: *Nodes.Data): whole_8 {
    declare cached_signedness = whole_8.cast(hashmap_string_get2(&cached_signedness_map, type));
    if !(cached_signedness == 999) {
        return cached_signedness;
    };

    if string_length=(type, "*", 1) {
        hashmap_string_put(&cached_signedness_map, type, 0);
        return 0;
    };

    if string_length=(type, "whole_", 6) {
        hashmap_string_put(&cached_signedness_map, type, 0);
        return 0;
    };
    if string_length=(type, "any_", 4) {
        hashmap_string_put(&cached_signedness_map, type, 0);
        return 0;
    };
    if string_length=(type, "integer_", 8) {
        hashmap_string_put(&cached_signedness_map, type, 1);
        return 1;
    };

    // Assuming all structures are unsigned?

    //declare node_count = nodes.index;
    //declare i = 0;
    //while i < node_count {
    //    if Nodes.get_id(nodes, i) == Node.STRUCTURE {
    //        declare pointer = *Node.StructureData.cast(Nodes.get_pointer_data(nodes, i));
    //        declare name = pointer.name;

    //        if !(name == 0) {
    //            declare member_types = pointer.item_types;
    //            if string=(type, name) {
    //                declare is_signed2 = is_signed(*.cast(array8_get(member_types, 0)), nodes);
    //                hashmap_string_put(&cached_signedness_map, type, is_signed2);
    //                return is_signed2;
    //            };
    //        };
    //    };
    //    i = i + 1;
    //};

    hashmap_string_put(&cached_signedness_map, type, 0);
    return 0;
};

define print_node_error_beginning = function(nodes: *Nodes.Data, location: whole_8) {
    declare location_data = Nodes.get_location_data(nodes, location);
    print("[ERROR] ");
    print(location_data.file);
    print(":");
    print_whole_8(location_data.row);
    print(":");
    print_whole_8(location_data.column);
    print(": ");
};

define ProgramData = structure {
    define_types: HashMap;
    define_values: HashMap;
    define_or_declares: HashMap;
    structure_datas: AutoBufferStack8;
    structure_member_types: AutoBuffer;
    structure_member_names: AutoBuffer;
    function_datas: AutoBuffer;
    function_locations: AutoBuffer;
    function_argument_types: AutoBuffer;
    function_argument_names: AutoBuffer;
    function_return_types: AutoBuffer;
    function_return_types2: AutoBuffer;
    internal_function_argument_types: HashMap;
    internal_function_argument_names: HashMap;
    internal_function_return_types: HashMap;
    global_types: AutoBuffer;

    // possible should be in a separate structure
    get_size: *function[*,*Nodes.Data,*ProgramData:whole_8];
};

define process = function(nodes: *Nodes.Data, size_function: *function[*,*Nodes.Data,*ProgramData:whole_8]): ProgramData {
    declare node_count = nodes.index;

    declare module_stack = autobuffer_stack8_new(32);

    declare program_data = ProgramData.>0();

    program_data.internal_function_argument_types = hashmap_new(1024);
    program_data.internal_function_argument_names = hashmap_new(1024);
    program_data.internal_function_return_types = hashmap_new(1024);

    program_data.define_types = hashmap_new(512);
    program_data.define_values = hashmap_new(512);
    program_data.define_or_declares = hashmap_new(512);

    program_data.function_locations = autobuffer_new(1024);
    program_data.function_datas = autobuffer_new(1024);
    program_data.function_argument_types = autobuffer_new(1024);
    program_data.function_argument_names = autobuffer_new(1024);
    program_data.function_return_types = autobuffer_new(1024);
    program_data.function_return_types2 = autobuffer_new(1024);

    program_data.structure_datas = autobuffer_stack8_new(1024);
    program_data.structure_member_types = autobuffer_new(1024);
    program_data.structure_member_names = autobuffer_new(1024);

    program_data.global_types = autobuffer_new(512);

    program_data.get_size = size_function;

    setup_process(nodes, &program_data);

    declare current_function_id = 0;

    declare variable_scopes_types_map = autobuffer_stack8_new(64);
    declare variable_scopes_declares_map = autobuffer_stack8_new(64);

    declare stack = autobuffer_stack8_new(64);

    declare if_blocks = autobuffer_stack8_new(64);
    declare if_block_results = autobuffer_new(64);

    declare function_id = 0;

    declare has_main = false;
    declare declared_function_id = 0;
    declare declared_module_id = 0;

    declare declared_function_id = 0;
    declare declared_module_id = 0;

    declare in_function = false;

    declare i = 0;
    while i < node_count {
        declare id = Nodes.get_id(nodes, i);
        declare pointer_data = Nodes.get_pointer_data(nodes, i);

        if id == Node.FUNCTION {
            declare function_name = *Node.FunctionData.cast(pointer_data).name;

            if function_name == NULL {
                current_function_id = function_id;
                function_id = function_id + 1;
            };
            in_function = true;

            stack.index = 0;
        } else if id == Node.NUMBER {
            process_number(&module_stack, nodes, i, &stack, pointer_data);
        } else if id == Node.BOOLEAN {
            autobuffer_stack8_push(&stack, "boolean");
        } else if id == Node.STRING {
            autobuffer_stack8_push(&stack, "*");
        } else if id == Node.INVOKE {
            process_invoke(nodes, i, &module_stack, &stack, &program_data, pointer_data);
        } else if id == Node.INVOKE_INTERNAL {
            process_invoke_internal(nodes, i, &module_stack, &stack, &program_data, pointer_data);
        } else if id == Node.CAST {
            declare cast_data = #nodes_get_pointer_data(nodes, Node.CastData, i);
            declare _ = autobuffer_stack8_pop(&stack);
            declare cast_to = expand_module_name_array(cast_data.type, 0, &module_id_map, &module_references_map, &module_stack, create_previous_results_list());
            autobuffer_stack8_push(&stack, cast_to);
        } else if id == Node.SIZE_OF {
            autobuffer_stack8_push(&stack, "whole_8");
        } else if id == Node.DECLARE {
            declare declare_data = *Node.DeclareData.cast(pointer_data);
            declare variable_name = declare_data.name;
            declare variable_type_names = declare_data.type;

            if in_function {
                hashmap_string_put(*HashMap.cast(autobuffer_stack8_peek(&variable_scopes_types_map)), variable_name, variable_type_names);
                hashmap_string_put(*HashMap.cast(autobuffer_stack8_peek(&variable_scopes_declares_map)), variable_name, i);
            };
        } else if id == Node.ASSIGN {
            process_assign(nodes, &i, &module_stack, &stack, &program_data, &variable_scopes_types_map, &variable_scopes_declares_map, pointer_data);
        } else if id == Node.RETRIEVE {
            if in_function {
                process_retrieve(nodes, &i, &module_stack, &stack, &variable_scopes_types_map, &program_data, current_function_id);
            };
        } else if id == Node.RETURN {
            process_return(nodes, i, &stack, &program_data, &module_stack, current_function_id);
        } else if id == Node.JUMP_CONDITIONAL {
            process_jump_conditional(nodes, i, &program_data, &stack);
        } else if id == Node.SCOPE {
            declare new_hashmap = hashmap_new(512);
            declare allocated = *HashMap.cast(brk_allocate(24));
            allocated.* = new_hashmap;
            autobuffer_stack8_push(&variable_scopes_types_map, allocated);

            declare new_hashmap = hashmap_new(512);
            declare allocated = *HashMap.cast(brk_allocate(24));
            allocated.* = new_hashmap;
            autobuffer_stack8_push(&variable_scopes_declares_map, allocated);
        } else if id == Node.ENDSCOPE {
            declare _ = autobuffer_stack8_pop(&variable_scopes_types_map);
            declare _ = autobuffer_stack8_pop(&variable_scopes_declares_map);
        } else if id == Node.STARTIFBLOCK {
            autobuffer_stack8_push(&if_blocks, stack.index);
        } else if id == Node.ENDIFBLOCK {
            process_end_if(nodes, i, &stack, &if_blocks, &if_block_results, pointer_data, &program_data);
        } else if id == Node.DEFINE {
            declare define_node_data = *Node.DefineData.cast(pointer_data);
            if string=(define_node_data.name, "main") {
                has_main = true;
            };
        } else if id == Node.ENDDEFINE {
        } else if id == Node.MODULE {
            autobuffer_stack8_push(&module_stack, declared_module_id);
            declared_module_id = declared_module_id + 1;
        } else if id == Node.ENDMODULE {
            declare _ = autobuffer_stack8_pop(&module_stack);
        } else if id == Node.JUMP {
        } else if id == Node.TARGET {
        } else if id == Node.ENDFUNCTION {
            in_function = false;
        } else if id == Node.STRUCTURE {
        } else if id == Node.SKIP {
        } else if id == Node.ENDSTATEMENT {
            if !(stack.index == 0) {
                print_node_error_beginning(nodes, i);
                println("Statement end has extra stack values");
                exit(1);

            };
        } else {
            print("Unhandled ");
            print_whole_8(id);
            println("");
        };

        i = i + 1;
    };
    
    if !(has_main) {
        println("[ERROR] No 'main' function defined");
        exit(1);
    };

    return program_data;
};

define is_define = function(type: *): boolean {
    if string_length=(type, "any_", 4) {
        return false;
    };
    if string_length=(type, "whole_", 6) {
        return false;
    };
    if string_length=(type, "integer_", 8) {
        return false;
    };
    if string_length=(type, "boolean", 6) {
        return false;
    };
    if string_length=(type, "*function[", 10) {
        return false;
    };
    if string=(type, "*") {
        return false;
    };
    return true;
};

define process_number = function(module_stack: *AutoBufferStack8, nodes: *Nodes.Data, nodes_index: whole_8, stack: *AutoBufferStack8, pointer_data: *) {
    declare number_data = *Node.NumberData.cast(pointer_data);

    declare coersion = number_data.coersion;
    if coersion == NULL {
        coersion = "whole_8";
    } else {
        coersion = *.cast(array8_get(coersion, 0));
    };

    if (!string_length=(coersion, "whole_", 6)) && (!string_length=(coersion, "integer_", 8)) {
        print_node_error_beginning(nodes, nodes_index);
        print("Number coersion '");
        print(coersion);
        println("' not allowed");
    };
    number_data.coersion = coersion;

    autobuffer_stack8_push(stack, coersion);
};

define process_jump_conditional = function(nodes: *Nodes.Data, nodes_index: whole_8, program_data: *ProgramData, stack: *AutoBufferStack8) {
    if stack.index == 0 {
        print_node_error_beginning(nodes, nodes_index);
        println("Conditional jump ran out of stack values");
        exit(1);
    };

    declare popped = *.cast(autobuffer_stack8_pop(stack));
    if !is_type(popped, "boolean", nodes, program_data) {
        print_node_error_beginning(nodes, nodes_index);
        print("Conditional Jump (if/while) wants 'boolean', given '");
        print(popped);
        println("'");
        exit(1);
    };
};

define process_return = function(nodes: *Nodes.Data, nodes_index: whole_8, stack: *AutoBufferStack8, program_data: *ProgramData, module_stack: *AutoBufferStack8, current_function_id: whole_8) {
    declare function_return_types = &program_data.function_return_types;
    declare function_return_types_specific = *.cast(autobuffer_array8_get(function_return_types, current_function_id));

    declare function_return_types2 = &program_data.function_return_types2;
    declare function_return_types2_specific = *.cast(autobuffer_array8_get(function_return_types2, current_function_id));

    declare temp = array8_length(function_return_types2_specific);
    declare j = temp - 1;
    while j < temp {
        declare function_return = *.cast(array8_get(function_return_types2_specific, j));
        function_return = *.cast(array8_get(function_return, 0));

        if stack.index == 0 {
            print_node_error_beginning(nodes, nodes_index);
            println("Return ran out of stack values");
            exit(1);
        };

        declare stack_popped = *.cast(autobuffer_stack8_pop(stack));
        
        if !is_type(function_return, stack_popped, nodes, program_data) {
            print_node_error_beginning(nodes, nodes_index);
            print("Return wants '");
            print(function_return);
            print("', given '");
            print(stack_popped);
            println("'");
            exit(1);
        };

        j = j - 1;
    };

    if stack.index > 0 {
        print_node_error_beginning(nodes, nodes_index);
        println("Return has extra stack values");
        exit(1);
    };
};

define process_end_if = function(nodes: *Nodes.Data, nodes_index: whole_8, stack: *AutoBufferStack8, if_blocks: *AutoBufferStack8, if_block_results: *AutoBuffer, pointer_data: *, program_data: *ProgramData) {
    declare end_if_data = *Node.EndIfBlockData.cast(pointer_data);
    declare end_if_id = end_if_data.id;
    declare is_last = end_if_data.is_last;
    declare is_bare_else = end_if_data.is_bare_else;

    declare start_stack = whole_8.cast(autobuffer_stack8_pop(if_blocks));
    declare previous_results = *.cast(autobuffer_array8_get(if_block_results, end_if_id));

    declare size = 8 * (stack.index - start_stack);
    if previous_results == NULL {
        previous_results = brk_allocate(8 + size);
        declare array = autobuffer_get_size(&stack.autobuffer, 8 * start_stack, size);
        copy(array, previous_results, size);

        autobuffer_array8_set(if_block_results, end_if_id, previous_results);

        if !is_last {
            declare j = 0;
            while j < size / 8 {
                declare _ = autobuffer_stack8_pop(stack);

                j = j + 1;
            };
        } else if (!is_bare_else) && (size > 0) {
            print_node_error_beginning(nodes, nodes_index);
            println("If expression resulting in a value requires an 'else' condition");
            exit(1);
        };
    } else {
        declare array = autobuffer_get_size(&stack.autobuffer, 8 * start_stack, size);
        declare previous_array = previous_results;

        declare max_size = size;
        if (array8_length(previous_array) * 8) > size {
            size = array8_length(previous_array) * 8;
        };

        declare j = 0;
        while j < size / 8 {
            declare previous_value = *.cast(array8_get(previous_array, j));
            declare value = *.cast(array8_get(array, j));

            declare error = false;

            if value == NULL {
                error = true;
            } else if previous_value == NULL {
                error = true;
            } else if !is_type(value, previous_value, nodes, program_data) {
                if is_type(previous_value, value, nodes, program_data) {
                    array8_set(previous_array, j, previous_value);
                    array8_set(array, j, previous_value);
                } else {
                    error = true;
                };
            } else if !is_last {
                declare _ = autobuffer_stack8_pop(stack);
            };

            if error {
                print_node_error_beginning(nodes, nodes_index);
                print("If does not have matching branch results (");
                print(value);
                print(", ");
                print(previous_value);
                println(")");
                exit(1);
            };

            j = j + 1;
        };
    };
};

define process_assign = function(nodes: *Nodes.Data, nodes_index_in: *whole_8, module_stack: *AutoBufferStack8, stack: *AutoBufferStack8, program_data: *ProgramData, variable_scopes_types_map: *AutoBufferStack8, variable_scopes_declares_map: *AutoBufferStack8, pointer_data: *) {
    declare nodes_index = nodes_index_in.*;
    declare assign_data = *Node.AssignData.cast(pointer_data);
    declare name = assign_data.name;
    declare uses_previous = assign_data.uses_previous;

    if stack.index == 0 {
        print_node_error_beginning(nodes, nodes_index);
        println("Assign ran out of stack values");
        exit(1);
    };

    if assign_data.has_multiple {
        declare full_name = expand_module_name_array(name, 0, &module_id_map, &module_references_map, module_stack, create_previous_results_list());
        name = full_name;
    };

    declare type = *.>0();

    if uses_previous {
        declare peeked = *.cast(autobuffer_stack8_peek(stack));

        declare top_define = *.>0();
        if string_length=(peeked, "module:", 7) {
            top_define = peeked + 7;
        };

        declare name_new = expand_module_name_stack(name, &module_id_map, &module_references_map, module_stack, top_define, create_previous_results_list());

        if !(string=(name, name_new)) {
            name = name_new;
            declare _ = autobuffer_stack8_pop(stack);
        } else {
            declare index = 0;
            declare type_temp = *.cast(autobuffer_stack8_peek(stack));
            if string_length=(type_temp, "*", 1) {
                type_temp = type_temp + 1;
            } else {
                Nodes.set_id(nodes, nodes_index + index, Node.INVOKE_INTERNAL);
                declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, nodes_index + index);
                invoke_data.name = "&";
                invoke_data.uses_previous = false;
                invoke_data.has_multiple = false;
                index = index + 1;

                type = concatenate2_brk_allocate("*", type_temp);
                declare _ = autobuffer_stack8_pop(stack);
                autobuffer_stack8_push(stack, type);
            };

            declare function_name = type_temp;
            Nodes.set_id(nodes, nodes_index + index, Node.RETRIEVE);
            declare retrieve_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, nodes_index + index);
            retrieve_data.name = function_name;
            retrieve_data.coercion = *.>0();
            retrieve_data.uses_previous = false;
            retrieve_data.has_multiple = false;
            index = index + 1;

            declare function_name = if string=(name, "*") {
                "<2"
            } else {
                concatenate2_brk_allocate("<2", name)
            };
            Nodes.set_id(nodes, nodes_index + index, Node.INVOKE_INTERNAL);
            declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, nodes_index + index);
            invoke_data.name = function_name;
            invoke_data.uses_previous = true;

            nodes_index_in.* = nodes_index_in.* - 1;
            return;
        };
    };

    declare popped_stack = *.cast(autobuffer_stack8_pop(stack));

    declare scope_index, variable_type = get_variable_info(variable_scopes_types_map, name);
    if !(variable_type == NULL) {
        if string=(variable_type, "") {
            variable_type = create_size_one_array8_brk_allocate(popped_stack);

            hashmap_string_put(*HashMap.cast(autobuffer_stack8_get(variable_scopes_types_map, scope_index)), name, variable_type);

            declare variable_declare_node_index = hashmap_string_get(*HashMap.cast(autobuffer_stack8_get(variable_scopes_declares_map, scope_index)), name);
            declare variable_declare_node = *Node.DeclareData.cast(Nodes.get_pointer_data(nodes, whole_8.cast(variable_declare_node_index)));
            variable_declare_node.type = variable_type;
        };

        type = *.cast(array8_get(variable_type, 0));
        if !is_type(type, popped_stack, nodes, program_data) {
            print_node_error_beginning(nodes, nodes_index);
            print("Assign of ");
            print(name);
            print(" wants '");
            print(type);
            print("', given '");
            print(popped_stack);
            println("'");
            exit(1);
        };
    };

    declare define_types = &program_data.define_types;
    declare define_values = &program_data.define_values;
    if type == NULL {
        type = get_define_retrieve_type(define_types, define_values, name);
    };

    if !(type == NULL) {
        if !is_type(type, popped_stack, nodes, program_data) {
            print_node_error_beginning(nodes, nodes_index);
            print("Assign of ");
            print(name);
            print(" wants '");
            print(type);
            print("', given '");
            print(popped_stack);
            println("'");
            exit(1);
        };
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Assign target '");
        print(name);
        println("' not found");
        exit(1);
    };
};

define get_variable_info = function(variable_scopes_types_map: *AutoBufferStack8, variable_name: *): whole_8, * {
    declare max_index = variable_scopes_types_map.index;
    declare scope_index = max_index - 1;
    declare variable_type = *.cast(0);
    while (variable_type == NULL) && (scope_index < max_index) {
        declare scope_map = *HashMap.cast(autobuffer_stack8_get(variable_scopes_types_map, scope_index));
        variable_type = *.cast(hashmap_string_get(scope_map, variable_name));
        scope_index = scope_index - 1;
    };
    scope_index = scope_index + 1;

    return scope_index, variable_type;
};

define get_define_type = function(define_types: *HashMap, define_values: *HashMap, define_name: *): * {
    return *.cast(hashmap_string_get(define_types, define_name));
};

define get_define_retrieve_type_without_structure = function(define_types: *HashMap, define_values: *HashMap, define_name: *): * {
    declare define_type = get_define_type(define_types, define_values, define_name);
    if define_type == NULL {

    } else if string_length=(define_type, "global[", 7) {
        define_type = substring_brk_allocate(define_type, 7, string_length(define_type) - 1);
    } else if string_length=(define_type, "structure[", 10) {
        define_type = define_name;
    };

    return define_type;
};

define get_define_retrieve_type = function(define_types: *HashMap, define_values: *HashMap, define_name: *): * {
    declare define_type = get_define_type(define_types, define_values, define_name);
    if define_type == NULL {

    } else if string_length=(define_type, "global[", 7) {
        define_type = substring_brk_allocate(define_type, 7, string_length(define_type) - 1);
    };

    return define_type;
};

define get_value_of_define = function(define_types: *HashMap, define_values: *HashMap, define_name: *): any_8 {
    return *.cast(hashmap_string_get2(define_values, define_name));
};

define process_retrieve = function(nodes: *Nodes.Data, nodes_index_in: *whole_8, module_stack: *AutoBufferStack8, stack: *AutoBufferStack8, variable_scopes_types_map: *AutoBufferStack8, program_data: *ProgramData, current_function_id: whole_8) {
    declare nodes_index = nodes_index_in.*;
    declare retrieve_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, nodes_index);
    declare name = retrieve_data.name;
    declare uses_previous = retrieve_data.uses_previous;
    declare coercion = retrieve_data.coercion;

    declare type = *.>0();

    if retrieve_data.has_multiple {
        declare last_element = *.cast(array8_get(name, array8_length(name) - 1));
        declare resolvable_end = 0;
        if string=(last_element, "cast") {
            resolvable_end = array8_length(name) - 1;
        };
        declare full_name = expand_module_name_array(name, resolvable_end, &module_id_map, &module_references_map, module_stack, create_previous_results_list());
        name = full_name;
    };

    if uses_previous {
        declare peeked = *.cast(autobuffer_stack8_peek(stack));

        declare top_define = *.>0();
        if string_length=(peeked, "module:", 7) {
            top_define = peeked + 7;
        };

        declare name_new = expand_module_name_stack(name, &module_id_map, &module_references_map, module_stack, top_define, create_previous_results_list());

        if !(string=(name, name_new)) {
            name = name_new;
            declare _ = autobuffer_stack8_pop(stack);
        } else {
            declare index = 0;
            declare type_temp = *.cast(autobuffer_stack8_peek(stack));
            if string_length=(type_temp, "*", 1) {
                type_temp = type_temp + 1;
            } else {
                Nodes.set_id(nodes, nodes_index + index, Node.INVOKE_INTERNAL);
                declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, nodes_index + index);
                invoke_data.name = "&";
                invoke_data.uses_previous = false;
                index = index + 1;

                type = concatenate2_brk_allocate("*", type_temp);
                declare _ = autobuffer_stack8_pop(stack);
                autobuffer_stack8_push(stack, type);
            };

            declare function_name = type_temp;
            Nodes.set_id(nodes, nodes_index + index, Node.RETRIEVE);
            declare retrieve_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, nodes_index + index);
            retrieve_data.name = function_name;
            retrieve_data.coercion = *.>0();
            retrieve_data.uses_previous = false;
            index = index + 1;

            declare function_name = if string=(name, "*") {
                ">"
            } else {
                concatenate2_brk_allocate(">", name)
            };
            Nodes.set_id(nodes, nodes_index + index, Node.INVOKE_INTERNAL);
            declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, nodes_index + index);
            invoke_data.name = function_name;
            invoke_data.uses_previous = true;

            nodes_index_in.* = nodes_index_in.* - 1;
            return;
        };
    };

    declare scope_index, variable_type = get_variable_info(variable_scopes_types_map, name);
    if !(variable_type == NULL) {
        type = expand_module_name_array(variable_type, 0, &module_id_map, &module_references_map, module_stack, create_previous_results_list());
    };

    if type == NULL {
        declare function_argument_types = &program_data.function_argument_types;
        declare function_argument_names = &program_data.function_argument_names;
        declare function_argument_names_specific = *.cast(autobuffer_array8_get(function_argument_names, current_function_id));
        declare function_argument_types_specific = *.cast(autobuffer_array8_get(function_argument_types, current_function_id));

        declare argument_type = stringarray_get(function_argument_names_specific, function_argument_types_specific, name, array8_length(function_argument_types_specific));
        if !(argument_type == NULL) {
            type = expand_module_name_array(argument_type, 0, &module_id_map, &module_references_map, module_stack, create_previous_results_list());
        };
    };

    declare define_types = &program_data.define_types;
    declare define_values = &program_data.define_values;

    if type == NULL {
        declare found = false;
        declare i = 0;
        while i < module_stack.index {
            declare module_id = whole_8.cast(autobuffer_stack8_get(module_stack, i));
            declare module_id_string = any_24.>0();
            whole_8_to_string(module_id, &module_id_string);
            declare name_temp = concatenate2_brk_allocate(&module_id_string, name);
            type = get_define_retrieve_type(define_types, define_values, name_temp);

            if !(type == NULL) {
                name = name_temp;
                found = true;
                break;
            };
            i = i + 1;
        };

        if !found {
            type = get_define_retrieve_type(define_types, define_values, name);
        };
    };

    if !(type == NULL) {
        while string=(type, "define") {
            declare value = *.cast(get_value_of_define(define_types, define_values, name));
            declare reference = *.cast(hashmap_string_get(&module_references_map, name));
            declare expanded = expand_module_name_array(reference, 0, &module_id_map, &module_references_map, module_stack, create_previous_results_list());
            name = expanded;
            type = get_define_retrieve_type(define_types, define_values, name);
        };

        if string=(type, "module") {
            type = concatenate2_brk_allocate("module:", name);
        } else if string_length=(type, "structure[", 10) {
            type = concatenate2_brk_allocate("structure:", name);
        };

        if is_pointer(nodes, nodes_index + 1) {
            type = concatenate2_brk_allocate("*", type);
        };
    };

    // TODO: add checks to ensure that this is valid
    if !(coercion == NULL) {
        type = *.cast(array8_get(coercion, 0));
    };

    if string_length=(name, "any_", 4) {
        type = concatenate2_brk_allocate("structure:", name);
    };

    if string=(name, "@current_module") {
        type = concatenate2_brk_allocate("module:", name);
    };

    if !(type == NULL) {
        if string_length=(type, "structure:", 10) {
            while true {
                if stack.index > 0 {
                    if string=(*.cast(autobuffer_stack8_peek(stack)), "structure:*") {
                        declare popped = *.cast(autobuffer_stack8_pop(stack));
                        type = concatenate2_brk_allocate("*", type);
                    } else {
                        break;
                    };
                } else {
                    break;
                };
            };
        };

        autobuffer_stack8_push(stack, type);
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Retrieve target '");
        print(name);
        println("' not found");
        exit(1);
    };
};

define process_invoke = function(nodes: *Nodes.Data, nodes_index: whole_8, module_stack: *AutoBufferStack8, stack: *AutoBufferStack8, program_data: *ProgramData, pointer_data: *) {
    declare function_type = *.cast(autobuffer_stack8_pop(stack));

    if string_length=(function_type, "*function[", 10) {
        declare type = string_to_function_data(function_type);
        declare arguments_buffer = type.argument_types;
        declare returns_buffer = type.return_types;

        declare k = integer_8.cast(array8_length(arguments_buffer));
        while k > 0:integer_8 {
            k = k - 1:integer_8;

            if stack.index == 0 {
                print_node_error_beginning(nodes, nodes_index);
                print("Invoke of '");
                if Nodes.get_id(nodes, nodes_index - 1) == Node.RETRIEVE {
                    declare previous_node_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, nodes_index - 1);
                    print(previous_node_data.name);
                } else {
                    print("unknown");
                };
                println("' ran out of stack values");
                exit(1);
            };

            declare given = *.cast(autobuffer_stack8_pop(stack));
            declare wanted = *.cast(array8_get(arguments_buffer, whole_8.cast(k)));
            wanted = *.cast(array8_get(wanted, 0));

            if !is_type(wanted, given, nodes, program_data) {
                print_node_error_beginning(nodes, nodes_index);
                print("Invoke of '");

                if Nodes.get_id(nodes, nodes_index - 1) == Node.RETRIEVE {
                    declare previous_node_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, nodes_index - 1);
                    print(previous_node_data.name);
                } else {
                    print("unknown");
                };

                print("' wants '");
                print(wanted);
                print("', given '");
                print(given);
                println("'");
                exit(1);
            };
        };

        declare k = 0;
        declare length = array8_length(returns_buffer);
        while k < length {
            declare return_type = *.cast(array8_get(returns_buffer, k));
            declare return_type = *.cast(array8_get(return_type, 0));

            autobuffer_stack8_push(stack, return_type);
            k = k + 1;
        };
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Attempting to invoke non function pointer '");
        print(function_type);
        println("'");
        exit(1);
    };
};

define process_invoke_internal = function(nodes: *Nodes.Data, nodes_index: whole_8, module_stack: *AutoBufferStack8, stack: *AutoBufferStack8, program_data: *ProgramData, pointer_data: *) {
    declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, nodes_index);
    declare function_name = invoke_data.name;
    declare is_single = !invoke_data.uses_previous;

    if invoke_data.has_multiple {
        function_name = *.cast(array8_get(function_name, array8_length(function_name) - 1));
    };

    if is_single && string=(function_name, "+") {
        invoke_data.name = process_math_invoke(nodes, nodes_index, stack, program_data, "+");
    } else if is_single && string=(function_name, "-") {
        invoke_data.name = process_math_invoke(nodes, nodes_index, stack, program_data, "-");
    } else if is_single && string=(function_name, "*") {
        invoke_data.name = process_math_invoke(nodes, nodes_index, stack, program_data, "*");
    } else if is_single && string=(function_name, "/") {
        invoke_data.name = process_math_invoke(nodes, nodes_index, stack, program_data, "/");
    } else if is_single && string=(function_name, "%") {
        invoke_data.name = process_math_invoke(nodes, nodes_index, stack, program_data, "%");
    } else if is_single && string=(function_name, "=") {
        invoke_data.name = process_comparison_invoke(nodes, nodes_index, stack, program_data, "=");
    } else if is_single && string=(function_name, ">") {
        invoke_data.name = process_comparison_invoke(nodes, nodes_index, stack, program_data, ">");
    } else if is_single && string=(function_name, "<") {
        invoke_data.name = process_comparison_invoke(nodes, nodes_index, stack, program_data, "<");
    } else if (string=(function_name, "cast") || string=(function_name, "pcast")) && (!invoke_data.has_multiple) {
        process_cast(nodes, nodes_index, module_stack, stack, program_data, invoke_data, function_name);
    } else if string=(function_name, "cast") || string=(function_name, "pcast") {
        process_cast_new(nodes, nodes_index, module_stack, stack, program_data, invoke_data, invoke_data.name);
    } else if is_single && string=(function_name, "&") {
    } else {
        function_name = if !is_single {
            declare popped = *.cast(autobuffer_stack8_pop(stack));
            if !string_length=(popped, "structure:", 10) {
                if string_length=(popped, "module:", 7) {
                    print_node_error_beginning(nodes, nodes_index);
                    print("Attempting to invoke structure function on module '");
                    print(popped + 7);
                    println("'");
                    exit(1);
                };
            };
            concatenate2_brk_allocate(popped + 10, function_name)
        } else {
            function_name
        };
        process_internal_invoke(nodes, nodes_index, stack, program_data, module_stack, function_name);

        invoke_data.name = function_name;
    };
};

define expand_module_name_stack = function(name_in: *, module_id_map: *HashMap, module_references_map: *HashMap, module_stack: *AutoBufferStack8, top_define: *, previous_results_list: *AutoBufferStack8): * {
    declare name = name_in;
    declare pointer_count = 0;
    while (*any_1.cast(name + pointer_count).* == ASCII.ASTERISK) && (pointer_count < string_length(name)) {
         pointer_count = pointer_count + 1;
    };

    name  = name + pointer_count;

    if string_length(name) > 0 {
        declare current_module_id = if !(top_define == NULL) {
            if string=(top_define, "@current_module") {
                whole_8.cast(autobuffer_stack8_peek(module_stack))
            } else {
                whole_8.cast(hashmap_string_get2(module_id_map, top_define))
            }
        } else {
            999
        };

        if !(current_module_id == 999) {
            declare current_module_id_string = any_16.>0();
            whole_8_to_string(current_module_id, &current_module_id_string);
            name = concatenate2_brk_allocate(&current_module_id_string, name);
        };

        declare possible_reference = *.cast(hashmap_string_get2(module_references_map, name));
        if !(possible_reference == 999) {
            declare i = 0;
            while i < previous_results_list.index {
                if string=(*.cast(autobuffer_stack8_get(previous_results_list, i)), name) {
                    return name;
                };
                i = i + 1;
            };
            autobuffer_stack8_push(previous_results_list, name);

            name = expand_module_name_array(possible_reference, 0, module_id_map, module_references_map, module_stack, previous_results_list);
        };
    };

    declare i = 0;
    while i < pointer_count {
        name = concatenate2_brk_allocate("*", name);
        i = i + 1;
    };

    return name;
};

define expand_module_name_array = function(name_array: *, resolvable_end: whole_8, module_id_map: *HashMap, module_references_map: *HashMap, module_stack: *AutoBufferStack8, previous_results_list: *AutoBufferStack8): * {
    if array8_length(name_array) == 1 {
        return *.cast(array8_get(name_array, 0));
    };

    declare name = *.cast(array8_get(name_array, 0));
    declare pointer_count = 0;
    while (*any_1.cast(name + pointer_count).* == ASCII.ASTERISK) && (pointer_count < string_length(name)) {
         pointer_count = pointer_count + 1;
    };

    // TODO: lol
    name = *.cast(array8_get(name_array, array8_length(name_array) - 1));

    declare current_module_id = 999;
    declare i = 0;
    declare is_first = true;
    while i < ((array8_length(name_array) - resolvable_end) - 1) {
        declare current_module = *.cast(array8_get(name_array, i));
        if is_first {
            current_module = current_module + pointer_count;
        };
        is_first = false;

        declare new_id = if string=(current_module, "@current_module") {
            whole_8.cast(autobuffer_stack8_peek(module_stack))
        } else if =(current_module_id, 999) {
            declare temp_id = whole_8.cast(hashmap_string_get2(module_id_map, current_module));

            if temp_id == 999 {
                declare temp_name = *.cast(hashmap_string_get2(module_references_map, current_module));
                temp_name = expand_module_name_array(temp_name, 0, module_id_map, module_references_map, module_stack, create_previous_results_list());
                temp_id = whole_8.cast(hashmap_string_get2(module_id_map, temp_name));
            };
            temp_id
        } else {
            declare current_module_id_string = any_16.>0();
            whole_8_to_string(current_module_id, &current_module_id_string);

            declare current_module_full = concatenate2_brk_allocate(&current_module_id_string, current_module);
            declare temp_id = whole_8.cast(hashmap_string_get2(module_id_map, current_module_full));

            if temp_id == 999 {
                declare temp_name = *.cast(hashmap_string_get2(module_references_map, current_module_full));
                if temp_name == 999 {
                    return name;
                };

                temp_name = expand_module_name_array(temp_name, 0, module_id_map, module_references_map, module_stack, create_previous_results_list());
                temp_id = whole_8.cast(hashmap_string_get2(module_id_map, temp_name));
            };
            temp_id
        };

        current_module_id = new_id;
        i = i + 1;
    };

    if !(current_module_id == 999) {
        declare current_module_id_string = any_16.>0();
        whole_8_to_string(current_module_id, &current_module_id_string);
        name = concatenate2_brk_allocate(&current_module_id_string, *.cast(array8_get(name_array, (array8_length(name_array) - resolvable_end) - 1)));
    } else {
        name = *.cast(array8_get(name_array, (array8_length(name_array) - resolvable_end) - 1));
    };

    declare possible_reference = *.cast(hashmap_string_get2(module_references_map, name));
    if !(possible_reference == 999) {
        declare i = 0;
        while i < previous_results_list.index {
            if string=(*.cast(autobuffer_stack8_get(previous_results_list, i)), name) {
                return name;
            };
            i = i + 1;
        };
        autobuffer_stack8_push(previous_results_list, name);

        name = expand_module_name_array(possible_reference, 0, module_id_map, module_references_map, module_stack, previous_results_list);
    };

    if !is_first {
        declare i = 0;
        while i < pointer_count {
            name = concatenate2_brk_allocate("*", name);
            i = i + 1;
        };
    };

    return name;
};

define print_array8_string = function(array: *) {
    print("[");
    declare i = 0;
    while i < array8_length(array) {
        print(*.cast(array8_get(array, i)));
        print(", ");
        i = i + 1;
    };
    println("]");
};

define process_cast = function(nodes: *Nodes.Data, nodes_index: whole_8, module_stack: *AutoBufferStack8, stack: *AutoBufferStack8, program_data: *ProgramData, invoke_data: *Node.InvokeInternalData, function_name: *) {
    if stack.index == 0 {
        print_node_error_beginning(nodes, nodes_index);
        println("Cast ran out of stack values");
        exit(1);
    };

    declare pointer_count = 0;
    declare popped = *.cast(autobuffer_stack8_pop(stack));
    while *any_1.cast(popped + pointer_count).* == ASCII.ASTERISK {
        pointer_count = pointer_count + 1;
    };

    declare to_push = popped + pointer_count + 10;
    declare i = 0;
    while i < pointer_count {
        to_push = concatenate2_brk_allocate("*", to_push);
        i = i + 1;
    };

    if string=(function_name, "pcast") {
        to_push = concatenate2_brk_allocate("*", to_push);
    };

    declare popped = *.cast(autobuffer_stack8_pop(stack));

    declare size_function = program_data.get_size;
    if !(size_function(popped, nodes, program_data) == size_function(to_push, nodes, program_data)) {
        print_node_error_beginning(nodes, nodes_index);
        print("Cast wants equal sized types, given '");
        print(popped);
        print("' and casts to '");
        print(to_push);
        println("'");
        exit(1);
    };

    autobuffer_stack8_push(stack, to_push);

    Nodes.set_skip(nodes, nodes_index - 1);
};

define process_cast_new = function(nodes: *Nodes.Data, nodes_index: whole_8, module_stack: *AutoBufferStack8, stack: *AutoBufferStack8, program_data: *ProgramData, invoke_data: *Node.InvokeInternalData, function_name: *) {
    if stack.index == 0 {
        print_node_error_beginning(nodes, nodes_index);
        println("Cast ran out of stack values");
        exit(1);
    };

    declare to_push = expand_module_name_array(function_name, array8_length(function_name) - 1, &module_id_map, &module_references_map, module_stack, create_previous_results_list());

    if string=(function_name, "pcast") {
        to_push = concatenate2_brk_allocate("*", to_push);
    };

    declare popped = *.cast(autobuffer_stack8_pop(stack));

    declare size_function = program_data.get_size;
    if !(size_function(popped, nodes, program_data) == size_function(to_push, nodes, program_data)) {
        print_node_error_beginning(nodes, nodes_index);
        print("Cast wants equal sized types, given '");
        print(popped);
        print("' and casts to '");
        print(to_push);
        println("'");
        exit(1);
    };

    autobuffer_stack8_push(stack, to_push);

    Nodes.set_skip(nodes, nodes_index - 1);
};

define process_internal_invoke = function(nodes: *Nodes.Data, nodes_index: whole_8, stack: *AutoBufferStack8, program_data: *ProgramData, module_stack: *AutoBufferStack8, function_name: *) {
    declare found_function = false;

    declare internal_function_argument_types = &program_data.internal_function_argument_types;
    declare internal_function_return_types = &program_data.internal_function_return_types;

    if hashmap_string_get(internal_function_argument_types, function_name) == NULL {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke target '");
        print(function_name);
        println("' not found");
        exit(1);
    };

    declare arguments = *.cast(hashmap_string_get(internal_function_argument_types, function_name));
    declare returns = *.cast(hashmap_string_get(internal_function_return_types, function_name));

    declare arguments_length = array8_length(arguments);
    declare k = 0;
    while k < arguments_length {
        if stack.index == 0 {
            print_node_error_beginning(nodes, nodes_index);
            print("Invoke of '");
            print(function_name);
            println("' ran out of stack values");
            exit(1);
        };

        declare given = *.cast(autobuffer_stack8_pop(stack));
        declare wanted = *.cast(array8_get(arguments, (arguments_length - k) - 1));
        wanted = *.cast(array8_get(wanted, 0));
        if !is_type(wanted, given, nodes, program_data) {
            print_node_error_beginning(nodes, nodes_index);
            print("Invoke of '");
            print(function_name);
            print("' wants '");
            print(wanted);
            print("', given '");
            print(given);
            println("'");
            exit(1);
        };

        k = k + 1;
    };

    declare k = 0;
    while !(array8_get(returns, k) == NULL) {
        declare return_value = *.cast(array8_get(returns, k));
        return_value = *.cast(array8_get(return_value, 0));
        if is_pointer(nodes, nodes_index + 1) {
            return_value = concatenate2_brk_allocate("*", return_value);
        };

        autobuffer_stack8_push(stack, return_value);

        k = k + 1;
    };
};

define process_math_invoke = function(nodes: *Nodes.Data, nodes_index: whole_8, stack: *AutoBufferStack8, program_data: *ProgramData, math_name: *): * {
    if stack.index < 2 {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(math_name);
        println("' ran out of stack values");
        exit(1);
    };

    declare first = *.cast(autobuffer_stack8_pop(stack));
    declare second = *.cast(autobuffer_stack8_pop(stack));

    declare size_function = program_data.get_size;
    if (!size_function(first, nodes, program_data) == size_function(second, nodes, program_data)) || (!is_signed(first, nodes) == is_signed(second, nodes)) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(math_name);
        print("' wants matching arguments, given '");
        print(first);
        print("' and '");
        print(second);
        println("'");
        exit(1);
    };

    autobuffer_stack8_push(stack, second);

    declare define_types = &program_data.define_types;
    declare define_values = &program_data.define_values;

    if is_define(first) {
        first = get_define_retrieve_type_without_structure(define_types, define_values, first);
    };
    return concatenate3_brk_allocate(math_name, "_" first);
};

define process_comparison_invoke = function(nodes: *Nodes.Data, nodes_index: whole_8, stack: *AutoBufferStack8, program_data: *ProgramData, comparison_name: *): * {
    if stack.index == 0 {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(comparison_name);
        println("' ran out of stack values");
        exit(1);
    };

    declare first = *.cast(autobuffer_stack8_pop(stack));
    declare second = *.cast(autobuffer_stack8_pop(stack));

    declare size_function = program_data.get_size;
    if (!(size_function(first, nodes, program_data) == size_function(second, nodes, program_data))) || (!(is_signed(first, nodes) == is_signed(second, nodes))) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(comparison_name);
        print("' has incompatable arguments, given '");
        print(first);
        print("' and '");
        print(second);
        println("'");
        exit(1);
    };

    autobuffer_stack8_push(stack, "boolean");

    declare define_types = &program_data.define_types;
    declare define_values = &program_data.define_values;

    if is_define(first) {
        first = get_define_retrieve_type_without_structure(define_types, define_values, first);
    };
    return concatenate3_brk_allocate(comparison_name, "_" first);
};

declare module_id_map: HashMap;
declare module_references_map: HashMap;
declare define_module_map: HashMap;

define setup_process = function(nodes: *Nodes.Data, program_data: *ProgramData) {
    declare node_count = nodes.index;

    declare module_stack = autobuffer_stack8_new(24);
    module_id_map = hashmap_new(64);
    module_references_map = hashmap_new(64);
    define_module_map = hashmap_new(64);

    declare define_types_stack = autobuffer_stack8_new(32);

    declare current_module_id = 0;

    declare declared_module_id = 0;

    declare in_function = false;

    declare i = 0;
    while i < node_count {
        declare id = Nodes.get_id(nodes, i);
        declare pointer_data = Nodes.get_pointer_data(nodes, i);

        declare next_id = Nodes.get_id(nodes, i + 1);

        if id == Node.DEFINE {
            declare define_data = *Node.DefineData.cast(pointer_data);
            declare define_name = define_data.name;

            hashmap_string_put(&define_module_map, define_name, whole_8.cast(autobuffer_stack8_peek(&module_stack)));

            if next_id == Node.MODULE {
                hashmap_string_put(&module_id_map, define_name, declared_module_id);
            };
        } else if id == Node.MODULE {
            autobuffer_stack8_push(&module_stack, declared_module_id);
            declared_module_id = declared_module_id + 1;
        } else if id == Node.ENDMODULE {
            declare _ = autobuffer_stack8_pop(&module_stack);
        };
        i = i + 1;
    };

    declare declared_function_id = 0;
    declare declared_structure_id = 0;
    declare declared_global_id = 0;
    declared_module_id = 0;

    declare define_types = &program_data.define_types;
    declare define_values = &program_data.define_values;
    declare define_or_declares = &program_data.define_or_declares;

    declare function_locations = &program_data.function_locations;
    declare function_datas = &program_data.function_datas;
    declare function_argument_names = &program_data.function_argument_names;
    declare function_argument_types = &program_data.function_argument_types;
    declare function_return_types = &program_data.function_return_types;
    declare function_return_types2 = &program_data.function_return_types2;

    declare internal_function_argument_types = &program_data.internal_function_argument_types;
    declare internal_function_argument_names = &program_data.internal_function_argument_names;
    declare internal_function_return_types = &program_data.internal_function_return_types;

    declare structure_datas = &program_data.structure_datas;
    declare structure_member_types = &program_data.structure_member_types;
    declare structure_members_names = &program_data.structure_member_names;

    declare global_types = &program_data.global_types;

    declare i = 0;
    while i < node_count {
        declare id = Nodes.get_id(nodes, i);
        declare pointer_data = Nodes.get_pointer_data(nodes, i);

        if id == Node.FUNCTION {
            declare function_data = *Node.FunctionData.cast(pointer_data);
            declare function_name = function_data.name;
            
            if !(function_name == NULL) {
                expand_function_data(function_data, &module_stack);

                hashmap_string_put(internal_function_argument_types, function_name, function_data.argument_types);
                hashmap_string_put(internal_function_argument_names, function_name, function_data.argument_names);
                hashmap_string_put(internal_function_return_types, function_name, function_data.return_types);
            } else {
                expand_function_data(function_data, &module_stack);

                autobuffer_array8_set(function_locations, declared_function_id, i);
                autobuffer_array8_set(function_datas, declared_function_id, function_data);
                autobuffer_array8_set(function_argument_types, declared_function_id, function_data.argument_types);
                autobuffer_array8_set(function_argument_names, declared_function_id, function_data.argument_names);
                autobuffer_array8_set(function_return_types2, declared_function_id, function_data.return_types);
                declared_function_id = declared_function_id + 1;
            };
            in_function = true;
        } else if id == Node.ENDFUNCTION {
            in_function = false;
        } else if id == Node.STRUCTURE {
            declare structure_data = *Node.StructureData.cast(pointer_data);

            if structure_data.name == NULL {
                expand_structure_data(structure_data, &module_stack);
                autobuffer_array8_set(structure_member_types, declared_structure_id, structure_data.item_types);
                autobuffer_array8_set(structure_members_names, declared_structure_id, structure_data.item_names);

                // TODO: Depending on defines existing where it probably should not be.
                declare structure_name = #nodes_get_pointer_data(nodes, Node.DefineData, i - 1).name;
                structure_data.name = structure_name;

                declared_structure_id = declared_structure_id + 1;
            };

            autobuffer_stack8_push(structure_datas, structure_data);
        } else if id == Node.MODULE {
            autobuffer_stack8_push(&module_stack, declared_module_id);
            declared_module_id = declared_module_id + 1;
        } else if id == Node.ENDMODULE {
            declare _ = autobuffer_stack8_pop(&module_stack);
        } else if id == Node.DEFINE {
            declare define_data = *Node.DefineData.cast(pointer_data);
            declare define_name = define_data.name;
            declare define_type = define_data.type;

            // Calculate define_type
            if define_type == NULL {
                declare next_id = Nodes.get_id(nodes, i + 1);
                declare next_data = Nodes.get_pointer_data(nodes, i + 1);

                define_type = if next_id == Node.NUMBER {
                    declare number_data = *Node.NumberData.cast(next_data);
                    declare coersion = number_data.coersion;
                    if !(=(coersion, 0)) {
                        expand_module_name_array(coersion, 0, &module_id_map, &module_references_map, &module_stack, create_previous_results_list())
                    } else {
                        "whole_8"
                    }
                } else if next_id == Node.FUNCTION {
                    expand_function_data(*Node.FunctionData.cast(next_data), &module_stack);
                    function_data_to_string(&module_stack, *Node.FunctionData.cast(next_data))
                } else if next_id == Node.STRUCTURE {
                    structure_data_to_string(*Node.StructureData.cast(next_data))
                } else if next_id == Node.MODULE {
                    "module"
                } else if next_id == Node.RETRIEVE {
                    "define"
                } else {
                    print_node_error_beginning(nodes, i);
                    println("Unknown define type");
                    exit(1);
                    ""
                };

                define_data.type = define_type;
            } else {
                // TODO: Check to make sure type is valid
            };

            declare name = define_data.name;
            if module_stack.index > 0 {
                declare top_module = whole_8.cast(autobuffer_stack8_peek(&module_stack));
                declare top_module_string = any_16.>0();
                whole_8_to_string(top_module, &top_module_string);

                name = concatenate2_brk_allocate(&top_module_string, name);
            };

            declare previous_type = hashmap_string_get2(define_types, name);
            if !(previous_type == 999) {
                print_node_error_beginning(nodes, i);
                print("Duplicate definition '");
                print(name);
                println("'");
                exit(1);
            };

            hashmap_string_put(&define_module_map, name, whole_8.cast(autobuffer_stack8_peek(&module_stack)));

            if string=(define_type, "module") {
                hashmap_string_put(&module_id_map, name, declared_module_id);
            } else if string=(define_type, "define") {
                declare full_define2 = *AutoBufferStack8.cast(brk_allocate(AutoBufferStack8.size()));
                full_define2.* = autobuffer_stack8_new(24);
                declare full_define = "";

                // TODO: Should remove once the old syntax is gone (Foo.Bar syntax)
                declare override_array = *.cast(0);

                i = i + 1;
                declare j = 0;
                while |(Nodes.get_id(nodes, i + j) == Node.RETRIEVE, Nodes.get_id(nodes, i + j) == Node.SKIP) {
                    if Nodes.get_id(nodes, i + j) == Node.RETRIEVE {
                        declare retrieve_data = #nodes_get_pointer_data(nodes, Node.RetrieveData, i + j);
                        declare retrieve_name = retrieve_data.name;

                        if retrieve_data.has_multiple {
                            override_array = retrieve_name;
                            break;
                        };

                        if string=(retrieve_name, "@current_module") {
                            declare top_module = whole_8.cast(autobuffer_stack8_peek(&module_stack));
                            declare top_module_string = any_16.>0();
                            whole_8_to_string(top_module, &top_module_string);

                            autobuffer_stack8_push(full_define2, copy_string_brk_allocate(&top_module_string));
                            full_define = concatenate2_brk_allocate(full_define, &top_module_string);
                        } else {
                            autobuffer_stack8_push(full_define2, copy_string_brk_allocate(retrieve_name));
                            full_define = concatenate3_brk_allocate(full_define, retrieve_name, ".");
                        };
                    };

                    j = j + 1;
                };

                if !(override_array == 0) {
                    hashmap_string_put(&module_references_map, name, override_array);
                } else {
                    full_define = substring_brk_allocate(full_define, 0, string_length(full_define) - 1);
                    hashmap_string_put(&module_references_map, name, full_define2.autobuffer.buffer);
                };
            };

            define_name = get_define_name_with_module(&module_stack, define_name);
            define_data.name = define_name;

            declare define_value = if string_length=(define_type, "*function", 9) {
                declared_function_id
            } else if string_length=(define_type, "structure", 9) {
                declared_structure_id
            } else if string_length=(define_type, "global", 6) {
                declared_global_id
            } else if string_length=(define_type, "module", 6) {
                declared_module_id
            } else {
                #nodes_get_pointer_data(nodes, Node.NumberData, i + 1).value
            };

            autobuffer_stack8_push(&define_types_stack, define_type);

            hashmap_string_put(define_types, define_name, define_type);
            hashmap_string_put(define_values, define_name, define_value);
            hashmap_string_put(define_or_declares, define_name, "define");
        } else if id == Node.ENDDEFINE {
            declare _ = autobuffer_stack8_pop(&define_types_stack);
        } else if id == Node.RETRIEVE {
            declare retrieve_data = *Node.RetrieveData.cast(pointer_data);
            declare coersion = retrieve_data.coercion;

            if !(coersion == NULL) {
                declare coersion_string = expand_type_array(coersion, &module_stack);
                retrieve_data.coercion = create_size_one_array8_brk_allocate(coersion_string);
            };
        } else if id == Node.DECLARE {
            declare declare_data = *Node.DeclareData.cast(pointer_data);
            declare declare_name = declare_data.name;
            declare declare_type = declare_data.type;

            if !in_function {
                declare_type = expand_module_name_array(declare_type, 0, &module_id_map, &module_references_map, &module_stack, create_previous_results_list());
                declare_name = get_define_name_with_module(&module_stack, declare_name);
                declare_data.name = declare_name;

                hashmap_string_put(define_types, declare_name, declare_type);
                hashmap_string_put(define_values, declare_name, declared_global_id);
                hashmap_string_put(define_or_declares, declare_name, "declare");
                autobuffer_array8_set(global_types, declared_global_id, declare_type);

                declared_global_id = declared_global_id + 1;
            } else {
                if array8_length(declare_type) > 0 {
                    declare type_string = expand_type_array(declare_type, &module_stack);
                    declare_data.type = create_size_one_array8_brk_allocate(type_string);
                };
            };
        };

        i = i + 1;
    };
};

define expand_type_array = function(type: *, module_stack: *AutoBufferStack8): * {
    declare type_first = *.cast(array8_get(type, 0));
    return if string_length=(type_first, "*function[", 10) {
        declare function_data = string_to_function_data(type_first);
        expand_function_data(&function_data, module_stack);
        function_data_to_string(module_stack, &function_data)
    } else if string_length=(type_first, "**function[", 11) {
        declare function_data = string_to_function_data(type_first + 1);
        expand_function_data(&function_data, module_stack);
        function_data_to_string(module_stack, &function_data)
    } else {
        expand_module_name_array(type, 0, &module_id_map, &module_references_map, module_stack, create_previous_results_list())
    };
};

define expand_function_data = function(function_data: *Node.FunctionData, module_stack: *AutoBufferStack8) {
    declare j = 0;
    declare argument_types = function_data.argument_types;
    declare return_types = function_data.return_types;
    declare length = array8_length(argument_types);
    while j < length {
        declare argument = *.cast(array8_get(argument_types, j));
        declare expanded_argument = expand_type_array(argument, module_stack);
        array8_set(argument_types, j, create_size_one_array8_brk_allocate(expanded_argument));
        j = j + 1;
    };

    declare j = 0;
    declare length = array8_length(return_types);
    while j < length {
        declare return_ = *.cast(array8_get(return_types, j));
        declare expanded_return = expand_type_array(return_, module_stack);
        array8_set(return_types, j, create_size_one_array8_brk_allocate(expanded_return));
        j = j + 1;
    };
};

define expand_structure_data = function(structure_data: *Node.StructureData, module_stack: *AutoBufferStack8) {
    declare j = 0;
    declare item_types = structure_data.item_types;
    declare length = array8_length(item_types);
    while j < length {
        declare item = *.cast(array8_get(item_types, j));
        declare expanded_item = expand_type_array(item, module_stack);
        array8_set(item_types, j, create_size_one_array8_brk_allocate(expanded_item));
        j = j + 1;
    };
};

define expand_module_name = function(name_in: *, module_id_map: *HashMap, module_references_map: *HashMap, module_stack: *AutoBufferStack8, previous_results_list: *AutoBufferStack8): * {
    declare name = name_in;
    declare array = autobuffer_new(32);
    declare array_index = 0;
    declare buffer = autobuffer_buffer_new(64);

    declare i = 0;
    while i < string_length(name) {
        declare character = *any_1.cast(name + i).*;

        if character == ASCII.PERIOD {
            autobuffer_array8_set(&array, array_index, copy_string_brk_allocate(buffer.autobuffer.buffer));
            array_index = array_index + 1;
            autobuffer_buffer_reset(&buffer);
        } else {
            autobuffer_buffer_push_any_1(&buffer, character);
        };

        i = i + 1;
    };

    if string_length(buffer.autobuffer.buffer) > 0 {
        autobuffer_array8_set(&array, array_index, buffer.autobuffer.buffer);
        array_index = array_index + 1;
    };

    return expand_module_name_array(array.buffer, 0, module_id_map, module_references_map, module_stack, previous_results_list);
};

define create_previous_results_list = function(): *AutoBufferStack8 {
    declare new = autobuffer_stack8_new(32);
    declare allocated = *AutoBufferStack8.cast(brk_allocate(AutoBufferStack8.size()));
    allocated.* = new;
    return allocated;
};

define is_pointer = function(nodes: *Nodes.Data, index_in: whole_8): boolean {
    declare index = index_in;
    while true {
        declare id = Nodes.get_id(nodes, index);
        if id == Node.INVOKE_INTERNAL {
            declare invoke_data = #nodes_get_pointer_data(nodes, Node.InvokeInternalData, index);
            declare name = invoke_data.name;
            return string=(name, "&");
        } else if id == Node.SKIP {
            
        } else {
            break;
        };

        index = index + 1;
    };
    return false;
};


define get_define_name_with_module = function(module_stack: *AutoBufferStack8, define_name: *): * {
    declare new_define_name = "";

    if module_stack.index > 0 {
        declare module_id = whole_8.cast(autobuffer_stack8_peek(module_stack));
        declare module_id_buffer = any_24.>0();
        whole_8_to_string(module_id, &module_id_buffer);

        new_define_name = copy_string_brk_allocate(&module_id_buffer);
    };

    return concatenate2_brk_allocate(new_define_name, define_name);
};
