// TODO: Currently using a define to define a type as another will result in two equal types, I would prefer them to be unique, but is that really a good idea?
define is_type = function(wanted: *, given: *, nodes: *Nodes, program_data: *ProgramData): boolean {
    if string=(wanted, given) {
        return true;
    };

    if string=(wanted, "") {
        return true;
    };

    if string_length=(wanted, "*", 1) {
        if string_length=(given, "*", 1) {
            return is_type(+(wanted, 1), +(given, 1), nodes, program_data);
        };
    };

    if string_length=(wanted, "any_", 4) {
        declare size = string_to_whole_8(*.cast(+(wanted, 4)));
        declare size_function = ProgramData.>get_size(program_data);
        return =(size, size_function(given, nodes, program_data));
    };

    return false;
};

define is_signed = function(type: *, nodes: *Nodes): whole_8 {
    declare cached_signedness = whole_8.cast(hashmap_string_get2(&(cached_signedness_map), type));
    if !(=(cached_signedness, 999)) {
        return cached_signedness;
    };

    if string_length=(type, "*", 1) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };

    if string_length=(type, "whole_", 6) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "any_", 4) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "integer_", 8) {
        hashmap_string_put(&(cached_signedness_map), type, 1);
        return 1;
    };

    declare node_count = Nodes.>index(nodes);
    declare i = 0;
    while <(i, node_count) {
        if =(nodes_get_id(nodes, i), NODE_STRUCTURE) {
            declare pointer = NodeStructureData.*cast(nodes_get_pointer_data(nodes, i));
            declare name = NodeStructureData.>name(pointer);

            if !(=(name, 0)) {
                declare member_types = NodeStructureData.>item_types(pointer);
                if string=(type, name) {
                    declare is_signed2 = is_signed(*.cast(array8_get(member_types, 0)), nodes);
                    hashmap_string_put(&(cached_signedness_map), type, is_signed2);
                    return is_signed2;
                };
            };
        };
        i = +(i, 1);
    };

    hashmap_string_put(&(cached_signedness_map), type, 0);
    return 0;
};

define print_node_error_beginning = function(nodes: *Nodes, location: whole_8) {
    declare location_data = nodes_get_location_data(nodes, location);
    print("[ERROR] ");
    print(NodeLocationData.>file(location_data));
    print(":");
    print_whole_8(NodeLocationData.>row(location_data));
    print(":");
    print_whole_8(NodeLocationData.>column(location_data));
    print(": ");
};

define ProgramData = structure {
    define_types: HashMap;
    define_values: HashMap;
    structure_datas: AutoBufferStack8;
    structure_member_types: AutoBuffer;
    structure_member_names: AutoBuffer;
    function_datas: AutoBuffer;
    function_locations: AutoBuffer;
    function_argument_types: AutoBuffer;
    function_argument_names: AutoBuffer;
    function_return_types: AutoBuffer;
    internal_function_argument_types: HashMap;
    internal_function_argument_names: HashMap;
    internal_function_return_types: HashMap;
    global_types: AutoBuffer;

    // possible should be in a separate structure
    get_size: *function[*,*Nodes,*ProgramData:whole_8];
};

define module_stack = global(AutoBufferStack8);

define process = function(nodes: *Nodes, size_function: *function[*,*Nodes,*ProgramData:whole_8]): ProgramData {
    declare node_count = Nodes.>index(nodes);

    module_stack = autobuffer_stack8_new(32);

    declare program_data = ProgramData.>0();

    ProgramData.<internal_function_argument_types(&(program_data), hashmap_new(1024));
    ProgramData.<internal_function_argument_names(&(program_data), hashmap_new(1024));
    ProgramData.<internal_function_return_types(&(program_data), hashmap_new(1024));

    ProgramData.<define_types(&(program_data), hashmap_new(512));
    ProgramData.<define_values(&(program_data), hashmap_new(512));

    ProgramData.<function_locations(&(program_data), autobuffer_new(1024));
    ProgramData.<function_datas(&(program_data), autobuffer_new(1024));
    ProgramData.<function_argument_types(&(program_data), autobuffer_new(1024));
    ProgramData.<function_argument_names(&(program_data), autobuffer_new(1024));
    ProgramData.<function_return_types(&(program_data), autobuffer_new(1024));

    ProgramData.<structure_datas(&(program_data), autobuffer_stack8_new(1024));
    ProgramData.<structure_member_types(&(program_data), autobuffer_new(1024));
    ProgramData.<structure_member_names(&(program_data), autobuffer_new(1024));

    ProgramData.<global_types(&(program_data), autobuffer_new(512));

    ProgramData.<get_size(&(program_data), size_function);

    setup_process(nodes, &(program_data));

    declare current_function_id = 0;

    declare variable_scopes_types_map = autobuffer_new(64);
    declare variable_scope_types_pointer = 0;
    declare variable_scopes_declares_map = autobuffer_new(64);
    declare variable_scope_declares_pointer = 0;

    declare stack = autobuffer_new(64);
    declare stack_pointer = 0;

    declare if_blocks = autobuffer_new(64);
    declare if_block_pointer = 0;
    declare if_block_results = autobuffer_new(64);

    declare function_id = 0;

    declare has_main = false;
    declare declared_function_id = 0;
    declare declared_module_id = 0;

    declare declared_function_id = 0;
    declare declared_module_id = 0;

    declare in_function = false;

    declare i = 0;
    while <(i, node_count) {
        declare id = nodes_get_id(nodes, i);
        declare pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            declare function_name = NodeFunctionData.>name(NodeFunctionData.*cast(pointer_data));

            if =(function_name, 0) {
                current_function_id = function_id;
                function_id = +(function_id, 1);
            };
            in_function = true;

            stack_pointer = 0;
        } else if =(id, NODE_NUMBER) {
            process_number(&(stack), &(stack_pointer), pointer_data);
        } else if =(id, NODE_BOOLEAN) {
            autobuffer_stack8_legacy_push(&(stack), &(stack_pointer), "boolean");
        } else if =(id, NODE_STRING) {
            autobuffer_stack8_legacy_push(&(stack), &(stack_pointer), "*");
        } else if =(id, NODE_INVOKE) {
            process_invoke(nodes, i, &(stack), &(stack_pointer), &(program_data), pointer_data);
        } else if =(id, NODE_INVOKE_INTERNAL) {
            process_invoke_internal(nodes, i, &(stack), &(stack_pointer), &(program_data), pointer_data);
        } else if =(id, NODE_DECLARE) {
            declare declare_data = NodeDeclareData.*cast(pointer_data);
            declare variable_name = NodeDeclareData.>name(declare_data);
            declare variable_type_names = NodeDeclareData.>type(declare_data);

            hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), -(variable_scope_types_pointer, 1))), variable_name, variable_type_names);
            hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_declares_map), -(variable_scope_declares_pointer, 1))), variable_name, i);
        } else if =(id, NODE_ASSIGN) {
            process_assign(nodes, i, &(stack), &(stack_pointer), &(program_data), variable_scopes_types_map, variable_scope_types_pointer, variable_scopes_declares_map, pointer_data);
        } else if =(id, NODE_RETRIEVE) {
            if in_function {
                process_retrieve(nodes, i, &(stack), &(stack_pointer), variable_scopes_types_map, variable_scope_types_pointer, &(program_data), current_function_id);
            };
        } else if =(id, NODE_RETURN) {
            process_return(nodes, i, &(stack), &(stack_pointer), &(program_data), current_function_id);
        } else if =(id, NODE_JUMP_CONDITIONAL) {
            process_jump_conditional(nodes, i, &(program_data), &(stack), &(stack_pointer));
        } else if =(id, NODE_SCOPE) {
            declare new_hashmap = hashmap_new(512);
            declare allocated = brk_allocate(24);
            HashMap.<(HashMap.*cast(allocated), new_hashmap);
            autobuffer_stack8_legacy_push(&(variable_scopes_types_map), &(variable_scope_types_pointer), allocated);

            declare new_hashmap = hashmap_new(512);
            declare allocated = brk_allocate(24);
            HashMap.<(HashMap.*cast(allocated), new_hashmap);
            autobuffer_stack8_legacy_push(&(variable_scopes_declares_map), &(variable_scope_declares_pointer), allocated);
        } else if =(id, NODE_ENDSCOPE) {
            declare _ = autobuffer_stack8_legacy_pop(&(variable_scopes_types_map), &(variable_scope_types_pointer));
            declare _ = autobuffer_stack8_legacy_pop(&(variable_scopes_declares_map), &(variable_scope_declares_pointer));
        } else if =(id, NODE_STARTIFBLOCK) {
            autobuffer_stack8_legacy_push(&(if_blocks), &(if_block_pointer), stack_pointer);
        } else if =(id, NODE_ENDIFBLOCK) {
            process_end_if(nodes, i, &(stack), &(stack_pointer), &(if_blocks), &(if_block_results), &(if_block_pointer), pointer_data, &(program_data));
        } else if =(id, NODE_DEFINE) {
            declare define_node_data = NodeDefineData.*cast(pointer_data);
            if string=(NodeDefineData.>name(define_node_data), "main") {
                has_main = true;
            };
        } else if =(id, NODE_ENDDEFINE) {
        } else if =(id, NODE_MODULE) {
            autobuffer_stack8_push(&(module_stack), declared_module_id);
            declared_module_id = +(declared_module_id, 1);
        } else if =(id, NODE_ENDMODULE) {
            declare _ = autobuffer_stack8_pop(&(module_stack));
        } else if =(id, NODE_JUMP) {
        } else if =(id, NODE_TARGET) {
        } else if =(id, NODE_ENDFUNCTION) {
            in_function = false;
        } else if =(id, NODE_STRUCTURE) {
        } else if =(id, NODE_GLOBAL) {
        } else if =(id, NODE_SKIP) {
        } else if =(id, NODE_ENDSTATEMENT) {
            if !(=(stack_pointer, 0)) {
                print_node_error_beginning(nodes, i);
                println("Statement end has extra stack values");
                while !(=(stack_pointer, 0)) {
                    println(*.cast(autobuffer_stack8_legacy_pop(&(stack), &(stack_pointer))));
                };
                exit(1);

            };
        } else {
            print("Unhandled ");
            print_whole_8(id);
            println("");
        };

        i = +(i, 1);
    };
    
    if !(has_main) {
        println("[ERROR] No 'main' function defined");
        exit(1);
    };

    return program_data;
};

define is_define = function(type: *): boolean {
    if string_length=(type, "any_", 4) {
        return false;
    };
    if string_length=(type, "whole_", 6) {
        return false;
    };
    if string_length=(type, "integer_", 8) {
        return false;
    };
    if string_length=(type, "boolean", 6) {
        return false;
    };
    if string_length=(type, "*function[", 10) {
        return false;
    };
    if string=(type, "*") {
        return false;
    };
    return true;
};

define process_number = function(stack: *AutoBuffer, stack_pointer: *whole_8, pointer_data: *) {
    declare number_data = NodeNumberData.*cast(pointer_data);

    declare coersion = NodeNumberData.>coersion(number_data);
    if =(coersion, 0) {
        coersion = "whole_8";
    } else {
        coersion = expand_module_name_array(coersion, 0, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list());
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, coersion);
};

define process_jump_conditional = function(nodes: *Nodes, nodes_index: whole_8, program_data: *ProgramData, stack: *AutoBuffer, stack_pointer: *whole_8) {
    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        println("Conditional jump ran out of stack values");
        exit(1);
    };

    declare popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    if !(is_type(popped, "boolean", nodes, program_data)) {
        print_node_error_beginning(nodes, nodes_index);
        print("Conditional Jump (if/while) wants 'boolean', given '");
        print(popped);
        println("'");
        exit(1);
    };
};

define process_return = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, current_function_id: whole_8) {
    declare function_return_types = &(ProgramData.>function_return_types(program_data));
    declare function_return_types_specific = *.cast(autobuffer_array8_get(function_return_types, current_function_id));

    declare temp = array8_length(function_return_types_specific);
    declare j = -(temp, 1);
    while <(j, temp) {
        declare function_return = *.cast(array8_get(function_return_types_specific, j));

        if =(whole_8.>(stack_pointer), 0) {
            print_node_error_beginning(nodes, nodes_index);
            println("Return ran out of stack values");
            exit(1);
        };

        declare stack_popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
        
        if !(is_type(function_return, stack_popped, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Return wants '");
            print(function_return);
            print("', given '");
            print(stack_popped);
            println("'");
            exit(1);
        };

        j = -(j, 1);
    };

    if !(=(whole_8.>(stack_pointer), 0)) {
        print_node_error_beginning(nodes, nodes_index);
        println("Return has extra stack values");
        exit(1);
    };
};

define process_end_if = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, if_blocks: *AutoBuffer, if_block_results: *AutoBuffer, if_block_pointer: *whole_8, pointer_data: *, program_data: *ProgramData) {
    declare end_if_data = NodeEndIfBlockData.*cast(pointer_data);
    declare end_if_id = NodeEndIfBlockData.>id(end_if_data);
    declare is_last = NodeEndIfBlockData.>is_last(end_if_data);
    declare is_bare_else = NodeEndIfBlockData.>is_bare_else(end_if_data);

    declare start_stack = whole_8.cast(autobuffer_stack8_legacy_pop(if_blocks, if_block_pointer));
    declare previous_results = *.cast(autobuffer_array8_get(if_block_results, end_if_id));

    declare size = *(8, -(whole_8.>(stack_pointer), start_stack));
    if =(previous_results, 0) {
        previous_results = brk_allocate(+(8, size));
        declare array = autobuffer_get_size(stack, *(8, start_stack), size);
        copy(array, previous_results, size);

        autobuffer_array8_set(if_block_results, end_if_id, previous_results);

        if !(is_last) {
            declare j = 0;
            while <(j, /(size, 8)) {
                declare _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);

                j = +(j, 1);
            };
        } else if &&(!(is_bare_else), >(size, 0)) {
            print_node_error_beginning(nodes, nodes_index);
            println("If expression resulting in a value requires an 'else' condition");
            exit(1);
        };
    } else {
        declare array = autobuffer_get_size(stack, *(8, start_stack), size);
        declare previous_array = previous_results;

        declare max_size = size;
        if >(*(array8_length(previous_array), 8), size) {
            size = *(array8_length(previous_array), 8);
        };

        declare j = 0;
        while <(j, /(size, 8)) {
            declare previous_value = *.cast(array8_get(previous_array, j));
            declare value = *.cast(array8_get(array, j));

            declare error = false;

            if =(value, 0) {
                error = true;
            } else if =(previous_value, 0) {
                error = true;
            } else if !(is_type(value, previous_value, nodes, program_data)) {
                error = true;
            } else {
                if !(is_last) {
                    declare _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);
                };
            };

            if error {
                print_node_error_beginning(nodes, nodes_index);
                print("If does not have matching branch results (");
                print(value);
                print(", ");
                print(previous_value);
                println(")");
                exit(1);
            };

            j = +(j, 1);
        };
    };
};

define process_assign = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, variable_scopes_declares_map: AutoBuffer, pointer_data: *) {
    declare assign_data = NodeAssignData.*cast(pointer_data);
    declare variable_name = NodeAssignData.>name(assign_data);

    declare scope_index, variable_type = get_variable_info(variable_scopes_types_map, variable_scope_types_pointer, variable_name);

    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        println("Assign ran out of stack values");
        exit(1);
    };

    declare popped_stack = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if !(=(variable_type, 0)) {
        if string=(variable_type, "") {
            variable_type = create_size_one_array8_brk_allocate(popped_stack);

            hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name, variable_type);

            declare variable_declare_node_index = hashmap_string_get(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_declares_map), scope_index)), variable_name);
            declare variable_declare_node = NodeDeclareData.*cast(nodes_get_pointer_data(nodes, whole_8.cast(variable_declare_node_index)));
            NodeDeclareData.<type(variable_declare_node, variable_type);
        };

        variable_type = expand_module_name_array(variable_type, 0, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list());
        if !(is_type(variable_type, popped_stack, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Assign of ");
            print(variable_name);
            print(" wants '");
            print(variable_type);
            print("', given '");
            print(popped_stack);
            println("'");
            exit(1);
        };
        return;
    };

    declare define_values = &(ProgramData.>define_values(program_data));

    declare global_id = whole_8.cast(hashmap_string_get2(define_values, variable_name));
    if !(=(global_id, 999)) {
        declare global_types = &(ProgramData.>global_types(program_data));
        variable_type = *.cast(autobuffer_array8_get(global_types, global_id));
    };

    if !(=(variable_type, 0)) {
        if !(is_type(variable_type, popped_stack, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Assign of ");
            print(variable_name);
            print(" wants '");
            print(variable_type);
            print("', given '");
            print(popped_stack);
            println("'");
            exit(1);
        };
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Assign target '");
        print(variable_name);
        println("' not found");
        exit(1);
    };
};

define get_variable_info = function(variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, variable_name: *): whole_8, * {
    declare scope_index = -(variable_scope_types_pointer, 1);
    declare variable_type = *.cast(0);
    while &&(=(variable_type, 0), <(scope_index, variable_scope_types_pointer)) {
        variable_type = *.cast(hashmap_string_get(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name));
        scope_index = -(scope_index, 1);
    };
    scope_index = +(scope_index, 1);

    return scope_index, variable_type;
};

define process_invoke_pointer = function(nodes: *Nodes, nodes_index: whole_8,  stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, pointer_data: *) {
    declare function_type = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if !(string_length=(function_type, "*function[", 10)) {
        declare define_types = &(ProgramData.>define_types(program_data));
        declare define_values = &(ProgramData.>define_values(program_data));
        function_type = get_define_retrieve_type(define_types, define_values, function_type);
    };

    if string_length=(function_type, "*function[", 10) {
        declare arguments_buffer, returns_buffer = get_arguments_from_function_type(function_type);

        declare k = integer_8.cast(array8_length(arguments_buffer));
        while >(k, 0:integer_8) {
            k = -(k, 1:integer_8);

            if =(whole_8.>(stack_pointer), 0) {
                print_node_error_beginning(nodes, nodes_index);
                print("Invoke of '");
                if =(nodes_get_id(nodes, -(nodes_index, 1)), NODE_RETRIEVE) {
                    declare previous_node_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(nodes_index, 1)));
                    //print(expand_module_name_array(NodeRetrieveData.>names(previous_node_data), 0, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list()));
                } else {
                    print("unknown");
                };
                println("' ran out of stack values");
                exit(1);
            };

            declare given = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
            declare wanted = *.cast(array8_get(arguments_buffer, whole_8.cast(k)));

            if !(is_type(wanted, given, nodes, program_data)) {
                print_node_error_beginning(nodes, nodes_index);
                print("Invoke of '");

                if =(nodes_get_id(nodes, -(nodes_index, 1)), NODE_RETRIEVE) {
                    declare previous_node_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(nodes_index, 1)));
                    print(expand_module_name_array(NodeRetrieveData.>name(previous_node_data), 0, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list()));
                } else {
                    print("unknown");
                };

                print("' wants '");
                print(wanted);
                print("', given '");
                print(given);
                println("'");
                exit(1);
            };
        };

        declare k = 0;
        while <(k, array8_length(returns_buffer)) {
            declare return_ = *.cast(array8_get(returns_buffer, k));

            autobuffer_stack8_legacy_push(stack, stack_pointer, return_);
            k = +(k, 1);
        };
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Attempting to invoke non function pointer '");
        print(function_type);
        println("'");
        exit(1);
    };
};

define get_arguments_from_function_type = function(function_type: *): *, * {
    declare arguments_buffer = autobuffer_new(64);
    declare arguments_buffer_index = 0;

    declare current_buffer = autobuffer_buffer_new(64);

    declare inner = 0;
    declare j = 10;
    while |(!(=(whole_1.>(whole_1.*cast(+(function_type, j))), ASCII.COLON)), >(inner, 0)) {
        declare character = whole_1.>(whole_1.*cast(+(function_type, j)));
        if &&(|(=(character, ASCII.CLOSED_BRACKET), =(character, ASCII.COMMA)), =(inner, 0)) {
            autobuffer_array8_set(&(arguments_buffer), arguments_buffer_index, copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(current_buffer))));
            arguments_buffer_index = +(arguments_buffer_index, 1);

            current_buffer = autobuffer_buffer_new(64);
        } else {
            autobuffer_buffer_push_whole_1(&(current_buffer), character);
        };

        if =(character, ASCII.OPEN_BRACKET) {
            inner = +(inner, 1);
        } else if =(character, ASCII.CLOSED_BRACKET) {
            inner = -(inner, 1);
        };
        j = +(j, 1);
    };
    if >(AutoBufferBuffer.>index(&(current_buffer)), 0) {
        autobuffer_array8_set(&(arguments_buffer), arguments_buffer_index, copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(current_buffer))));
    };

    declare returns_buffer = autobuffer_new(64);
    declare returns_buffer_index = 0;

    declare inner = 0;
    current_buffer = autobuffer_buffer_new(64);

    j = +(j, 1);

    while |(!(=(whole_1.>(whole_1.*cast(+(function_type, j))), ASCII.CLOSED_BRACKET)), >(inner, 0)) {
        declare character = whole_1.>(whole_1.*cast(+(function_type, j)));
        if &&(|(=(character, ASCII.COLON), =(character, ASCII.COMMA)), =(inner, 0)) {
            declare return_ = autobuffer_buffer_get_buffer_pointer(&(current_buffer));

            autobuffer_array8_set(&(returns_buffer), returns_buffer_index, copy_string_brk_allocate(return_));
            returns_buffer_index = +(returns_buffer_index, 1);

            current_buffer = autobuffer_buffer_new(64);
        } else {
            autobuffer_buffer_push_whole_1(&(current_buffer), character);
        };

        if =(character, ASCII.OPEN_BRACKET) {
            inner = +(inner, 1);
        } else if =(character, ASCII.CLOSED_BRACKET) {
            inner = -(inner, 1);
        };
        j = +(j, 1);
    };

    if >(AutoBufferBuffer.>index(&(current_buffer)), 0) {
        autobuffer_array8_set(&(returns_buffer), returns_buffer_index, copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(current_buffer))));
    };

    return AutoBuffer.>buffer(&(arguments_buffer)), AutoBuffer.>buffer(&(returns_buffer));
};

define get_define_type = function(define_types: *HashMap, define_values: *HashMap, define_name: *): * {
    declare define_type = *.cast(hashmap_string_get(define_types, define_name));
    declare define_value = *.cast(hashmap_string_get(define_values, define_name));
    if =(define_type, 0) {

    } else if string_length=(define_type, "structure[", 10) {
        define_type = define_name;
    };
    return define_type;

};

define get_define_retrieve_type = function(define_types: *HashMap, define_values: *HashMap, define_name: *): * {
    declare define_type = get_define_type(define_types, define_values, define_name);
    if =(define_type, 0) {

    } else if string_length=(define_type, "global[", 7) {
        define_type = substring_brk_allocate(define_type, 7, -(length(define_type), 1));
    };

    return define_type;
};

define get_value_of_define = function(define_types: *HashMap, define_values: *HashMap, define_name: *): any_8 {
    return *.cast(hashmap_string_get2(define_values, define_name));
};

define process_retrieve = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, program_data: *ProgramData, current_function_id: whole_8) {
    declare retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, nodes_index));
    declare variable_name_array = NodeRetrieveData.>name(retrieve_data);
    declare simple_variable_name = *.cast(array8_get(variable_name_array, 0));
    declare coercion = NodeRetrieveData.>coercion(retrieve_data);

    declare variable_type = *.cast(0);

    declare scope_index, variable_type = get_variable_info(variable_scopes_types_map, variable_scope_types_pointer, simple_variable_name);

    if !(=(variable_type, 0)) {
        variable_type = expand_module_name_array(variable_type, 0, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list());
        if is_pointer(nodes, +(nodes_index, 1)) {
            variable_type = concatenate2_brk_allocate("*", variable_type);
        };
        autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
        return;
    };

    declare function_argument_types = &(ProgramData.>function_argument_types(program_data));
    declare function_argument_names = &(ProgramData.>function_argument_names(program_data));

    declare function_argument_names_specific = *.cast(autobuffer_array8_get(function_argument_names, current_function_id));
    declare function_argument_types_specific = *.cast(autobuffer_array8_get(function_argument_types, current_function_id));

    variable_type = stringarray_get(function_argument_names_specific, function_argument_types_specific, simple_variable_name, array8_length(function_argument_types_specific));
    if !(=(variable_type, 0)) {
        variable_type = expand_module_name_array(variable_type, 0, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list());
        if is_pointer(nodes, +(nodes_index, 1)) {
            variable_type = concatenate2_brk_allocate("*", variable_type);
        };
        autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
        return;
    };

    declare define_types = &(ProgramData.>define_types(program_data));
    declare define_values = &(ProgramData.>define_values(program_data));

    declare define_types = &(ProgramData.>define_types(program_data));

    declare module_expanded_name = expand_module_name_array(variable_name_array, 0, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list());
    variable_type = get_define_retrieve_type(define_types, define_values, module_expanded_name);
    if !(=(coercion, 0)) {
        variable_type = coercion;
    };

    if !(=(variable_type, 0)) {
        if string=(variable_type, "define") {
            declare value = *.cast(get_value_of_define(define_types, define_values, module_expanded_name));
            declare i = 0;
            while <(i, array8_length(value)) {
                i = +(i, 1);
            };

            declare value2 = *.cast(array8_get(value, 0));
        };
    };

    if is_pointer(nodes, +(nodes_index, 1)) {
        variable_type = concatenate2_brk_allocate("*", variable_type);
    };

    if !(=(variable_type, 0)) {
        if string=(variable_type, "module") {
            print_node_error_beginning(nodes, nodes_index);
            println("Cannot retrieve a module");
            exit(1);
        };
    };

    if !(=(variable_type, 0)) {
        autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
    } else if string_length=(simple_variable_name, "any_", 4) {
        autobuffer_stack8_legacy_push(stack, stack_pointer, simple_variable_name);
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Retrieve target '");
        print(module_expanded_name);
        println("' not found");
        exit(1);
    };
};

define process_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, pointer_data: *) {
    process_invoke_pointer(nodes, nodes_index, stack, stack_pointer, program_data, pointer_data);
};

define process_invoke_internal = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, pointer_data: *) {
    declare invoke_data = NodeInvokeInternalData.*cast(nodes_get_pointer_data(nodes, nodes_index));
    declare name_array = NodeInvokeInternalData.>name(invoke_data);
    declare is_single = =(array8_length(name_array), 1);
    declare function_name = *.cast(array8_get(name_array, -(array8_length(name_array), 1)));

    if &&(is_single, string=(function_name, "+")) {
        function_name = process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "+");
    } else if &&(is_single, string=(function_name, "-")) {
        function_name = process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "-");
    } else if &&(is_single, string=(function_name, "*")) {
        function_name = process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "*");
    } else if &&(is_single, string=(function_name, "/")) {
        function_name = process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "/");
    } else if &&(is_single, string=(function_name, "%")) {
        function_name = process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "%");
    } else if &&(is_single, string=(function_name, "=")) {
        function_name = process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "=");
    } else if &&(is_single, string=(function_name, ">")) {
        function_name = process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, ">");
    } else if &&(is_single, string=(function_name, "<")) {
        function_name = process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, "<");
    } else if |(string=(function_name, "cast"), string=(function_name, "*cast")) {
        process_cast(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, function_name);
    } else if &&(is_single, string=(function_name, "&")) {
    } else {
        if is_pointer(nodes, +(nodes_index, 1)) {
            function_name = concatenate2_brk_allocate("*", function_name);
        };
        function_name = if >(array8_length(NodeInvokeInternalData.>name(invoke_data)), 1) {
            declare function_name_new = expand_module_name_array(NodeInvokeInternalData.>name(invoke_data), 1, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list());
            concatenate2_brk_allocate(function_name_new, function_name)
        } else {
            function_name
        };
        process_internal_invoke(nodes, nodes_index, stack, stack_pointer, program_data, function_name);
    };

    array8_set(NodeInvokeInternalData.>name(invoke_data), 0, function_name);
};

define expand_module_name_array = function(name_array: *, resolvable_end: whole_8, module_id_map: *HashMap, module_references_map: *HashMap, module_stack: *AutoBufferStack8, previous_results_list: *AutoBufferStack8): * {
    declare name = *.cast(array8_get(name_array, 0));
    declare pointer_count = 0;
    while &&(=(any_1.>(any_1.*cast(+(name, pointer_count))), ASCII.ASTERISK), <(pointer_count, length(name))) {
         pointer_count = +(pointer_count, 1);
    };

    // TODO: lol
    name = *.cast(array8_get(name_array, -(array8_length(name_array), 1)));

    declare current_module_id = 999;
    declare i = 0;
    declare is_first = true;
    while <(i, -(-(array8_length(name_array), resolvable_end), 1)) {
        declare current_module = *.cast(array8_get(name_array, i));
        if is_first {
            current_module = +(current_module, pointer_count);
        };
        is_first = false;

        declare new_id = if string=(current_module, "@current_module") {
            whole_8.cast(autobuffer_stack8_peek(module_stack))
        } else if =(current_module_id, 999) {
            declare temp_id = whole_8.cast(hashmap_string_get2(module_id_map, current_module));

            if =(temp_id, 999) {
                declare temp_name = *.cast(hashmap_string_get2(module_references_map, current_module));
                temp_name = expand_module_name(temp_name, module_id_map, module_references_map, module_stack, create_previous_results_list());
                temp_id = whole_8.cast(hashmap_string_get2(module_id_map, temp_name));
            };
            temp_id
        } else {
            declare current_module_id_string = any_16.>0();
            whole_8_to_string(current_module_id, &(current_module_id_string));

            declare current_module_full = concatenate2_brk_allocate(&(current_module_id_string), current_module);
            declare temp_id = whole_8.cast(hashmap_string_get2(module_id_map, current_module_full));

            if =(temp_id, 999) {
                declare temp_name = *.cast(hashmap_string_get2(module_references_map, current_module_full));
                if =(temp_name, 999) {
                    return name;
                };

                temp_name = expand_module_name(temp_name, module_id_map, module_references_map, module_stack, create_previous_results_list());
                temp_id = whole_8.cast(hashmap_string_get2(module_id_map, temp_name));
            };
            temp_id
        };

        current_module_id = new_id;
        i = +(i, 1);
    };

    if !(=(current_module_id, 999)) {
        declare current_module_id_string = any_16.>0();
        whole_8_to_string(current_module_id, &(current_module_id_string));
        name = concatenate2_brk_allocate(&(current_module_id_string), *.cast(array8_get(name_array, -(-(array8_length(name_array), resolvable_end), 1))));
    } else {
        name = *.cast(array8_get(name_array, -(-(array8_length(name_array), resolvable_end), 1)));
    };

    declare possible_reference = *.cast(hashmap_string_get2(module_references_map, name));
    if !(=(possible_reference, 999)) {
        declare i = 0;
        while <(i, AutoBufferStack8.>index(previous_results_list)) {
            if string=(*.cast(autobuffer_stack8_get(previous_results_list, i)), name) {
                return name;
            };
            i = +(i, 1);
        };
        autobuffer_stack8_push(previous_results_list, name);

        name = expand_module_name(possible_reference, module_id_map, module_references_map, module_stack, previous_results_list);
    };

    if !(is_first) {
        declare i = 0;
        while <(i, pointer_count) {
            name = concatenate2_brk_allocate("*", name);
            i = +(i, 1);
        };
    };

    return name;
};

define print_array8_string = function(array: *) {
    print("[");
    declare i = 0;
    while <(i, array8_length(array)) {
        print(*.cast(array8_get(array, i)));
        print(", ");
        i = +(i, 1);
    };
    println("]");
};

define process_cast = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, invoke_data: *NodeInvokeInternalData, function_name: *) {
    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        println("Cast ran out of stack values");
        exit(1);
    };

    declare to_push = expand_module_name_array(NodeInvokeInternalData.>name(invoke_data), 1, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list());

    if string=(function_name, "*cast") {
        to_push = concatenate2_brk_allocate("*", to_push);
    };

    declare popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    declare size_function = ProgramData.>get_size(program_data);
    if !(=(size_function(popped, nodes, program_data), size_function(to_push, nodes, program_data))) {
        print_node_error_beginning(nodes, nodes_index);
        print("Cast wants equal sized types, given '");
        print(popped);
        print("' and casts to '");
        print(to_push);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, to_push);

    nodes_set_skip(nodes, -(nodes_index, 1));
};

define process_internal_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, function_name: *) {
    //declare function_name = NodeInvokeData.>name(invoke_data);
    //declare has_specifier = NodeInvokeData.>has_specifier(invoke_data);
    declare found_function = false;

    //if has_specifier {
    //    declare popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    //    function_name = concatenate2_brk_allocate(popped, function_name);
    //    NodeInvokeData.<name(invoke_data, function_name);
    //    NodeInvokeData.<has_specifier(invoke_data, false);

    //    declare running = true;

    //    declare i = -(nodes_index, 1);
    //    while running {
    //        declare id = nodes_get_id(nodes, i);
    //        declare is_module = NodeRetrieveData.>is_module(NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, i)));
    //        nodes_set_skip(nodes, i);

    //        if =(id, NODE_SKIP) {

    //        } else if =(id, NODE_RETRIEVE) {
    //            if !(is_module) {
    //                running = false;
    //            };
    //        } else {
    //            running = false;
    //        };

    //        i = -(i, 1);
    //    };
    //};

    declare internal_function_argument_types = &(ProgramData.>internal_function_argument_types(program_data));
    declare internal_function_return_types = &(ProgramData.>internal_function_return_types(program_data));

    if =(hashmap_string_get(internal_function_argument_types, function_name), 0) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke target '");
        print(function_name);
        println("' not found");
        exit(1);
    };

    declare arguments = *.cast(hashmap_string_get(internal_function_argument_types, function_name));
    declare returns = *.cast(hashmap_string_get(internal_function_return_types, function_name));

    declare arguments_length = array8_length(arguments);
    declare k = 0;
    while <(k, arguments_length) {
        if =(whole_8.>(stack_pointer), 0) {
            print_node_error_beginning(nodes, nodes_index);
            print("Invoke of '");
            print(function_name);
            println("' ran out of stack values");
            exit(1);
        };

        declare given = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
        declare wanted = *.cast(array8_get(arguments, -(-(arguments_length, k), 1)));
        if !(is_type(wanted, given, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Invoke of '");
            print(function_name);
            print("' wants '");
            print(wanted);
            print("', given '");
            print(given);
            println("'");
            exit(1);
        };

        k = +(k, 1);
    };

    declare k = 0;
    while !(=(array8_get(returns, k), 0)) {
        declare return_value = *.cast(array8_get(returns, k));

        autobuffer_stack8_legacy_push(stack, stack_pointer, return_value);

        k = +(k, 1);
    };
};

define process_math_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, math_name: *): * {
    if <(whole_8.>(stack_pointer), 2) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(math_name);
        println("' ran out of stack values");
        exit(1);
    };

    declare first = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    declare second = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    declare size_function = ProgramData.>get_size(program_data);
    if |(!(=(size_function(first, nodes, program_data), size_function(second, nodes, program_data))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(math_name);
        print("' wants matching arguments, given '");
        print(first);
        print("' and '");
        print(second);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, second);

    declare define_types = &(ProgramData.>define_types(program_data));
    declare define_values = &(ProgramData.>define_values(program_data));

    if is_define(first) {
        first = get_define_retrieve_type(define_types, define_values, first);
    };
    declare new_name = concatenate3_brk_allocate(math_name, "_" first);

    return new_name;
};

define process_comparison_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, comparison_name: *): * {
    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(comparison_name);
        println("' ran out of stack values");
        exit(1);
    };

    declare first = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    declare second = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    declare size_function = ProgramData.>get_size(program_data);
    if |(!(=(size_function(first, nodes, program_data), size_function(second, nodes, program_data))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(comparison_name);
        print("' has incompatable arguments, given '");
        print(first);
        print("' and '");
        print(second);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, "boolean");

    declare define_types = &(ProgramData.>define_types(program_data));
    declare define_values = &(ProgramData.>define_values(program_data));

    if is_define(first) {
        first = get_define_retrieve_type(define_types, define_values, first);
    };
    declare new_name = concatenate3_brk_allocate(comparison_name, "_" first);

    return new_name;
};

define module_id_map = global(HashMap);
define module_references_map = global(HashMap);
define define_module_map = global(HashMap);

define setup_process = function(nodes: *Nodes, program_data: *ProgramData) {
    declare node_count = Nodes.>index(nodes);

    module_stack = autobuffer_stack8_new(24);
    module_id_map = hashmap_new(64);
    module_references_map = hashmap_new(64);
    define_module_map = hashmap_new(64);

    declare define_types = autobuffer_stack8_new(32);

    declare current_module_id = 0;

    declare declared_function_id = 0;
    declare declared_structure_id = 0;
    declare declared_global_id = 0;
    declare declared_module_id = 0;

    declare i = 0;
    while <(i, node_count) {
        declare id = nodes_get_id(nodes, i);
        declare pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            declare function_data = NodeFunctionData.*cast(pointer_data);
            declare function_name = NodeFunctionData.>name(function_data);
            
            if !(=(function_name, 0)) {
                declare internal_function_argument_types = &(ProgramData.>internal_function_argument_types(program_data));
                declare internal_function_argument_names = &(ProgramData.>internal_function_argument_names(program_data));
                declare internal_function_return_types = &(ProgramData.>internal_function_return_types(program_data));

                hashmap_string_put(internal_function_argument_types, function_name, NodeFunctionData.>argument_types(function_data));
                hashmap_string_put(internal_function_argument_names, function_name, NodeFunctionData.>argument_names(function_data));
                hashmap_string_put(internal_function_return_types, function_name, NodeFunctionData.>returns(function_data));
            } else {
                // probably should check for duplicate functions
                declare function_locations = &(ProgramData.>function_locations(program_data));
                declare function_datas = &(ProgramData.>function_datas(program_data));
                declare function_argument_names = &(ProgramData.>function_argument_names(program_data));
                declare function_argument_types = &(ProgramData.>function_argument_types(program_data));
                declare function_return_types = &(ProgramData.>function_return_types(program_data));

                autobuffer_array8_set(function_locations, declared_function_id, i);
                autobuffer_array8_set(function_datas, declared_function_id, function_data);
                autobuffer_array8_set(function_argument_types, declared_function_id, NodeFunctionData.>argument_types_array(function_data));
                autobuffer_array8_set(function_argument_names, declared_function_id, NodeFunctionData.>argument_names(function_data));
                autobuffer_array8_set(function_return_types, declared_function_id, NodeFunctionData.>returns(function_data));
                declared_function_id = +(declared_function_id, 1);
            };
        };

        if =(id, NODE_STRUCTURE) {
            declare structure_data = NodeStructureData.*cast(pointer_data);

            if =(NodeStructureData.>name(structure_data), 0) {
                declare structure_member_types = &(ProgramData.>structure_member_types(program_data));
                declare structure_members_names = &(ProgramData.>structure_member_names(program_data));
                autobuffer_array8_set(structure_member_types, declared_structure_id, NodeStructureData.>item_types(structure_data));
                autobuffer_array8_set(structure_members_names, declared_structure_id, NodeStructureData.>item_names(structure_data));

                // TODO: Also depending on defines existing where it probably should not be.
                declare structure_name = NodeDefineData.>name(NodeDefineData.*cast(nodes_get_pointer_data(nodes, -(i, 1))));
                NodeStructureData.<name(structure_data, structure_name);

                declared_structure_id = +(declared_structure_id, 1);
            };

            declare structure_datas = &(ProgramData.>structure_datas(program_data));
            autobuffer_stack8_push(structure_datas, structure_data);
        };

        if =(id, NODE_GLOBAL) {
            declare global_data = NodeGlobalData.*cast(pointer_data);
            declare global_name = NodeGlobalData.>name(global_data);
            declare global_type = NodeGlobalData.>type(global_data);

            declare global_types = &(ProgramData.>global_types(program_data));
            autobuffer_array8_set(global_types, declared_global_id, global_type);
            declared_global_id = +(declared_global_id, 1);
        };

        if =(id, NODE_MODULE) {
            autobuffer_stack8_push(&(module_stack), declared_module_id);
            declared_module_id = +(declared_module_id, 1);
        };

        if =(id, NODE_ENDMODULE) {
            declare _ = autobuffer_stack8_pop(&(module_stack));
        };

        if =(id, NODE_DEFINE) {
            declare define_data = NodeDefineData.*cast(pointer_data);
            declare define_name = NodeDefineData.>name(define_data);
            declare define_type = NodeDefineData.>type(define_data);

            // Calculate define_type
            if =(define_type, 0) {
                declare next_id = nodes_get_id(nodes, +(i, 1));
                declare next_data = nodes_get_pointer_data(nodes, +(i, 1));

                define_type = if =(next_id, NODE_NUMBER) {
                    declare number_data = NodeNumberData.*cast(next_data);
                    declare coersion = NodeNumberData.>coersion(number_data);
                    if !(=(coersion, 0)) {
                        expand_module_name_array(coersion, 0, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list())
                    } else {
                        "whole_8"
                    }
                } else if =(next_id, NODE_FUNCTION) {
                    function_data_to_string(NodeFunctionData.*cast(next_data))
                } else if =(next_id, NODE_STRUCTURE) {
                    structure_data_to_string(NodeStructureData.*cast(next_data))
                } else if =(next_id, NODE_GLOBAL) {
                    global_data_to_string(NodeGlobalData.*cast(next_data))
                } else if =(next_id, NODE_MODULE) {
                    "module"
                } else if =(next_id, NODE_RETRIEVE){
                    "define"
                } else {
                    print_node_error_beginning(nodes, i);
                    println("Unknown define type");
                    exit(1);
                    ""
                };

                NodeDefineData.<type(define_data, define_type);
            } else {
                // TODO: Check to make sure type is valid
            };

            declare name = NodeDefineData.>name(define_data);
            if >(AutoBufferStack8.>index(&(module_stack)), 0) {
                declare top_module = whole_8.cast(autobuffer_stack8_peek(&(module_stack)));
                declare top_module_string = any_16.>0();
                whole_8_to_string(top_module, &(top_module_string));

                name = concatenate2_brk_allocate(&(top_module_string), name);
            };

            hashmap_string_put(&(define_module_map), name, whole_8.cast(autobuffer_stack8_peek(&(module_stack))));

            if string=(define_type, "module") {
                hashmap_string_put(&(module_id_map), name, declared_module_id);
            } else if string=(define_type, "define") {
                declare full_define = "";

                declare j = 0;
                declare retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, +(i, 1)));
                declare retrieve_names = NodeRetrieveData.>name(retrieve_data);
                while <(j, array8_length(retrieve_names)) {
                    declare retrieve_name = *.cast(array8_get(retrieve_names, j));
                    if string=(retrieve_name, "@current_module") {
                        declare top_module = whole_8.cast(autobuffer_stack8_peek(&(module_stack)));
                        declare top_module_string = any_16.>0();
                        whole_8_to_string(top_module, &(top_module_string));

                        full_define = concatenate2_brk_allocate(full_define, &(top_module_string));
                    } else {
                        full_define = concatenate3_brk_allocate(full_define, retrieve_name, ".");
                    };

                    j = +(j, 1);
                };

                full_define = substring_brk_allocate(full_define, 0, -(length(full_define), 1));
                hashmap_string_put(&(module_references_map), name, full_define);
            };

            define_name = get_define_name_with_module(define_name);
            NodeDefineData.<name(define_data, define_name);

            declare define_value: any_8;
            if string_length=(define_type, "*function", 9) {
                declare function_data = string_to_function_data(define_type);
                declare j = 0;
                declare argument_types = NodeFunctionData.>argument_types(&(function_data));
                while <(j, array8_length(argument_types)) {
                    declare argument = *.cast(array8_get(argument_types, j));
                    declare argument_array = to_type_array(argument);
                    declare new_argument = expand_module_name_array(argument_array, 0, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list());
                    array8_set(argument_types, j, new_argument);
                    j = +(j, 1);
                };
                define_type = function_data_to_string_old(&(function_data));
                NodeDefineData.<type(define_data, define_type);
                define_value = declared_function_id;
            } else if string_length=(define_type, "structure", 9) {
                define_value = declared_structure_id;
            } else if string_length=(define_type, "global", 6) {
                define_value = declared_global_id;
            } else if string_length=(define_type, "module", 6) {
                define_value = declared_module_id;
            } else {
                define_value = NodeNumberData.>value(NodeNumberData.*cast(nodes_get_pointer_data(nodes, +(i, 1))));
            };

            autobuffer_stack8_push(&(define_types), define_type);

            declare define_types = &(ProgramData.>define_types(program_data));
            hashmap_string_put(define_types, define_name, define_type);

            declare define_values = &(ProgramData.>define_values(program_data));
            hashmap_string_put(define_values, define_name, define_value);
        };

        if =(id, NODE_ENDDEFINE) {
            declare define_data = NodeEndDefineData.*cast(pointer_data);
            declare define_type = *.cast(autobuffer_stack8_pop(&(define_types)));

            //if =(define_type, 0) {
            //} else if string=(define_type, "module") {
            //    declare _ = autobuffer_stack8_pop(&(module_stack));
            //};
        };

        i = +(i, 1);
    };
};

define expand_module_name = function(name_in: *, module_id_map: *HashMap, module_references_map: *HashMap, module_stack: *AutoBufferStack8, previous_results_list: *AutoBufferStack8): * {
    declare name = name_in;
    declare pointer_count = 0;
    while =(any_1.>(any_1.*cast(+(name, pointer_count))), ASCII.ASTERISK) {
         pointer_count = +(pointer_count, 1);
    };

    name = +(name, pointer_count);

    declare current_module_id = 999;
    declare buffer = autobuffer_buffer_new(8);
    declare i = 0;
    while <(i, length(name)) {
        declare character = any_1.>(any_1.*cast(+(name, i)));
        if =(character, ASCII.PERIOD) {
            declare current_module = autobuffer_buffer_get_buffer_pointer(&(buffer));

            declare new_id = if string=(current_module, "@current_module") {
                whole_8.cast(autobuffer_stack8_peek(module_stack))
            } else if =(current_module_id, 999) {
                declare temp_id = whole_8.cast(hashmap_string_get2(module_id_map, current_module));

                if =(temp_id, 999) {
                    declare temp_name = *.cast(hashmap_string_get2(module_references_map, current_module));
                    temp_name = expand_module_name(temp_name, module_id_map, module_references_map, module_stack, create_previous_results_list());
                    temp_id = whole_8.cast(hashmap_string_get2(module_id_map, temp_name));
                };
                temp_id
            } else {
                declare current_module_id_string = any_16.>0();
                whole_8_to_string(current_module_id, &(current_module_id_string));

                declare current_module_full = concatenate2_brk_allocate(&(current_module_id_string), current_module);
                declare temp_id = whole_8.cast(hashmap_string_get2(module_id_map, current_module_full));

                if =(temp_id, 999) {
                    declare temp_name = *.cast(hashmap_string_get2(module_references_map, current_module_full));
                    if =(temp_name, 999) {
                        return name;
                    };

                    temp_name = expand_module_name(temp_name, module_id_map, module_references_map, module_stack, create_previous_results_list());
                    temp_id = whole_8.cast(hashmap_string_get2(module_id_map, temp_name));
                };
                temp_id
            };

            current_module_id = new_id;

            autobuffer_buffer_reset(&(buffer));
        } else {
            autobuffer_buffer_push_whole_1(&(buffer), whole_1.cast(character));
        };
        i = +(i, 1);
    };

    if !(=(current_module_id, 999)) {
        declare current_module_id_string = any_16.>0();
        whole_8_to_string(current_module_id, &(current_module_id_string));
        name = concatenate2_brk_allocate(&(current_module_id_string), autobuffer_buffer_get_buffer_pointer(&(buffer)));
    };

    declare possible_reference = *.cast(hashmap_string_get2(module_references_map, name));
    if !(=(possible_reference, 999)) {
        declare i = 0;
        while <(i, AutoBufferStack8.>index(previous_results_list)) {
            if string=(*.cast(autobuffer_stack8_get(previous_results_list, i)), name) {
                return name;
            };
            i = +(i, 1);
        };
        autobuffer_stack8_push(previous_results_list, name);

        name = expand_module_name(possible_reference, module_id_map, module_references_map, module_stack, previous_results_list);
    };

    declare i = 0;
    while <(i, pointer_count) {
        name = concatenate2_brk_allocate("*", name);
        i = +(i, 1);
    };

    return name;
};

define create_previous_results_list = function(): *AutoBufferStack8 {
    declare new = autobuffer_stack8_new(32);
    declare allocated = AutoBufferStack8.*cast(brk_allocate(AutoBufferStack8.size()));
    AutoBufferStack8.<(allocated, new);
    return allocated;
};

define is_pointer = function(nodes: *Nodes, index_in: whole_8): boolean {
    declare index = index_in;
    while true {
        declare id = nodes_get_id(nodes, index);
        if =(id, NODE_INVOKE_INTERNAL) {
            declare invoke_data = NodeInvokeInternalData.*cast(nodes_get_pointer_data(nodes, index));
            declare name_expanded = *.cast(array8_get(NodeInvokeInternalData.>name(invoke_data), 0));
            return string=(name_expanded, "&");
        } else if =(id, NODE_SKIP) {
            
        } else {
            break;
        };

        index = +(index, 1);
    };
    return false;
};


define get_define_name_with_module = function(define_name: *): * {
    declare new_define_name = "";

    if >(AutoBufferStack8.>index(&(module_stack)), 0) {
        declare module_id = whole_8.cast(autobuffer_stack8_peek(&(module_stack)));
        declare module_id_buffer = any_24.>0();
        whole_8_to_string(module_id, &(module_id_buffer));

        new_define_name = copy_string_brk_allocate(&(module_id_buffer));
    };

    return concatenate2_brk_allocate(new_define_name, define_name);
};
