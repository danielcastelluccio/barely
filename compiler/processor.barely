define expand_type = function(nodes: *Nodes, program_data: *ProgramData, type: *): * {
    variable type2 = type;
    if string_length=(type, "function[", 9) {
        variable function_data_inner = get_function_from_string_type(type);

        update_function_data(program_data, &(function_data_inner), nodes, 0);
        type2 = get_function_string_type(&(function_data_inner));
    };
    return type2;
};

define is_type = function(wanted_in: *, given_in: *, nodes: *Nodes, program_data: *ProgramData): boolean {
    variable wanted = expand_type(nodes, program_data, wanted_in);
    variable given = expand_type(nodes, program_data, given_in);
    if string=(wanted, given) {
        return true;
    };

    if string=(wanted, "*") {
        if string_length=(given, "*", 1) {
            return true;
        };
    };

    if string_length=(wanted, "*", 1) {
        if string_length=(given, "*", 1) {
            return is_type(+(wanted, 1), +(given, 1), nodes, program_data);
        };
    };

    if string_length=(given, "*", 1) {
        if string=(wanted, "structure[_:any_8]") {
            return true;
        };
    };

    variable define_types = &(ProgramData.>define_types(program_data));
    variable define_values = &(ProgramData.>define_values(program_data));

    variable defined = get_type_of_define(define_types, define_values, given);
    if !(=(defined, 0)) {
        if string=(defined, wanted) {
            return true;
        };
    };

    defined = get_type_of_define(define_types, define_values, wanted);
    if !(=(defined, 0)) {
        if string=(defined, given) {
            return true;
        };
    };

    if string_length=(wanted, "global[", 7) {
        return string_length=(+(wanted, 7), given, -(length(wanted), 8));
    };

    if string_length=(given, "global[", 7) {
        variable given_substring = substring_brk_allocate(given, 7, -(length(given), 1));
        return is_type(given_substring, wanted, nodes, program_data);
    };

    if |(&&(string=(wanted, "*structure[_:any_8]"), string=(given, "structure[_:any_8]")), &&(string=(wanted, "structure[_:any_8]"), string=(given, "*structure[_:any_8]"))) {
        return true;
    };

    if string_length=(wanted, "any_", 4) {
        variable size = to_number(*.cast(+(wanted, 4)));
        variable size_function = ProgramData.>get_size(program_data);
        return =(size, size_function(given, nodes, program_data));
    };

    variable define_values = &(ProgramData.>define_values(program_data));

    variable prepended = "";
    variable buffer = autobuffer_buffer_new(24);
    variable i = 0;
    while <(i, length(wanted)) {
        variable character_pointer = +(wanted, i);

        if string_length=(character_pointer, ".", 1) {
            variable current_name = autobuffer_buffer_get_buffer_pointer(&(buffer));
            current_name = concatenate2_brk_allocate(prepended, current_name);

            variable module_id = if string=(current_name, "This") {
                whole_8.cast(autobuffer_stack8_pop(&(module_stack)))
            } else {
                whole_8.cast(hashmap_string_get2(define_values, current_name))
            };

            variable module_id_buffer = any_24.>0();
            whole_8_to_string(module_id, &(module_id_buffer));

            prepended = copy_string_brk_allocate(&(module_id_buffer));

            autobuffer_buffer_reset(&(buffer));
        } else {
            autobuffer_buffer_push_string_length(&(buffer), character_pointer, 1);
        };
        i = +(i, 1);
    };
    variable current_name_wanted = autobuffer_buffer_get_buffer_pointer(&(buffer));
    current_name_wanted = concatenate2_brk_allocate(prepended, current_name_wanted);

    variable prepended = "";
    variable buffer = autobuffer_buffer_new(24);
    variable i = 0;
    while <(i, length(given)) {
        variable character_pointer = +(given, i);

        if string_length=(character_pointer, ".", 1) {
            variable current_name = autobuffer_buffer_get_buffer_pointer(&(buffer));
            current_name = concatenate2_brk_allocate(prepended, current_name);

            variable module_id = if string=(current_name, "This") {
                whole_8.cast(autobuffer_stack8_pop(&(module_stack)))
            } else {
                whole_8.cast(hashmap_string_get2(define_values, current_name))
            };

            variable module_id_buffer = any_24.>0();
            whole_8_to_string(module_id, &(module_id_buffer));

            prepended = copy_string_brk_allocate(&(module_id_buffer));

            autobuffer_buffer_reset(&(buffer));
        } else {
            autobuffer_buffer_push_string_length(&(buffer), character_pointer, 1);
        };
        i = +(i, 1);
    };
    variable current_name_given = autobuffer_buffer_get_buffer_pointer(&(buffer));
    current_name_given = concatenate2_brk_allocate(prepended, current_name_given);

    if |(!(string=(current_name_wanted, wanted)), !(string=(current_name_given, given))) {
        if is_type(current_name_wanted, current_name_given, nodes, program_data) {
            return true;
        };
    };

    return false;
};

define is_signed = function(type: *, nodes: *Nodes): whole_8 {
    variable cached_signedness = whole_8.cast(hashmap_string_get2(&(cached_signedness_map), type));
    if !(=(cached_signedness, 999)) {
        return cached_signedness;
    };

    if string_length=(type, "*", 1) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };

    if string_length=(type, "whole", 5) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "any", 3) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "integer", 7) {
        hashmap_string_put(&(cached_signedness_map), type, 1);
        return 1;
    };

    variable node_count = Nodes.>index(nodes);
    variable i = 0;
    while <(i, node_count) {
        if =(nodes_get_id(nodes, i), NODE_STRUCTURE) {
            variable pointer = NodeStructureData.*cast(nodes_get_pointer_data(nodes, i));
            variable name = NodeStructureData.>name(pointer);

            if !(=(name, 0)) {
                variable member_types = NodeStructureData.>item_types(pointer);
                if string=(type, name) {
                    variable is_signed2 = is_signed(*.cast(array8_get(member_types, 0)), nodes);
                    hashmap_string_put(&(cached_signedness_map), type, is_signed2);
                    return is_signed2;
                };
            };
        };
        i = +(i, 1);
    };

    hashmap_string_put(&(cached_signedness_map), type, 0);
    return 0;
};

define print_node_error_beginning = function(nodes: *Nodes, location: whole_8) {
    variable location_data = nodes_get_location_data(nodes, location);
    print("[ERROR] ");
    print(NodeLocationData.>file(location_data));
    print(":");
    print_whole_8(NodeLocationData.>row(location_data));
    print(":");
    print_whole_8(NodeLocationData.>column(location_data));
    print(": ");
};

define ProgramData = structure {
    define_types: HashMap;
    define_values: HashMap;
    structure_datas: AutoBufferStack8;
    structure_member_types: AutoBuffer;
    structure_member_names: AutoBuffer;
    function_datas: AutoBuffer;
    function_locations: AutoBuffer;
    function_argument_types: AutoBuffer;
    function_argument_names: AutoBuffer;
    function_return_types: AutoBuffer;
    internal_function_argument_types: HashMap;
    internal_function_argument_names: HashMap;
    internal_function_return_types: HashMap;
    global_types: AutoBuffer;

    // possible should be in a separate structure
    get_size: *function[*,*Nodes,*ProgramData:whole_8];
};

define module_stack = global(AutoBufferStack8);

define process = function(nodes: *Nodes, size_function: *function[*,*Nodes,*ProgramData:whole_8]): ProgramData {
    variable node_count = Nodes.>index(nodes);

    module_stack = autobuffer_stack8_new(32);

    variable program_data = ProgramData.>0();

    ProgramData.<internal_function_argument_types(&(program_data), hashmap_new(1024));
    ProgramData.<internal_function_argument_names(&(program_data), hashmap_new(1024));
    ProgramData.<internal_function_return_types(&(program_data), hashmap_new(1024));

    ProgramData.<define_types(&(program_data), hashmap_new(512));
    ProgramData.<define_values(&(program_data), hashmap_new(512));

    ProgramData.<function_locations(&(program_data), autobuffer_new(1024));
    ProgramData.<function_datas(&(program_data), autobuffer_new(1024));
    ProgramData.<function_argument_types(&(program_data), autobuffer_new(1024));
    ProgramData.<function_argument_names(&(program_data), autobuffer_new(1024));
    ProgramData.<function_return_types(&(program_data), autobuffer_new(1024));

    ProgramData.<structure_datas(&(program_data), autobuffer_stack8_new(1024));
    ProgramData.<structure_member_types(&(program_data), autobuffer_new(1024));
    ProgramData.<structure_member_names(&(program_data), autobuffer_new(1024));

    ProgramData.<global_types(&(program_data), autobuffer_new(512));

    ProgramData.<get_size(&(program_data), size_function);

    setup_process(nodes, &(program_data));

    variable current_function_id = 0;

    variable variable_scopes_types_map = autobuffer_new(64);
    variable variable_scope_types_pointer = 0;
    variable variable_scopes_declares_map = autobuffer_new(64);
    variable variable_scope_declares_pointer = 0;

    variable stack = autobuffer_new(64);
    variable stack_pointer = 0;

    variable if_blocks = autobuffer_new(64);
    variable if_block_pointer = 0;
    variable if_block_results = autobuffer_new(64);

    variable function_id = 0;

    variable has_main = false;
    variable declared_function_id = 0;
    variable declared_module_id = 0;

    variable i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            variable function_name = NodeFunctionData.>name(NodeFunctionData.*cast(pointer_data));

            if =(function_name, 0) {
                variable structure_datas = &(ProgramData.>structure_datas(&(program_data)));
                variable define_types = &(ProgramData.>define_types(&(program_data)));
                variable define_values = &(ProgramData.>define_values(&(program_data)));

                variable return_types = &(ProgramData.>function_return_types(&(program_data)));
                variable return_types_individual = *.cast(autobuffer_array8_get(return_types, declared_function_id));
                variable return_types_individual2 = *.cast(autobuffer_array8_get(return_types, declared_function_id));

                variable j = 0;
                while <(j, array8_length(return_types_individual)) {
                    variable return_ = *.cast(array8_get(return_types_individual, j));

                    variable is_pointer = &&(string_length=(return_, "*", 1), >(length(return_), 1));
                    if is_pointer {
                        return_ = +(return_, 1);
                    };

                    if is_define(return_) {
                        variable structure_id = whole_8.cast(get_value_of_define(define_types, define_values, return_));
                        variable structure_data = NodeStructureData.*cast(autobuffer_stack8_get(structure_datas, structure_id));
                        array8_set(return_types_individual, j, get_structure_string_type(structure_data));
                    };

                    if is_pointer {
                        return_ = concatenate2_brk_allocate("*", return_);
                    };

                    j = +(j, 1);
                };

                declared_function_id = +(declared_function_id, 1);
            } else {
                variable function_data = NodeFunctionData.*cast(pointer_data);
                variable type = get_function_string_type(function_data);
                update_function_data(&(program_data), function_data, nodes, i);
            };
        } else if =(id, NODE_DECLARE) {
            variable structure_datas = &(ProgramData.>structure_datas(&(program_data)));
            variable define_types = &(ProgramData.>define_types(&(program_data)));
            variable define_values = &(ProgramData.>define_values(&(program_data)));

            variable declare_data = NodeDeclareData.*cast(pointer_data);
            variable declare_type = NodeDeclareData.>type(declare_data);

            if >(length(declare_type), 0) {
                variable is_pointer = &&(string_length=(declare_type, "*", 1), >(length(declare_type), 1));
                if is_pointer {
                    declare_type = +(declare_type, 1);
                };

                if is_define(declare_type) {
                    variable structure_id = whole_8.cast(get_value_of_define(define_types, define_values, declare_type));
                    if !(=(structure_id, 999)) {
                        variable structure_data = NodeStructureData.*cast(autobuffer_stack8_get(structure_datas, structure_id));
                        declare_type = get_structure_string_type(structure_data);
                    } else {
                        // TODO: Actually get where the issues is, probably gonna have to rework some 
                        // stuff to make that info accessable here.
                        print_node_error_beginning(nodes, i);
                        print("Could not resolve type '");
                        print(declare_type);
                        println("'");
                        exit(1);
                    };
                };

                if is_pointer {
                    declare_type = concatenate2_brk_allocate("*", declare_type);
                };

                NodeDeclareData.<type(declare_data, declare_type);
            };
        } else if =(id, NODE_MODULE) {
            autobuffer_stack8_push(&(module_stack), declared_module_id);
            declared_module_id = +(declared_module_id, 1);
        } else if =(id, NODE_ENDMODULE) {
            variable _ = autobuffer_stack8_pop(&(module_stack));
        } else if =(id, NODE_DEFINE) {
            variable structure_datas = &(ProgramData.>structure_datas(&(program_data)));
            variable define_types = &(ProgramData.>define_types(&(program_data)));
            variable define_values = &(ProgramData.>define_values(&(program_data)));

            variable define_data = NodeDefineData.*cast(pointer_data);
            variable define_name = NodeDefineData.>name(define_data);
            variable define_type = NodeDefineData.>type(define_data);

            if string_length=(define_type, "*function[", 10) {
                variable function_datas = &(ProgramData.>function_datas(&(program_data)));
                variable function_data = NodeFunctionData.*cast(autobuffer_array8_get(function_datas, declared_function_id));
                update_function_data(&(program_data), function_data, nodes, +(i, 1));

                define_type = get_function_string_type(function_data);
                hashmap_string_put(define_types, define_name, define_type);
            };
        };

        i = +(i, 1);
    };

    variable declared_function_id = 0;
    variable declared_module_id = 0;

    variable i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            variable function_name = NodeFunctionData.>name(NodeFunctionData.*cast(pointer_data));

            if =(function_name, 0) {
                current_function_id = function_id;
                function_id = +(function_id, 1);
            };

            stack_pointer = 0;
        } else if =(id, NODE_NUMBER) {
            process_number(&(stack), &(stack_pointer), pointer_data);
        } else if =(id, NODE_BOOLEAN) {
            autobuffer_stack8_legacy_push(&(stack), &(stack_pointer), "structure[_:any_1]");
        } else if =(id, NODE_STRING) {
            autobuffer_stack8_legacy_push(&(stack), &(stack_pointer), "structure[_:any_8]");
        } else if =(id, NODE_INVOKE) {
            process_invoke(nodes, i, &(stack), &(stack_pointer), &(program_data), pointer_data);
        } else if =(id, NODE_DECLARE) {
            variable declare_data = NodeDeclareData.*cast(pointer_data);
            variable variable_name = NodeDeclareData.>name(declare_data);
            variable variable_type = NodeDeclareData.>type(declare_data);

            hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), -(variable_scope_types_pointer, 1))), variable_name, variable_type);
            hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_declares_map), -(variable_scope_declares_pointer, 1))), variable_name, i);
        } else if =(id, NODE_ASSIGN) {
            process_assign(nodes, i, &(stack), &(stack_pointer), &(program_data), variable_scopes_types_map, variable_scope_types_pointer, variable_scopes_declares_map, pointer_data);
        } else if =(id, NODE_RETRIEVE) {
            process_retrieve(nodes, i, &(stack), &(stack_pointer), variable_scopes_types_map, variable_scope_types_pointer, &(program_data), current_function_id);
        } else if =(id, NODE_RETURN) {
            process_return(nodes, i, &(stack), &(stack_pointer), &(program_data), current_function_id);
        } else if =(id, NODE_POINTER) {
            process_pointer(nodes, i, &(stack), &(stack_pointer));
        } else if =(id, NODE_JUMP_CONDITIONAL) {
            process_jump_conditional(nodes, i, &(program_data), &(stack), &(stack_pointer));
        } else if =(id, NODE_SCOPE) {
            variable new_hashmap = hashmap_new(512);
            variable allocated = brk_allocate(24);
            HashMap.<(HashMap.*cast(allocated), new_hashmap);
            autobuffer_stack8_legacy_push(&(variable_scopes_types_map), &(variable_scope_types_pointer), allocated);

            variable new_hashmap = hashmap_new(512);
            variable allocated = brk_allocate(24);
            HashMap.<(HashMap.*cast(allocated), new_hashmap);
            autobuffer_stack8_legacy_push(&(variable_scopes_declares_map), &(variable_scope_declares_pointer), allocated);
        } else if =(id, NODE_ENDSCOPE) {
            variable _ = autobuffer_stack8_legacy_pop(&(variable_scopes_types_map), &(variable_scope_types_pointer));
            variable _ = autobuffer_stack8_legacy_pop(&(variable_scopes_declares_map), &(variable_scope_declares_pointer));
        } else if =(id, NODE_STARTIFBLOCK) {
            autobuffer_stack8_legacy_push(&(if_blocks), &(if_block_pointer), stack_pointer);
        } else if =(id, NODE_ENDIFBLOCK) {
            process_end_if(nodes, i, &(stack), &(stack_pointer), &(if_blocks), &(if_block_results), &(if_block_pointer), pointer_data, &(program_data));
        } else if =(id, NODE_DEFINE) {
            variable define_node_data = NodeDefineData.*cast(pointer_data);
            if string=(NodeDefineData.>name(define_node_data), "main") {
                has_main = true;
            };
        } else if =(id, NODE_ENDDEFINE) {
        } else if =(id, NODE_MODULE) {
            autobuffer_stack8_push(&(module_stack), declared_module_id);
            declared_module_id = +(declared_module_id, 1);
        } else if =(id, NODE_ENDMODULE) {
            variable _ = autobuffer_stack8_pop(&(module_stack));
        } else if =(id, NODE_JUMP) {
        } else if =(id, NODE_TARGET) {
        } else if =(id, NODE_ENDFUNCTION) {
        } else if =(id, NODE_STRUCTURE) {
        } else if =(id, NODE_GLOBAL) {
        } else if =(id, NODE_SKIP) {
        } else if =(id, NODE_ENDSTATEMENT) {
            if !(=(stack_pointer, 0)) {
                print_node_error_beginning(nodes, i);
                println("Statement end has extra stack values");
                while !(=(stack_pointer, 0)) {
                    println(*.cast(autobuffer_stack8_legacy_pop(&(stack), &(stack_pointer))));
                };
                exit(1);

            };
        } else {
            print("Unhandled ");
            print_whole_8(id);
            println("");
        };

        i = +(i, 1);
    };
    
    if !(has_main) {
        println("[ERROR] No 'main' function defined");
        exit(1);
    };

    return program_data;
};

define update_function_data = function(program_data: *ProgramData, function_data: *NodeFunctionData, nodes: *Nodes, index: whole_8) {
    variable structure_datas = &(ProgramData.>structure_datas(program_data));
    variable define_types = &(ProgramData.>define_types(program_data));
    variable define_values = &(ProgramData.>define_values(program_data));

    variable function_argument_types = NodeFunctionData.>argument_types(function_data);
    variable function_return_types = NodeFunctionData.>returns(function_data);

    variable j = 0;
    while !(=(array8_get(function_argument_types, j), 0)) {
        variable argument = *.cast(array8_get(function_argument_types, j));

        variable is_pointer = &&(string_length=(argument, "*", 1), >(length(argument), 1));
        if is_pointer {
            argument = +(argument, 1);
        };

        if is_define(argument) {
            variable structure_id = whole_8.cast(get_value_of_define(define_types, define_values, argument));
            if !(=(structure_id, 999)) {
                variable structure_data = NodeStructureData.*cast(autobuffer_stack8_get(structure_datas, structure_id));
                argument = get_structure_string_type(structure_data);
            } else {
                // TODO: Actually get where the issues is, probably gonna have to rework some 
                // stuff to make that info accessable here.
                print_node_error_beginning(nodes, index);
                print("Could not resolve type '");
                print(argument);
                println("'");
                exit(1);
            };
        };

        if string_length=(argument, "function[", 9) {
            variable function_data_inner = get_function_from_string_type(argument);

            update_function_data(program_data, &(function_data_inner), nodes, index);
            argument = get_function_string_type(&(function_data_inner));
            is_pointer = false;
        };

        if is_pointer {
            argument = concatenate2_brk_allocate("*", argument);
        };

        array8_set(function_argument_types, j, argument);

        j = +(j, 1);
    };

    variable j = 0;
    while !(=(array8_get(function_return_types, j), 0)) {
        variable return_ = *.cast(array8_get(function_return_types, j));

        variable is_pointer = &&(string_length=(return_, "*", 1), >(length(return_), 1));
        if is_pointer {
            return_ = +(return_, 1);
        };

        if is_define(return_) {
            variable structure_id = whole_8.cast(get_value_of_define(define_types, define_values, return_));
            variable structure_data = NodeStructureData.*cast(autobuffer_stack8_get(structure_datas, structure_id));
            return_ = get_structure_string_type(structure_data);
        };

        if is_pointer {
            return_ = concatenate2_brk_allocate("*", return_);
        };

        array8_set(function_return_types, j, return_);

        j = +(j, 1);
    };
};

define get_function_from_string_type = function(type: *): NodeFunctionData {
    variable argument_types = autobuffer_stack8_new(24);
    variable return_types = autobuffer_stack8_new(24);

    variable argument_index = 0;
    variable return_index = 0;

    variable inside = 0;
    variable is_return = false;
    variable buffer = autobuffer_buffer_new(24);
    variable i = 9;
    while <(i, length(type)) {
        variable character_pointer = +(type, i);
        
        if &&(=(inside, 0), |(string_length=(character_pointer, ":", 1), &&(string_length=(character_pointer, ",", 1), !(is_return)))) {
            if >(AutoBufferStack8.>index(&(buffer)), 0) {
                autobuffer_stack8_push(&(argument_types), copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(buffer))));
                autobuffer_buffer_reset(&(buffer));
            };

            if string_length=(character_pointer, ":", 1) {
                is_return = true;
            };
        } else if &&(=(inside, 0), |(string_length=(character_pointer, "]", 1), string_length=(character_pointer, ",", 1))) {
            if >(AutoBufferStack8.>index(&(buffer)), 0) {
                autobuffer_stack8_push(&(return_types), copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(buffer))));
                autobuffer_buffer_reset(&(buffer));
            };
            if string_length=(character_pointer, "]", 1) {
                break;
            };
        } else if string_length=(character_pointer, "[", 1) {
            inside = +(inside, 1);
            autobuffer_buffer_push_string_length(&(buffer), character_pointer, 1);
        } else if string_length=(character_pointer, "]", 1) {
            inside = -(inside, 1);
            autobuffer_buffer_push_string_length(&(buffer), character_pointer, 1);
        } else {
            autobuffer_buffer_push_string_length(&(buffer), character_pointer, 1);
        };

        i = +(i, 1);
    };

    variable data = NodeFunctionData.>0();
    NodeFunctionData.<argument_types(&(data), autobuffer_stack8_get_buffer_pointer(&(argument_types)));
    NodeFunctionData.<returns(&(data), autobuffer_stack8_get_buffer_pointer(&(return_types)));

    return data;
};

define is_define = function(type: *): boolean {
    if string_length=(type, "structure[", 10) {
        return false;
    };
    if string_length=(type, "any_", 4) {
        return false;
    };
    if string_length=(type, "function[", 9) {
        return false;
    };
    if string_length=(type, "*function[", 10) {
        return false;
    };
    if string_length=(type, "global[", 7) {
        return false;
    };
    return true;
};

define process_number = function(stack: *AutoBuffer, stack_pointer: *whole_8, pointer_data: *) {
    variable number_data = NodeNumberData.*cast(pointer_data);

    variable number_type = autobuffer_buffer_new(16);

    if =(NodeNumberData.>type(number_data), 0) {
        autobuffer_buffer_push_string(&(number_type), "whole_");
    } else {
        autobuffer_buffer_push_string(&(number_type), "integer_");
    };

    autobuffer_buffer_string_push_whole_8(&(number_type), NodeNumberData.>size(number_data));

    autobuffer_stack8_legacy_push(stack, stack_pointer, AutoBuffer.>buffer(&(AutoBufferBuffer.>autobuffer(&(number_type)))));
};

define process_jump_conditional = function(nodes: *Nodes, nodes_index: whole_8, program_data: *ProgramData, stack: *AutoBuffer, stack_pointer: *whole_8) {
    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        println("Conditional jump ran out of stack values");
        exit(1);
    };

    variable popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    if !(is_type(popped, "boolean", nodes, program_data)) {
        print_node_error_beginning(nodes, nodes_index);
        print("Conditional Jump (if/while) wants 'boolean', given '");
        print(popped);
        println("'");
        exit(1);
    };
};

define process_pointer = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8) {
};

define process_return = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, current_function_id: whole_8) {
    variable function_return_types = &(ProgramData.>function_return_types(program_data));
    variable function_return_types_specific = *.cast(autobuffer_array8_get(function_return_types, current_function_id));

    variable temp = array8_length(function_return_types_specific);
    variable j = -(temp, 1);
    while <(j, temp) {
        variable function_return = *.cast(array8_get(function_return_types_specific, j));

        if =(whole_8.>(stack_pointer), 0) {
            print_node_error_beginning(nodes, nodes_index);
            println("Return ran out of stack values");
            exit(1);
        };

        variable stack_popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
        
        if !(is_type(function_return, stack_popped, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Return wants '");
            print(function_return);
            print("', given '");
            print(stack_popped);
            println("'");
            exit(1);
        };

        j = -(j, 1);
    };

    if !(=(whole_8.>(stack_pointer), 0)) {
        print_node_error_beginning(nodes, nodes_index);
        println("Return has extra stack values");
        exit(1);
    };
};

define process_end_if = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, if_blocks: *AutoBuffer, if_block_results: *AutoBuffer, if_block_pointer: *whole_8, pointer_data: *, program_data: *ProgramData) {
    variable end_if_data = NodeEndIfBlockData.*cast(pointer_data);
    variable end_if_id = NodeEndIfBlockData.>id(end_if_data);
    variable is_last = NodeEndIfBlockData.>is_last(end_if_data);
    variable is_bare_else = NodeEndIfBlockData.>is_bare_else(end_if_data);

    variable start_stack = whole_8.cast(autobuffer_stack8_legacy_pop(if_blocks, if_block_pointer));
    variable previous_results = *.cast(autobuffer_array8_get(if_block_results, end_if_id));

    variable size = *(8, -(whole_8.>(stack_pointer), start_stack));
    if =(previous_results, 0) {
        previous_results = brk_allocate(+(8, size));
        variable array = autobuffer_get_size(stack, *(8, start_stack), size);
        copy(array, previous_results, size);

        autobuffer_array8_set(if_block_results, end_if_id, previous_results);

        if !(is_last) {
            variable j = 0;
            while <(j, /(size, 8)) {
                variable _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);

                j = +(j, 1);
            };
        } else if &&(!(is_bare_else), >(size, 0)) {
            print_node_error_beginning(nodes, nodes_index);
            println("If expression resulting in a value requires an 'else' condition");
            exit(1);
        };
    } else {
        variable array = autobuffer_get_size(stack, *(8, start_stack), size);
        variable previous_array = previous_results;

        variable max_size = size;
        if >(*(array8_length(previous_array), 8), size) {
            size = *(array8_length(previous_array), 8);
        };

        variable j = 0;
        while <(j, /(size, 8)) {
            variable previous_value = *.cast(array8_get(previous_array, j));
            variable value = *.cast(array8_get(array, j));

            variable error = false;

            if =(value, 0) {
                error = true;
            } else if =(previous_value, 0) {
                error = true;
            } else if !(is_type(value, previous_value, nodes, program_data)) {
                error = true;
            } else {
                if !(is_last) {
                    variable _ = autobuffer_stack8_legacy_pop(stack, stack_pointer);
                };
            };

            if error {
                print_node_error_beginning(nodes, nodes_index);
                println("If does not have matching branch results");
                exit(1);
            };

            j = +(j, 1);
        };
    };
};

define process_assign = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, variable_scopes_declares_map: AutoBuffer, pointer_data: *) {
    variable assign_data = NodeAssignData.*cast(pointer_data);
    variable variable_name = NodeAssignData.>name(assign_data);

    variable scope_index, variable_type = get_variable_info(variable_scopes_types_map, variable_scope_types_pointer, variable_name);

    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        println("Assign ran out of stack values");
        exit(1);
    };

    variable popped_stack = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if !(=(variable_type, 0)) {
        if string=(variable_type, "") {
            variable_type = popped_stack;

            hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name, popped_stack);

            variable variable_declare_node_index = hashmap_string_get(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_declares_map), scope_index)), variable_name);
            variable variable_declare_node = NodeDeclareData.*cast(nodes_get_pointer_data(nodes, whole_8.cast(variable_declare_node_index)));
            NodeDeclareData.<type(variable_declare_node, variable_type);
        };

        if !(is_type(variable_type, popped_stack, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Assign of ");
            print(variable_name);
            print(" wants '");
            print(variable_type);
            print("', given '");
            print(popped_stack);
            println("'");
            exit(1);
        };
        return;
    };

    variable define_values = &(ProgramData.>define_values(program_data));

    variable global_id = whole_8.cast(hashmap_string_get2(define_values, variable_name));
    if !(=(global_id, 999)) {
        variable global_types = &(ProgramData.>global_types(program_data));
        variable_type = *.cast(autobuffer_array8_get(global_types, global_id));
    };

    if !(=(variable_type, 0)) {
        if !(is_type(variable_type, popped_stack, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Assign of ");
            print(variable_name);
            print(" wants '");
            print(variable_type);
            print("', given '");
            print(popped_stack);
            println("'");
            exit(1);
        };
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Assign target '");
        print(variable_name);
        println("' not found");
        exit(1);
    };
};

define get_variable_info = function(variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, variable_name: *): whole_8, * {
    variable scope_index = -(variable_scope_types_pointer, 1);
    variable variable_type = *.cast(0);
    while &&(=(variable_type, 0), <(scope_index, variable_scope_types_pointer)) {
        variable_type = *.cast(hashmap_string_get(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name));
        scope_index = -(scope_index, 1);
    };
    scope_index = +(scope_index, 1);

    return scope_index, variable_type;
};

define process_invoke_pointer = function(nodes: *Nodes, nodes_index: whole_8,  stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, pointer_data: *) {
    variable function_type = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if string_length=(function_type, "*function[", 10) {
        variable arguments_buffer, returns_buffer = get_arguments_from_function_type(function_type);

        variable k = integer_8.cast(array8_length(arguments_buffer));
        while >(k, 0_integer_8) {
            k = -(k, 1_integer_8);

            if =(whole_8.>(stack_pointer), 0) {
                print_node_error_beginning(nodes, nodes_index);
                print("Invoke of '");
                if =(nodes_get_id(nodes, -(nodes_index, 1)), NODE_RETRIEVE) {
                    variable previous_node_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(nodes_index, 1)));
                    print(NodeRetrieveData.>name(previous_node_data));
                } else {
                    print("unknown");
                };
                println("' ran out of stack values");
                exit(1);
            };

            variable given = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
            variable wanted = *.cast(array8_get(arguments_buffer, whole_8.cast(k)));

            if !(is_type(wanted, given, nodes, program_data)) {
                print_node_error_beginning(nodes, nodes_index);
                print("Invoke of '");

                if =(nodes_get_id(nodes, -(nodes_index, 1)), NODE_RETRIEVE) {
                    variable previous_node_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(nodes_index, 1)));
                    print(NodeRetrieveData.>name(previous_node_data));
                } else {
                    print("unknown");
                };

                print("' wants '");
                print(wanted);
                print("', given '");
                print(given);
                println("'");
                exit(1);
            };
        };

        variable k = 0;
        while <(k, array8_length(returns_buffer)) {
            variable return_ = *.cast(array8_get(returns_buffer, k));

            autobuffer_stack8_legacy_push(stack, stack_pointer, return_);
            k = +(k, 1);
        };
    } else {
        print_node_error_beginning(nodes, nodes_index);
        print("Attempting to invoke non function pointer '");
        print(function_type);
        println("'");
        exit(1);
    };
};

define get_arguments_from_function_type = function(function_type: *): *, * {
    variable arguments_buffer = autobuffer_new(64);
    variable arguments_buffer_index = 0;

    variable current_buffer = autobuffer_buffer_new(64);

    variable inner = 0;
    variable j = 10;
    while |(!(=(whole_1.>(whole_1.*cast(+(function_type, j))), ASCII_COLON)), >(inner, 0)) {
        variable character = whole_1.>(whole_1.*cast(+(function_type, j)));
        if &&(|(=(character, ASCII_CLOSED_BRACKET), =(character, ASCII_COMMA)), =(inner, 0)) {
            autobuffer_array8_set(&(arguments_buffer), arguments_buffer_index, copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(current_buffer))));
            arguments_buffer_index = +(arguments_buffer_index, 1);

            current_buffer = autobuffer_buffer_new(64);
        } else {
            autobuffer_buffer_push_whole_1(&(current_buffer), character);
        };

        if =(character, ASCII_OPEN_BRACKET) {
            inner = +(inner, 1);
        } else if =(character, ASCII_CLOSED_BRACKET) {
            inner = -(inner, 1);
        };
        j = +(j, 1);
    };
    if >(AutoBufferBuffer.>index(&(current_buffer)), 0) {
        autobuffer_array8_set(&(arguments_buffer), arguments_buffer_index, copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(current_buffer))));
    };

    variable returns_buffer = autobuffer_new(64);
    variable returns_buffer_index = 0;

    variable inner = 0;
    current_buffer = autobuffer_buffer_new(64);

    j = +(j, 1);

    while |(!(=(whole_1.>(whole_1.*cast(+(function_type, j))), ASCII_CLOSED_BRACKET)), >(inner, 0)) {
        variable character = whole_1.>(whole_1.*cast(+(function_type, j)));
        if &&(|(=(character, ASCII_COLON), =(character, ASCII_COMMA)), =(inner, 0)) {
            variable return_ = autobuffer_buffer_get_buffer_pointer(&(current_buffer));

            autobuffer_array8_set(&(returns_buffer), returns_buffer_index, copy_string_brk_allocate(return_));
            returns_buffer_index = +(returns_buffer_index, 1);

            current_buffer = autobuffer_buffer_new(64);
        } else {
            autobuffer_buffer_push_whole_1(&(current_buffer), character);
        };

        if =(character, ASCII_OPEN_BRACKET) {
            inner = +(inner, 1);
        } else if =(character, ASCII_CLOSED_BRACKET) {
            inner = -(inner, 1);
        };
        j = +(j, 1);
    };

    if >(AutoBufferBuffer.>index(&(current_buffer)), 0) {
        autobuffer_array8_set(&(returns_buffer), returns_buffer_index, copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(current_buffer))));
    };

    return AutoBuffer.>buffer(&(arguments_buffer)), AutoBuffer.>buffer(&(returns_buffer));
};

define get_type_of_define = function(define_types: *HashMap, define_values: *HashMap, define_name: *): * {
    variable define_type = "";
    variable buffer = autobuffer_buffer_new(24);
    variable define_name_extra = concatenate2_brk_allocate(define_name, ".");
    variable i = 0;
    while <(i, length(define_name_extra)) {
        variable character_pointer = +(define_name_extra, i);
        if string_length=(character_pointer, ".", 1) {
            variable define_name_local = autobuffer_buffer_get_buffer_pointer(&(buffer));

            variable define_type_local = *.cast(hashmap_string_get(define_types, define_name_local));
            if string=(define_name_local, "This") {
                define_type_local = "module";
            };

            if =(define_type_local, 0) {
                return *.cast(0);
            };

            if string=(define_type_local, "define") {
                variable define_value = *.cast(hashmap_string_get(define_values, define_name_local));
                variable define_array_length = array8_length(define_value);

                variable current_name = "";
                variable current_module_index = 999;

                variable index = -(define_array_length, 1);
                while <(index, define_array_length) {
                    current_name = *.cast(array8_get(define_value, index));

                    if !(=(current_module_index, 999)) {
                        variable index_buffer = any_24.>0();
                        whole_8_to_string(current_module_index, &(index_buffer));
                        current_name = concatenate2_brk_allocate(&(index_buffer), current_name);
                    };

                    if !(=(hashmap_string_get2(define_types, current_name), 999)) {
                        current_module_index = whole_8.cast(hashmap_string_get2(define_values, current_name));
                    } else if string=(current_name, "This") {
                        current_module_index = whole_8.cast(autobuffer_stack8_peek(&(module_stack)));
                    };
                    index = -(index, 1);
                };

                variable index_buffer = any_24.>0();
                whole_8_to_string(whole_8.cast(get_value_of_define(define_types, define_values, current_name)), &(index_buffer));

                define_type = get_type_of_define(define_types, define_values, current_name);
            } else {
                define_type = define_type_local;
            };

            autobuffer_buffer_reset(&(buffer));
        } else {
            autobuffer_buffer_push_string_length(&(buffer), character_pointer, 1);
        };

        i = +(i, 1);
    };

    return define_type;
};

define get_value_of_define = function(define_types: *HashMap, define_values: *HashMap, define_name: *): any_8 {
    variable prepended = "";
    variable define_value: any_8 = 999;
    variable buffer = autobuffer_buffer_new(24);
    variable define_name_extra = concatenate2_brk_allocate(define_name, ".");
    variable i = 0;
    while <(i, length(define_name_extra)) {
        variable character_pointer = +(define_name_extra, i);
        if string_length=(character_pointer, ".", 1) {
            variable define_name_local = autobuffer_buffer_get_buffer_pointer(&(buffer));
            define_name_local = concatenate2_brk_allocate(prepended, define_name_local);

            variable define_type_local = *.cast(hashmap_string_get(define_types, define_name_local));
            variable define_value_local = *.cast(hashmap_string_get2(define_values, define_name_local));

            if string=(define_name_local, "This") {
                define_type_local = "module";
            };
            if =(define_type_local, 0) {
                return 999;
            };

            if string=(define_type_local, "define") {
                variable define_value_local = *.cast(hashmap_string_get2(define_values, define_name_local));
                variable define_array_length = array8_length(define_value_local);

                variable current_name = "";
                variable current_module_index = 999;

                variable index = -(define_array_length, 1);
                while <(index, define_array_length) {
                    current_name = *.cast(array8_get(define_value_local, index));

                    if !(=(current_module_index, 999)) {
                        variable index_buffer = any_24.>0();
                        whole_8_to_string(current_module_index, &(index_buffer));
                        current_name = concatenate2_brk_allocate(&(index_buffer), current_name);
                    };

                    if !(=(hashmap_string_get2(define_types, current_name), 999)) {
                        current_module_index = whole_8.cast(hashmap_string_get2(define_values, current_name));
                    } else if string=(current_name, "This") {
                        current_module_index = whole_8.cast(autobuffer_stack8_peek(&(module_stack)));
                    };
                    index = -(index, 1);
                };

                define_value = get_value_of_define(define_types, define_values, current_name);
            } else {
                if string=(define_name_local, "This") {
                    define_value = whole_8.cast(autobuffer_stack8_peek(&(module_stack)));
                } else {
                    define_value = define_value_local;
                };
            };

            variable index_buffer = any_24.>0();
            whole_8_to_string(whole_8.cast(define_value), &(index_buffer));
            prepended = copy_string_brk_allocate(&(index_buffer));

            autobuffer_buffer_reset(&(buffer));
        } else {
            autobuffer_buffer_push_string_length(&(buffer), character_pointer, 1);
        };

        i = +(i, 1);
    };

    return define_value;
};

define process_retrieve = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, variable_scopes_types_map: AutoBuffer, variable_scope_types_pointer: whole_8, program_data: *ProgramData, current_function_id: whole_8) {
    variable retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, nodes_index));
    variable variable_name = NodeRetrieveData.>name(retrieve_data);

    variable variable_type: * = *.cast(0);

    if !(NodeRetrieveData.>using_module(retrieve_data)) {
        if &&(string_length=(variable_name, "any_", 4), &&(=(nodes_get_id(nodes, +(nodes_index, 1)), NODE_INVOKE), NodeInvokeData.>has_specifier(NodeInvokeData.*cast(nodes_get_pointer_data(nodes, +(nodes_index, 1)))))) {
            autobuffer_stack8_legacy_push(stack, stack_pointer, variable_name);
            return;
        };

        variable scope_index, variable_type = get_variable_info(variable_scopes_types_map, variable_scope_types_pointer, variable_name);

        if !(=(variable_type, 0)) {
            if is_pointer(nodes, +(nodes_index, 1)) {
                variable_type = concatenate2_brk_allocate("*", variable_type);
            };
            autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
            return;
        };

        variable function_argument_types = &(ProgramData.>function_argument_types(program_data));
        variable function_argument_names = &(ProgramData.>function_argument_names(program_data));

        variable function_argument_names_specific = *.cast(autobuffer_array8_get(function_argument_names, current_function_id));
        variable function_argument_types_specific = *.cast(autobuffer_array8_get(function_argument_types, current_function_id));

        variable_type = stringarray_get(function_argument_names_specific, function_argument_types_specific, variable_name, array8_length(function_argument_types_specific));
        if !(=(variable_type, 0)) {
            if is_pointer(nodes, +(nodes_index, 1)) {
                variable_type = concatenate2_brk_allocate("*", variable_type);
            };
            autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
            return;
        };
    };

    variable define_values = &(ProgramData.>define_values(program_data));

    if is_pointer(nodes, +(nodes_index, 1)) {
        variable_name = concatenate2_brk_allocate("*", variable_name);
        NodeRetrieveData.<name(retrieve_data, variable_name);
    };

    if NodeRetrieveData.>using_module(retrieve_data) {
        variable original_index = nodes_index;
        variable modules_index = +(original_index, 1);
        while =(nodes_get_id(nodes, modules_index), NODE_RETRIEVE) {
            variable retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, modules_index));
            variable is_module = NodeRetrieveData.>is_module(retrieve_data);

            if !(is_module) {
                break;
            };
            modules_index = +(modules_index, 1);
        };

        modules_index = -(modules_index, 1);

        variable prepended_to_name = "";

        while >(modules_index, original_index) {
            variable retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, modules_index));
            variable retrieve_name = NodeRetrieveData.>name(retrieve_data);
            variable module_name_with_parents = concatenate2_brk_allocate(prepended_to_name, retrieve_name);

            variable module_id = if string=(module_name_with_parents, "This") {
                whole_8.cast(autobuffer_stack8_peek(&(module_stack)))
            } else {
                whole_8.cast(hashmap_string_get2(define_values, module_name_with_parents))
            };

            variable module_id_buffer = any_24.>0();

            whole_8_to_string(module_id, &(module_id_buffer));

            prepended_to_name = copy_string_brk_allocate(&(module_id_buffer));

            nodes_set_skip(nodes, modules_index);

            modules_index = -(modules_index, 1);
        };

        variable_name = concatenate2_brk_allocate(prepended_to_name, variable_name);
        NodeRetrieveData.<name(retrieve_data, variable_name);
    };

    variable define_types = &(ProgramData.>define_types(program_data));

    variable_type = get_type_of_define(define_types, define_values, variable_name);

    if !(=(variable_type, 0)) {
        autobuffer_stack8_legacy_push(stack, stack_pointer, variable_type);
        return;
    } else {
        variable_type = get_type_of_define(define_types, define_values, +(variable_name, 1));
        if !(=(variable_type, 0)) {
            NodeRetrieveData.<name(retrieve_data, +(variable_name, 1));
            autobuffer_stack8_legacy_push(stack, stack_pointer, concatenate2_brk_allocate("*", variable_type));
            return;
        };

        if NodeRetrieveData.>is_module(retrieve_data) {
            autobuffer_stack8_legacy_push(stack, stack_pointer, variable_name);
        } else {
            print_node_error_beginning(nodes, nodes_index);
            print("Retrieve target '");
            print(variable_name);
            println("' not found");
            exit(1);
        };
    };
};

define process_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, pointer_data: *) {
    variable invoke_data = NodeInvokeData.*cast(pointer_data);
    variable is_pointer2 = NodeInvokeData.>is_pointer(invoke_data);

    if &&(is_pointer(nodes, +(nodes_index, 1)), !(=(NodeInvokeData.>name(invoke_data), 0))) {
        NodeInvokeData.<name(invoke_data, concatenate2_brk_allocate("*", NodeInvokeData.>name(invoke_data)));
    };

    if is_pointer2 {
        process_invoke_pointer(nodes, nodes_index, stack, stack_pointer, program_data, pointer_data);
    } else {
        variable has_specifier = NodeInvokeData.>has_specifier(invoke_data);
        variable function_name = NodeInvokeData.>name(invoke_data);

        if &&(!(has_specifier), string=(function_name, "+")) {
            process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "+");
        } else if &&(!(has_specifier), string=(function_name, "-")) {
            process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "-");
        } else if &&(!(has_specifier), string=(function_name, "*")) {
            process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "*");
        } else if &&(!(has_specifier), string=(function_name, "/")) {
            process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "/");
        } else if &&(!(has_specifier), string=(function_name, "%")) {
            process_math_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "%");
        } else if &&(!(has_specifier), string=(function_name, "=")) {
            process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "=");
        } else if &&(!(has_specifier), string=(function_name, ">")) {
            process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, ">");
        } else if &&(!(has_specifier), string=(function_name, "<")) {
            process_comparison_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data, "<");
        } else if &&(has_specifier, |(string=(function_name, "cast"), string=(function_name, "*cast"))) {
            process_cast(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data);
        } else {
            process_internal_invoke(nodes, nodes_index, stack, stack_pointer, program_data, invoke_data);
        };
    };
};

define process_cast = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, invoke_data: *NodeInvokeData) {
    variable function_name = NodeInvokeData.>name(invoke_data);

    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        println("Cast ran out of stack values");
        exit(1);
    };

    variable to_push = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    if string=(function_name, "*cast") {
        to_push = concatenate2_brk_allocate("*", to_push);
    };

    variable popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    variable size_function = ProgramData.>get_size(program_data);
    if !(=(size_function(popped, nodes, program_data), size_function(to_push, nodes, program_data))) {
        print_node_error_beginning(nodes, nodes_index);
        print("Cast wants equal sized types, given '");
        print(popped);
        print("' and casts to '");
        print(to_push);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, to_push);

    nodes_set_skip(nodes, -(nodes_index, 1));
};

define process_internal_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, invoke_data: *NodeInvokeData) {
    variable function_name = NodeInvokeData.>name(invoke_data);
    variable has_specifier = NodeInvokeData.>has_specifier(invoke_data);
    variable found_function = false;

    if has_specifier {
        variable popped = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

        function_name = concatenate2_brk_allocate(popped, function_name);
        NodeInvokeData.<name(invoke_data, function_name);
        NodeInvokeData.<has_specifier(invoke_data, false);

        nodes_set_skip(nodes, -(nodes_index, 1));
    };

    variable internal_function_argument_types = &(ProgramData.>internal_function_argument_types(program_data));
    variable internal_function_return_types = &(ProgramData.>internal_function_return_types(program_data));

    if =(hashmap_string_get(internal_function_argument_types, function_name), 0) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke target '");
        print(function_name);
        println("' not found");
        exit(1);
    };

    variable arguments = *.cast(hashmap_string_get(internal_function_argument_types, function_name));
    variable returns = *.cast(hashmap_string_get(internal_function_return_types, function_name));

    variable arguments_length = array8_length(arguments);
    variable k = 0;
    while <(k, arguments_length) {
        if =(whole_8.>(stack_pointer), 0) {
            print_node_error_beginning(nodes, nodes_index);
            print("Invoke of '");
            print(function_name);
            println("' ran out of stack values");
            exit(1);
        };

        variable given = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
        variable wanted = *.cast(array8_get(arguments, -(-(arguments_length, k), 1)));
        if !(is_type(wanted, given, nodes, program_data)) {
            print_node_error_beginning(nodes, nodes_index);
            print("Invoke of '");
            print(function_name);
            print("' wants '");
            print(wanted);
            print("', given '");
            print(given);
            println("'");
            exit(1);
        };

        k = +(k, 1);
    };

    variable k = 0;
    while !(=(array8_get(returns, k), 0)) {
        variable structure_datas = &(ProgramData.>structure_datas(program_data));
        variable define_types = &(ProgramData.>define_types(program_data));
        variable define_values = &(ProgramData.>define_values(program_data));

        variable return_value = *.cast(array8_get(returns, k));

        variable is_pointer = &&(string_length=(return_value, "*", 1), >(length(return_value), 1));
        if is_pointer {
            return_value = +(return_value, 1);
        };

        if is_define(return_value) {
            variable structure_id = whole_8.cast(get_value_of_define(define_types, define_values, return_value));
            variable structure_data = NodeStructureData.*cast(autobuffer_stack8_get(structure_datas, structure_id));
            return_value = get_structure_string_type(structure_data);
        };

        if is_pointer {
            return_value = concatenate2_brk_allocate("*", return_value);
        };

        autobuffer_stack8_legacy_push(stack, stack_pointer, return_value);

        k = +(k, 1);
    };
};

define process_math_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, invoke_data: *NodeInvokeData, math_name: *) {
    if <(whole_8.>(stack_pointer), 2) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(math_name);
        println("' ran out of stack values");
        exit(1);
    };

    variable first = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    variable second = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    // removed signdness check -- probably need to add it back
    variable size_function = ProgramData.>get_size(program_data);
    if !(=(size_function(first, nodes, program_data), size_function(second, nodes, program_data))) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(math_name);
        print("' wants matching arguments, given '");
        print(first);
        print("' and '");
        print(second);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, second);

    variable new_+_name = autobuffer_new(16);
    autobuffer_set(&(new_+_name), concatenate2_brk_allocate(math_name, "_"), 0, 2);
    autobuffer_set(&(new_+_name), first, 2, length(first));

    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
};

define process_comparison_invoke = function(nodes: *Nodes, nodes_index: whole_8, stack: *AutoBuffer, stack_pointer: *whole_8, program_data: *ProgramData, invoke_data: *NodeInvokeData, comparison_name: *) {
    if =(whole_8.>(stack_pointer), 0) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(comparison_name);
        println("' ran out of stack values");
        exit(1);
    };

    variable first = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));
    variable second = *.cast(autobuffer_stack8_legacy_pop(stack, stack_pointer));

    variable size_function = ProgramData.>get_size(program_data);
    if !(=(size_function(first, nodes, program_data), size_function(second, nodes, program_data))) {
        print_node_error_beginning(nodes, nodes_index);
        print("Invoke of '");
        print(comparison_name);
        print("' has incompatable arguments, given '");
        print(first);
        print("' and '");
        print(second);
        println("'");
        exit(1);
    };

    autobuffer_stack8_legacy_push(stack, stack_pointer, "boolean");

    variable new_+_name = autobuffer_new(16);
    autobuffer_set(&(new_+_name), concatenate2_brk_allocate(comparison_name, "_"), 0, 2);
    autobuffer_set(&(new_+_name), first, 2, length(first));

    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
};

define setup_process = function(nodes: *Nodes, program_data: *ProgramData) {
    variable node_count = Nodes.>index(nodes);

    variable declared_function_id = 0;
    variable declared_structure_id = 0;
    variable declared_global_id = 0;
    variable declared_module_id = 0;

    variable i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            variable function_data = NodeFunctionData.*cast(pointer_data);
            variable function_name = NodeFunctionData.>name(function_data);
            
            if !(=(function_name, 0)) {
                variable internal_function_argument_types = &(ProgramData.>internal_function_argument_types(program_data));
                variable internal_function_argument_names = &(ProgramData.>internal_function_argument_names(program_data));
                variable internal_function_return_types = &(ProgramData.>internal_function_return_types(program_data));

                hashmap_string_put(internal_function_argument_types, function_name, NodeFunctionData.>argument_types(function_data));
                hashmap_string_put(internal_function_argument_names, function_name, NodeFunctionData.>argument_names(function_data));
                hashmap_string_put(internal_function_return_types, function_name, NodeFunctionData.>returns(function_data));
            } else {
                // probably should check for duplicate functions
                variable function_locations = &(ProgramData.>function_locations(program_data));
                variable function_datas = &(ProgramData.>function_datas(program_data));
                variable function_argument_names = &(ProgramData.>function_argument_names(program_data));
                variable function_argument_types = &(ProgramData.>function_argument_types(program_data));
                variable function_return_types = &(ProgramData.>function_return_types(program_data));

                autobuffer_array8_set(function_locations, declared_function_id, i);
                autobuffer_array8_set(function_datas, declared_function_id, function_data);
                autobuffer_array8_set(function_argument_types, declared_function_id, NodeFunctionData.>argument_types(function_data));
                autobuffer_array8_set(function_argument_names, declared_function_id, NodeFunctionData.>argument_names(function_data));
                autobuffer_array8_set(function_return_types, declared_function_id, NodeFunctionData.>returns(function_data));
                declared_function_id = +(declared_function_id, 1);
            };
        };

        if =(id, NODE_STRUCTURE) {
            variable structure_data = NodeStructureData.*cast(pointer_data);

            if =(NodeStructureData.>name(structure_data), 0) {
                variable structure_member_types = &(ProgramData.>structure_member_types(program_data));
                variable structure_members_names = &(ProgramData.>structure_member_names(program_data));
                autobuffer_array8_set(structure_member_types, declared_structure_id, NodeStructureData.>item_types(structure_data));
                autobuffer_array8_set(structure_members_names, declared_structure_id, NodeStructureData.>item_names(structure_data));

                variable structure_name = get_structure_string_type(structure_data);
                NodeStructureData.<name(structure_data, structure_name);

                declared_structure_id = +(declared_structure_id, 1);
            };

            variable structure_datas = &(ProgramData.>structure_datas(program_data));
            autobuffer_stack8_push(structure_datas, structure_data);
        };

        if =(id, NODE_GLOBAL) {
            variable global_data = NodeGlobalData.*cast(pointer_data);
            variable global_name = NodeGlobalData.>name(global_data);
            variable global_type = NodeGlobalData.>type(global_data);

            variable global_types = &(ProgramData.>global_types(program_data));
            autobuffer_array8_set(global_types, declared_global_id, global_type);
            declared_global_id = +(declared_global_id, 1);
        };

        if =(id, NODE_MODULE) {
            declared_module_id = +(declared_module_id, 1);
        };

        if =(id, NODE_DEFINE) {
            variable define_data = NodeDefineData.*cast(pointer_data);
            variable define_name = NodeDefineData.>name(define_data);
            variable define_type = NodeDefineData.>type(define_data);

            define_name = get_define_name_with_module(define_name);
            NodeDefineData.<name(define_data, define_name);

            variable define_value: any_8;
            if string_length=(define_type, "*function", 9) {
                variable function_datas = ProgramData.>function_datas(program_data);
                define_value = declared_function_id;
            } else if string_length=(define_type, "structure", 9) {
                define_value = declared_structure_id;
            } else if string_length=(define_type, "global", 6) {
                define_value = declared_global_id;
            } else if string_length=(define_type, "module", 6) {
                define_value = declared_module_id;
                autobuffer_stack8_push(&(module_stack), declared_module_id);
            } else if string=(define_type, "define") {
                variable values_buffer = autobuffer_stack8_new(24);

                variable value_index = +(i, 1);
                while =(nodes_get_id(nodes, value_index), NODE_RETRIEVE) {
                    variable retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, value_index));
                    autobuffer_stack8_push(&(values_buffer), NodeRetrieveData.>name(retrieve_data));
                    value_index = +(value_index, 1);
                };

                define_value = autobuffer_stack8_get_buffer_pointer(&(values_buffer));
            } else {
                define_value = NodeNumberData.>value(NodeNumberData.*cast(nodes_get_pointer_data(nodes, +(i, 1))));
            };

            variable define_types = &(ProgramData.>define_types(program_data));
            hashmap_string_put(define_types, define_name, define_type);

            variable define_values = &(ProgramData.>define_values(program_data));
            hashmap_string_put(define_values, define_name, define_value);
        };

        if =(id, NODE_ENDDEFINE) {
            variable define_data = NodeEndDefineData.*cast(pointer_data);
            variable define_type = NodeEndDefineData.>type(define_data);

            if =(define_type, 0) {
            } else if string=(define_type, "module") {
                variable _ = autobuffer_stack8_pop(&(module_stack));
            };
        };

        i = +(i, 1);
    };

};

define is_pointer = function(nodes: *Nodes, index_in: whole_8): boolean {
    variable index = index_in;
    while |(|(|(=(nodes_get_id(nodes, index), NODE_POINTER), =(nodes_get_id(nodes, index), NODE_SKIP)), &&(=(nodes_get_id(nodes, index), NODE_RETRIEVE), NodeRetrieveData.>is_module(NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, index))))), &&(=(nodes_get_id(nodes, index), NODE_INVOKE), NodeInvokeData.>is_pointer(NodeInvokeData.*cast(nodes_get_pointer_data(nodes, index))))) {
        if =(nodes_get_id(nodes, index), NODE_POINTER) {
            return true;
        };
        index = +(index, 1);
    };
    return false;
};


define get_define_name_with_module = function(define_name: *): * {
    variable new_define_name = "";

    variable i = -(AutoBufferStack8.>index(&(module_stack)), 1);
    if >(AutoBufferStack8.>index(&(module_stack)), 0) {
        variable module_id = whole_8.cast(autobuffer_stack8_peek(&(module_stack)));
        variable module_id_buffer = any_24.>0();
        whole_8_to_string(module_id, &(module_id_buffer));

        new_define_name = copy_string_brk_allocate(&(module_id_buffer));
    };

    return concatenate2_brk_allocate(new_define_name, define_name);
};
