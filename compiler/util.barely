// probably should be able to just declare the number as whole_1
define ASCII = module {
    define TAB: whole_1 = 9;
    define LINE_FEED: whole_1 = 10;
    define SPACE: whole_1 = 32;
    define QUOTATION: whole_1 = 34;
    define OPEN_PARENTHESIS: whole_1 = 40;
    define CLOSED_PARENTHESIS: whole_1 = 41;
    define ASTERISK: whole_1 = 42;
    define COMMA: whole_1 = 44;
    define MINUS: whole_1 = 45;
    define PERIOD: whole_1 = 46;
    define SLASH: whole_1 = 47;
    define ZERO: whole_1 = 48;
    define NINE: whole_1 = 57;
    define COLON: whole_1 = 58;
    define SEMICOLON: whole_1 = 59;
    define LESS_THAN: whole_1 = 60;
    define GREATER_THAN: whole_1 = 62;
    define OPEN_BRACKET: whole_1 = 91;
    define CLOSED_BRACKET: whole_1 = 93;
    define UNDERSCORE: whole_1 = 95;
    define OPEN_CURLY_BRACKETS: whole_1 = 123;
    define CLOSED_CURLY_BRACKETS: whole_1 = 125;
};

define is_number = function(string: *): boolean {
    declare length2 = length(string);

    declare has_number = false;
    declare i = 0;
    while <(i, length2) {
        declare character = whole_1.>(whole_1.*cast(+(string, i)));

        if &&(=(character, ASCII.UNDERSCORE), >(i, 0)) {
            break;
            character = ASCII.ZERO;
        };

        if =(character, ASCII.MINUS) {
        } else if <(character, ASCII.ZERO) {
            return false;
        } else if >(character, ASCII.NINE) {
            return false;
        } else {
            has_number = true;
        };

        i = +(i, 1);
    };

    return has_number;
};

define string_to_whole_8 = function(string: *): whole_8 {
    return string_to_number(string, 8, false);
};

define string_to_number = function(string: *, size: whole_8, signed: boolean): whole_8 {
    declare length2 = length(string);

    declare whole_8 = 0;

    declare has_negative = false;

    declare i = 0;
    while <(i, length2) {
        declare character = whole_1.>(whole_1.*cast(+(string, i)));

        if =(character, ASCII.UNDERSCORE) {
            break;
        } else {
            if =(character, ASCII.MINUS) {
                has_negative = true;
            } else {
                whole_8 = *(whole_8, 10);
                whole_8 = +(whole_8, whole_1_to_whole_8(-(character, ASCII.ZERO)));
            };
            i = +(i, 1);
        };
    };

    if has_negative {
        if =(size, 8) {
            return -(0, whole_8);
        } else if =(size, 4) {
            return whole_4_to_whole_8(-(0:whole_4, whole_8_to_whole_4(whole_8)));
        } else if =(size, 2) {
            return whole_2_to_whole_8(-(0:whole_2, whole_8_to_whole_2(whole_8)));
        } else if =(size, 1) {
            return whole_1_to_whole_8(-(0:whole_1, whole_8_to_whole_1(whole_8)));
        };
    };
    return whole_8;
};

define whole_8_to_string = function(whole_8: whole_8, buffer: *) {
    declare whole_82 = whole_8;

    if =(whole_8, 0) {
        any_1.<(any_1.*cast(buffer), ASCII.ZERO);
    };

    declare length = 0;
    while !(=(whole_82, 0)) {
        whole_82 = /(whole_82, 10);
        length = +(length, 1);
    };

    whole_82 = whole_8;

    declare i = 0;
    while !(=(whole_82, 0)) {
        declare number = whole_8_to_whole_1(%(whole_82, 10));
        any_1.<(any_1.*cast(+(buffer, -(-(length, 1), i))), +(number, ASCII.ZERO));
        whole_82 = /(whole_82, 10);
        i = +(i, 1);
    };
};

define decrement_whole_8_pointer = function(pointer: *whole_8, amount: whole_8) {
    whole_8.<(pointer, -(whole_8.>(pointer), amount));
};

define stringarray_get = function(keys: *, values: *, wanted: *, size: whole_8): * {
    declare j = 0;
    while <(j, size) {
        if string=(*.cast(array8_get(keys, j)), wanted) {
            return *.cast(array8_get(values, j));
        };
        j = +(j, 1);
    };

    return *.cast(0);
};

define stringarray_get_index = function(keys: *, wanted: *, size: whole_8): whole_8 {
    declare j = 0;
    while <(j, size) {
        if string=(*.cast(array8_get(keys, j)), wanted) {
            return j;
        };
        j = +(j, 1);
    };

    return 999;
};

define print = function(string: *) {
    print_stdout(string, length(string));
};

define println = function(string: *) {
    print(string);

    declare new_line: whole_8 = 10;
    print_stdout(&(new_line), 1);
};

define array8_set = function(array: *, index: whole_8, value: any_8) {
    declare index_pointer = any_8.*cast(+(array, *(index, 8)));
    any_8.<(index_pointer, value);
};

define array8_get = function(array: *, index: whole_8): any_8 {
    declare index_pointer = any_8.*cast(+(array, *(index, 8)));
    return any_8.>(index_pointer);
};

define array8_length = function(array: *): whole_8 {
    declare k = 0;
    while !(=(array8_get(array, k), 0)) {
        k = +(k, 1);
    };
    return k;
};

define autobuffer_stack8_legacy_push = function(buffer: *AutoBuffer, stack_pointer: *whole_8, value: any_8) {
    autobuffer_set_whole_8(buffer, whole_8.cast(value), *(whole_8.>(stack_pointer), 8));
    increment_whole_8_pointer(stack_pointer, 1);
};

define autobuffer_stack8_legacy_pop = function(buffer: *AutoBuffer, stack_pointer: *whole_8): any_8 {
    decrement_whole_8_pointer(stack_pointer, 1);
    declare index_pointer = any_8.*cast(autobuffer_get(buffer, *(whole_8.>(stack_pointer), 8)));
    return any_8.>(index_pointer);
};

define autobuffer_stringarray_get_index = function(keys: *AutoBuffer, wanted: *, size: whole_8): whole_8 {
    declare j = 0;
    while <(j, size) {
        if string=(*.cast(autobuffer_array8_get(keys, j)), wanted) {
            return j;
        };
        j = +(j, 1);
    };

    return 999;
};

define print_whole_8 = function(whole_8: whole_8) {
    declare buffer = any_24.>0();
    whole_8_to_string(whole_8, &(buffer));
    print(&(buffer));
};

define HashMap = structure {
    buffer: AutoBuffer;
};

define BucketData = structure {
    data: whole_8;
    hash: whole_8;
    value: any_8;
};

define hashmap_new = function(size: whole_8): HashMap {
    declare hashmap: HashMap;

    declare buffer = autobuffer_new(size);

    HashMap.<buffer(&(hashmap), buffer);

    return hashmap;
};

define hashmap_put = function(hashmap: *HashMap, hash: whole_8, value: any_8) {
    declare buffer = &(HashMap.>buffer(hashmap));

    declare bucket_pointer = AutoBuffer.*cast(autobuffer_get_any_8(buffer, *(%(hash, /(AutoBuffer.>size(buffer), 8)), 8)));
    if =(bucket_pointer, 0) {
        declare allocated_autobuffer = AutoBuffer.*cast(brk_allocate(24));
        declare autobuffer = autobuffer_new(48);
        AutoBuffer.<(allocated_autobuffer, autobuffer);

        bucket_pointer = allocated_autobuffer;
        autobuffer_set_any_8(buffer, bucket_pointer, *(%(hash, /(AutoBuffer.>size(buffer), 8)), 8));
    };

    declare searching = true;
    declare i = 0;
    while searching {
        if =(autobuffer_get_any_8(bucket_pointer, *(i, 24)), 0) {
            searching = false;
        } else if =(autobuffer_get_any_8(bucket_pointer, +(*(i, 24), 8)), hash) {
            searching = false;
        } else {
            i = +(i, 1);
        };
    };

    declare bucket_data = BucketData.*cast(autobuffer_get_size(bucket_pointer, *(i, 24), 24));
    BucketData.<data(bucket_data, 1);
    BucketData.<hash(bucket_data, hash);
    BucketData.<value(bucket_data, value);
};

define hashmap_get = function(hashmap: *HashMap, hash: whole_8): any_8 {
    declare buffer = &(HashMap.>buffer(hashmap));

    declare bucket_pointer = AutoBuffer.*cast(autobuffer_get_any_8(buffer, *(%(hash, /(AutoBuffer.>size(buffer), 8)), 8)));
    if !(=(bucket_pointer, 0)) {
        declare i = 0;
        while !(=(autobuffer_get_any_8(bucket_pointer, *(i, 24)), 0)) {
            declare bucket_data = BucketData.*cast(autobuffer_get_size(bucket_pointer, *(i, 24), 24));

            if =(BucketData.>hash(bucket_data), hash) {
                return BucketData.>value(bucket_data);
            };

            i = +(i, 1);
        };
    };

    return 0;
};

define hashmap_get2 = function(hashmap: *HashMap, hash: whole_8): any_8 {
    declare buffer = &(HashMap.>buffer(hashmap));

    declare bucket_pointer = AutoBuffer.*cast(autobuffer_get_any_8(buffer, *(%(hash, /(AutoBuffer.>size(buffer), 8)), 8)));
    if !(=(bucket_pointer, 0)) {
        declare i = 0;
        while !(=(autobuffer_get_any_8(bucket_pointer, *(i, 24)), 0)) {
            declare bucket_data = BucketData.*cast(autobuffer_get_size(bucket_pointer, *(i, 24), 24));

            if =(BucketData.>hash(bucket_data), hash) {
                return BucketData.>value(bucket_data);
            };

            i = +(i, 1);
        };
    };

    return 999;
};

define hashmap_string_put = function(hashmap: *HashMap, string: *, value: any_8) {
    hashmap_put(hashmap, string_hash(string), value);
};

define hashmap_string_get = function(hashmap: *HashMap, string: *): any_8 {
    return hashmap_get(hashmap, string_hash(string));
};

define hashmap_string_get2 = function(hashmap: *HashMap, string: *): any_8 {
    return hashmap_get2(hashmap, string_hash(string));
};

define string_hash = function(string: *): whole_8 {
    declare hash = 5381;
    declare i = 0;
    while <(i, length(string)) {
        declare character = whole_1_to_whole_8(whole_1.cast(any_1.>(+(any_1.*cast(string), i))));
        //hash = +(+(hash, *(hash, character)), *(character, i));
        hash = +(*(hash, 33), character);
        i = +(i, 1);
    };

    return hash;
};

define concatenate2_brk_allocate = function(string1: *, string2: *): * {
    declare string1_length = length(string1);
    declare string2_length = length(string2);
    declare new_string = brk_allocate(+(+(string1_length, string2_length), 1));

    copy(string1, new_string, string1_length);
    copy(string2, +(new_string, string1_length), string2_length);

    return new_string;
};

define concatenate3_brk_allocate = function(string1: *, string2: *, string3: *): * {
    declare string1_length = length(string1);
    declare string2_length = length(string2);
    declare string3_length = length(string3);
    declare new_string = brk_allocate(+(+(+(string1_length, string2_length), string3_length), 1));

    copy(string1, new_string, string1_length);
    copy(string2, +(new_string, string1_length), string2_length);
    copy(string3, +(+(new_string, string1_length), string2_length), string3_length);

    return new_string;
};

define concatenate4_brk_allocate = function(string1: *, string2: *, string3: *, string4: *): * {
    declare string1_length = length(string1);
    declare string2_length = length(string2);
    declare string3_length = length(string3);
    declare string4_length = length(string4);
    declare new_string = brk_allocate(+(+(+(+(string1_length, string2_length), string3_length), string4_length), 1));

    copy(string1, new_string, string1_length);
    copy(string2, +(new_string, string1_length), string2_length);
    copy(string3, +(+(new_string, string1_length), string2_length), string3_length);
    copy(string4, +(+(+(new_string, string1_length), string2_length), string3_length), string4_length);

    return new_string;
};

define substring_brk_allocate = function(string: *, start: whole_8, end: whole_8): * {
    declare substring = brk_allocate(+(-(end, start), 1));
    copy(+(string, start), substring, -(end, start));

    return substring;
};

define nth_index = function(string: *, character: any_1, n: whole_8): whole_8 {
    declare i = 0;
    declare count = 0;
    while <(i, length(string)) {
        if =(any_1.>(any_1.*cast(+(string, i))), character) {
            if =(count, n) {
                return i;
            };
            count = +(count, 1);
        };
        i = +(i, 1);
    };

    return 999;
};

define first_index = function(string: *, character: any_1): whole_8 {
    return nth_index(string, character, 0);
};

define create_size_zero_array8_brk_allocate = function(): * {
    return brk_allocate(8);
};

define create_size_one_array8_brk_allocate = function(item: any_8): * {
    declare array = brk_allocate(16);
    array8_set(array, 0, item);
    return array;
};

define create_size_two_array8_brk_allocate = function(item1: any_8, item2: any_8): * {
    declare array = brk_allocate(24);
    array8_set(array, 0, item1);
    array8_set(array, 1, item2);
    return array;
};

define create_size_three_array8_brk_allocate = function(item1: any_8, item2: any_8, item3: any_8): * {
    declare array = brk_allocate(32);
    array8_set(array, 0, item1);
    array8_set(array, 1, item2);
    array8_set(array, 2, item3);
    return array;
};

define create_size_four_array8_brk_allocate = function(item1: any_8, item2: any_8, item3: any_8, item4: any_8): * {
    declare array = brk_allocate(40);
    array8_set(array, 0, item1);
    array8_set(array, 1, item2);
    array8_set(array, 2, item3);
    array8_set(array, 3, item4);
    return array;
};

define create_size_five_array8_brk_allocate = function(item1: any_8, item2: any_8, item3: any_8, item4: any_8, item5: any_8): * {
    declare array = brk_allocate(48);
    array8_set(array, 0, item1);
    array8_set(array, 1, item2);
    array8_set(array, 2, item3);
    array8_set(array, 3, item4);
    array8_set(array, 4, item5);
    return array;
};

define create_size_six_array8_brk_allocate = function(item1: any_8, item2: any_8, item3: any_8, item4: any_8, item5: any_8, item6: any_8): * {
    declare array = brk_allocate(56);
    array8_set(array, 0, item1);
    array8_set(array, 1, item2);
    array8_set(array, 2, item3);
    array8_set(array, 3, item4);
    array8_set(array, 4, item5);
    array8_set(array, 5, item6);
    return array;
};

define create_size_seven_array8_brk_allocate = function(item1: any_8, item2: any_8, item3: any_8, item4: any_8, item5: any_8, item6: any_8, item7: any_8): * {
    declare array = brk_allocate(64);
    array8_set(array, 0, item1);
    array8_set(array, 1, item2);
    array8_set(array, 2, item3);
    array8_set(array, 3, item4);
    array8_set(array, 4, item5);
    array8_set(array, 5, item6);
    array8_set(array, 6, item7);
    return array;
};

define copy_string_brk_allocate = function(string: *): * {
    declare string_length = length(string);
    declare new_string = brk_allocate(+(string_length, 1));
    copy(string, new_string, string_length);
    return new_string;
};

define AutoBufferBuffer = structure {
    autobuffer: AutoBuffer;
    index: whole_8;
};

define autobuffer_buffer_new = function(size: whole_8): AutoBufferBuffer {
    declare autobuffer_buffer = AutoBufferBuffer.>0();
    AutoBufferBuffer.<autobuffer(&(autobuffer_buffer), autobuffer_new(size));
    return autobuffer_buffer;
};

define autobuffer_buffer_push_string = function(buffer: *AutoBufferBuffer, string: *) {
    autobuffer_buffer_push_string_length(buffer, string, length(string));
};

define autobuffer_buffer_push_string_length = function(buffer: *AutoBufferBuffer, string: *, length: whole_8) {
    declare autobuffer = &(AutoBufferBuffer.>autobuffer(buffer));
    declare buffer_index = AutoBufferBuffer.>index(buffer);

    autobuffer_register(autobuffer, buffer_index, +(length, 1));
    autobuffer_set(autobuffer, string, buffer_index, length);

    AutoBufferBuffer.<index(buffer, +(buffer_index, length));
};

define autobuffer_buffer_string_push_whole_8 = function(buffer: *AutoBufferBuffer, whole_8: whole_8) {
    declare whole_8_buffer = any_24.>0();
    whole_8_to_string(whole_8, &(whole_8_buffer));
    autobuffer_buffer_push_string(buffer, &(whole_8_buffer));
};

define autobuffer_buffer_get_buffer_pointer = function(buffer: *AutoBufferBuffer): * {
    return AutoBuffer.>buffer(&(AutoBufferBuffer.>autobuffer(buffer)));
};

define autobuffer_buffer_reset = function(buffer: *AutoBufferBuffer) {
    declare actual_buffer = autobuffer_buffer_get_buffer_pointer(buffer);
    declare size = AutoBuffer.>size(&(AutoBufferBuffer.>autobuffer(buffer)));
    declare i = 0;
    while <(i, size) {
        declare done_anything = false;
        
        if <(+(i, 8), size) {
            any_8.<(any_8.*cast(+(actual_buffer, i)), 0);
            i = +(i, 1);
            done_anything = true;
        };

        if !(done_anything) {
            any_1.<(any_1.*cast(+(actual_buffer, i)), 0:whole_1);
            i = +(i, 1);
        };
    };

    AutoBufferBuffer.<index(buffer, 0);
};

define autobuffer_buffer_push_whole_1 = function(buffer: *AutoBufferBuffer, whole_1: whole_1) {
    declare buffer_index = AutoBufferBuffer.>index(buffer);

    autobuffer_set(&(AutoBufferBuffer.>autobuffer(buffer)), &(whole_1), buffer_index, 1);

    AutoBufferBuffer.<index(buffer, +(buffer_index, 1));
};

define autobuffer_buffer_push_whole_2 = function(buffer: *AutoBufferBuffer, whole_2: whole_2) {
    declare buffer_index = AutoBufferBuffer.>index(buffer);

    autobuffer_set(&(AutoBufferBuffer.>autobuffer(buffer)), &(whole_2), buffer_index, 2);

    AutoBufferBuffer.<index(buffer, +(buffer_index, 2));
};

define autobuffer_buffer_push_whole_4 = function(buffer: *AutoBufferBuffer, whole_4: whole_4) {
    declare buffer_index = AutoBufferBuffer.>index(buffer);

    autobuffer_set(&(AutoBufferBuffer.>autobuffer(buffer)), &(whole_4), buffer_index, 4);

    AutoBufferBuffer.<index(buffer, +(buffer_index, 4));
};

define autobuffer_buffer_push_whole_8 = function(buffer: *AutoBufferBuffer, whole_8: whole_8) {
    declare buffer_index = AutoBufferBuffer.>index(buffer);

    autobuffer_set(&(AutoBufferBuffer.>autobuffer(buffer)), &(whole_8), buffer_index, 8);

    AutoBufferBuffer.<index(buffer, +(buffer_index, 8));
};

define AutoBufferStack8 = structure {
    autobuffer: AutoBuffer;
    index: whole_8;
};

define autobuffer_stack8_new = function(size: whole_8): AutoBufferStack8 {
    declare autobuffer_buffer = AutoBufferStack8.>0();
    AutoBufferStack8.<autobuffer(&(autobuffer_buffer), autobuffer_new(size));
    return autobuffer_buffer;
};

define autobuffer_stack8_push = function(buffer: *AutoBufferStack8, value: any_8) {
    declare index = AutoBufferStack8.>index(buffer);
    autobuffer_register(&(AutoBufferStack8.>autobuffer(buffer)), +(*(index, 8), 8), 8);
    autobuffer_set_whole_8(&(AutoBufferStack8.>autobuffer(buffer)), whole_8.cast(value), *(index, 8));
    AutoBufferStack8.<index(buffer, +(index, 1));
};

define autobuffer_stack8_pop = function(buffer: *AutoBufferStack8): any_8 {
    declare index = AutoBufferStack8.>index(buffer);
    index = -(index, 1);

    declare index_pointer = any_8.*cast(autobuffer_get(&(AutoBufferStack8.>autobuffer(buffer)), *(index, 8)));

    AutoBufferStack8.<index(buffer, index);
    return any_8.>(index_pointer);
};

define autobuffer_stack8_peek = function(buffer: *AutoBufferStack8): any_8 {
    declare index = AutoBufferStack8.>index(buffer);
    index = -(index, 1);

    declare index_pointer = any_8.*cast(autobuffer_get(&(AutoBufferStack8.>autobuffer(buffer)), *(index, 8)));
    return any_8.>(index_pointer);
};

define autobuffer_stack8_get = function(buffer: *AutoBufferStack8, index: whole_8): any_8 {
    declare index_pointer = any_8.*cast(autobuffer_get(&(AutoBufferStack8.>autobuffer(buffer)), *(index, 8)));
    return any_8.>(index_pointer);
};

define autobuffer_stack8_reset = function(buffer: *AutoBufferStack8) {
    declare actual_buffer = autobuffer_stack8_get_buffer_pointer(buffer);
    declare size = AutoBuffer.>size(&(AutoBufferStack8.>autobuffer(buffer)));
    declare i = 0;
    while <(i, size) {
        declare done_anything = false;
        
        if <(+(i, 8), size) {
            any_8.<(any_8.*cast(+(actual_buffer, i)), 0:whole_8);
            i = +(i, 1);
            done_anything = true;
        };

        if !(done_anything) {
            any_1.<(any_1.*cast(+(actual_buffer, i)), 0:whole_1);
            i = +(i, 1);
        };
    };

    AutoBufferStack8.<index(buffer, 0);
};

define autobuffer_stack8_get_buffer_pointer = function(buffer: *AutoBufferStack8): * {
    return AutoBuffer.>buffer(&(AutoBufferStack8.>autobuffer(buffer)));
};

define to_type_array = function(type: *): * {
    declare new_array = autobuffer_new(24);
    declare new_array_index = 0;

    declare buffer = autobuffer_buffer_new(24);

    declare i = 0;
    while <(i, length(type)) {
        declare character_pointer = +(type, i);
        
        if string_length=(character_pointer, ".", 1) {
            if >(AutoBufferBuffer.>index(&(buffer)), 0) {
                autobuffer_array8_set(&(new_array), new_array_index, copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(buffer))));
                new_array_index = +(new_array_index, 1);
                autobuffer_buffer_reset(&(buffer));
            };
        } else {
            autobuffer_buffer_push_string_length(&(buffer), character_pointer, 1);
        };

        i = +(i, 1);
    };

    if >(AutoBufferBuffer.>index(&(buffer)), 0) {
        autobuffer_array8_set(&(new_array), new_array_index, copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(buffer))));
        new_array_index = +(new_array_index, 1);
    };

    return AutoBuffer.>buffer(&(new_array));
};

define string_to_function_data = function(type: *): NodeFunctionData {
    declare argument_types = autobuffer_stack8_new(24);
    declare return_types = autobuffer_stack8_new(24);

    declare argument_index = 0;
    declare return_index = 0;

    declare inside = 0;
    declare is_return = false;
    declare buffer = autobuffer_buffer_new(24);
    declare i = 10;
    while <(i, length(type)) {
        declare character_pointer = +(type, i);
        
        if &&(=(inside, 0), |(string_length=(character_pointer, ":", 1), &&(string_length=(character_pointer, ",", 1), !(is_return)))) {
            if >(AutoBufferBuffer.>index(&(buffer)), 0) {
                autobuffer_stack8_push(&(argument_types), copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(buffer))));
                autobuffer_buffer_reset(&(buffer));
            };

            if string_length=(character_pointer, ":", 1) {
                is_return = true;
            };
        } else if &&(=(inside, 0), |(string_length=(character_pointer, "]", 1), string_length=(character_pointer, ",", 1))) {
            if >(AutoBufferBuffer.>index(&(buffer)), 0) {
                autobuffer_stack8_push(&(return_types), copy_string_brk_allocate(autobuffer_buffer_get_buffer_pointer(&(buffer))));
                autobuffer_buffer_reset(&(buffer));
            };
            if string_length=(character_pointer, "]", 1) {
                break;
            };
        } else if string_length=(character_pointer, "[", 1) {
            inside = +(inside, 1);
            autobuffer_buffer_push_string_length(&(buffer), character_pointer, 1);
        } else if string_length=(character_pointer, "]", 1) {
            inside = -(inside, 1);
            autobuffer_buffer_push_string_length(&(buffer), character_pointer, 1);
        } else {
            autobuffer_buffer_push_string_length(&(buffer), character_pointer, 1);
        };

        i = +(i, 1);
    };

    declare data = NodeFunctionData.>0();
    NodeFunctionData.<argument_types(&(data), autobuffer_stack8_get_buffer_pointer(&(argument_types)));
    NodeFunctionData.<returns(&(data), autobuffer_stack8_get_buffer_pointer(&(return_types)));

    return data;
};

define function_data_to_string_old = function(pointer: *NodeFunctionData): * {
    declare main_name_buffer = autobuffer_buffer_new(16);

    autobuffer_buffer_push_string(&(main_name_buffer), "*function[");

    declare arguments = NodeFunctionData.>argument_types(pointer);
    declare returns = NodeFunctionData.>returns(pointer);

    declare j = 0;
    while !(=(array8_get(arguments, j), 0)) {
        autobuffer_buffer_push_string(&(main_name_buffer), *.cast(array8_get(arguments, j)));
        autobuffer_buffer_push_string(&(main_name_buffer), ",");
        j = +(j, 1);
    };

    if >(j, 0) {
        AutoBufferBuffer.<index(&(main_name_buffer), -(AutoBufferBuffer.>index(&(main_name_buffer)), 1));
    };
    autobuffer_buffer_push_string(&(main_name_buffer), ":");

    declare j = 0;
    while !(=(array8_get(returns, j), 0)) {
        autobuffer_buffer_push_string(&(main_name_buffer), *.cast(array8_get(returns, j)));
        autobuffer_buffer_push_string(&(main_name_buffer), ",");
        j = +(j, 1);
    };

    if >(j, 0) {
        AutoBufferBuffer.<index(&(main_name_buffer), -(AutoBufferBuffer.>index(&(main_name_buffer)), 1));
    };
    autobuffer_buffer_push_string(&(main_name_buffer), "]");

    return autobuffer_buffer_get_buffer_pointer(&(main_name_buffer));
};

define function_data_to_string = function(pointer: *NodeFunctionData): * {
    declare main_name_buffer = autobuffer_buffer_new(16);

    autobuffer_buffer_push_string(&(main_name_buffer), "*function[");

    declare arguments = NodeFunctionData.>argument_types_array(pointer);
    declare returns = NodeFunctionData.>returns(pointer);

    declare j = 0;
    while !(=(array8_get(arguments, j), 0)) {
        declare argument_type_array = *.cast(array8_get(arguments, j));
        declare argument_type = expand_module_name_array(argument_type_array, 0, &(module_id_map), &(module_references_map), &(module_stack), create_previous_results_list());
        autobuffer_buffer_push_string(&(main_name_buffer), argument_type);
        autobuffer_buffer_push_string(&(main_name_buffer), ",");
        j = +(j, 1);
    };

    if >(j, 0) {
        AutoBufferBuffer.<index(&(main_name_buffer), -(AutoBufferBuffer.>index(&(main_name_buffer)), 1));
    };
    autobuffer_buffer_push_string(&(main_name_buffer), ":");

    declare j = 0;
    while !(=(array8_get(returns, j), 0)) {
        autobuffer_buffer_push_string(&(main_name_buffer), *.cast(array8_get(returns, j)));
        autobuffer_buffer_push_string(&(main_name_buffer), ",");
        j = +(j, 1);
    };

    if >(j, 0) {
        AutoBufferBuffer.<index(&(main_name_buffer), -(AutoBufferBuffer.>index(&(main_name_buffer)), 1));
    };
    autobuffer_buffer_push_string(&(main_name_buffer), "]");

    return autobuffer_buffer_get_buffer_pointer(&(main_name_buffer));
};

define structure_data_to_string = function(pointer: *NodeStructureData): * {
    declare main_name_buffer = autobuffer_buffer_new(16);

    autobuffer_buffer_push_string(&(main_name_buffer), "structure[");

    declare items = NodeStructureData.>item_types(pointer);
    declare item_names = NodeStructureData.>item_names(pointer);

    declare j = 0;
    while !(=(array8_get(items, j), 0)) {
        autobuffer_buffer_push_string(&(main_name_buffer), *.cast(array8_get(item_names, j)));
        autobuffer_buffer_push_string(&(main_name_buffer), ":");
        autobuffer_buffer_push_string(&(main_name_buffer), *.cast(array8_get(items, j)));
        autobuffer_buffer_push_string(&(main_name_buffer), ",");
        j = +(j, 1);
    };

    AutoBufferBuffer.<index(&(main_name_buffer), -(AutoBufferBuffer.>index(&(main_name_buffer)), 1));
    autobuffer_buffer_push_string(&(main_name_buffer), "]");

    return autobuffer_buffer_get_buffer_pointer(&(main_name_buffer));
};

define global_data_to_string = function(global_data: *NodeGlobalData): * {
    return concatenate3_brk_allocate("global[", NodeGlobalData.>type(global_data), "]");
};
