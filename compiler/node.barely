define Node = module {
    define FUNCTION = 0;
    define FunctionData = structure {
        // I find it weird how internal functions still need this but non-internal ones do not
        // Maybe this is just the best way, however, name could potentially be stored elsewhere for internals
        name: *;
        argument_names: *;
        argument_types: *;
        return_types: *;
    };

    define ENDFUNCTION = 1;

    define RETRIEVE = 2;
    define RetrieveData = structure {
        name: *;
        coercion: *;
        uses_previous: boolean;
    };

    define STRING = 3;
    define StringData = structure {
        value: *;
    };

    define NUMBER = 4;
    define NumberData = structure {
        value: whole_8;
        // array of strings
        coersion: *;
    };

    define INVOKE = 5;

    define DECLARE = 6;
    define DeclareData = structure {
        name: *;
        // array of strings
        type: *;
    };

    define ASSIGN = 7;
    define AssignData = structure {
        name: *;
        uses_previous: boolean;
    };

    define RETURN = 8;

    define STRUCTURE = 9;
    define StructureData = structure {
        name: *;
        item_names: *;
        item_types: *;
        is_internal: boolean;
    };

    define BOOLEAN = 10;
    define BooleanData = structure {
        value: boolean;
    };

    define JUMP_CONDITIONAL = 11;
    define JumpConditionalData = structure {
        target_id: whole_8;
        desired_state: boolean;
    };

    define TARGET = 12;
    define TargetData = structure {
        id: whole_8;
    };

    define JUMP = 13;
    define JumpData = structure {
        target_id: whole_8;
    };

    define DEFINE = 14;
    define DefineData = structure {
        name: *;
        type: *;
        data: *;
    };

    define INVOKE_INTERNAL = 15;
    define InvokeInternalData = structure {
        name: *;
        uses_previous: boolean;
    };

    define SCOPE = 16;

    define ENDSCOPE = 17;

    define STARTIFBLOCK = 18;

    define ENDIFBLOCK = 19;
    define EndIfBlockData = structure {
        id: whole_8;
        is_last: boolean;
        is_bare_else: boolean;
    };

    define ENDSTATEMENT = 20;

    define ENDDEFINE = 21;
    define EndDefineData = structure {
        type: *;
    };

    define SKIP = 22;

    define MODULE = 23;

    define ENDMODULE = 24;

    define SIZE = 80;

    define LocationData = structure {
        file: *;
        row: whole_8;
        column: whole_8;
    };
};

define Nodes = module {
    define Nodes = structure {
        buffer: AutoBuffer;
        index: whole_8;
    };

    define new = function(size: whole_8): .Nodes {
        declare nodes: Nodes.Nodes;
        nodes.buffer = autobuffer_new(size * Node.SIZE);
        nodes.index = 0;
        return nodes;
    };

    define get_id = function(nodes: *.Nodes, index: whole_8): whole_8 {
        return autobuffer_get_whole_8(&(.Nodes.>buffer(nodes)), *(index, Node.SIZE));
    };

    define get_pointer_data = function(nodes: *.Nodes, index: whole_8): * {
        return autobuffer_get(&(.Nodes.>buffer(nodes)), +(*(index, Node.SIZE), 32));
    };

    define get_id_pointer = function(nodes: *.Nodes, index: whole_8): *whole_8 {
        return whole_8.pcast(.get_pointer(nodes, index));
    };

    define get_location_data = function(nodes: *.Nodes, index: whole_8): *Node.LocationData {
        return Node.LocationData.pcast(autobuffer_get(&(.Nodes.>buffer(nodes)), +(*(index, Node.SIZE), 8)));
    };

    define get_pointer = function(nodes: *.Nodes, index: whole_8): * {
        return autobuffer_get(&(.Nodes.>buffer(nodes)), *(index, Node.SIZE));
    };

    define append_data = function(nodes: *.Nodes, id: whole_8, file_name: *, row: whole_8, column: whole_8): * {
        return *.cast(+(.append(nodes, id, file_name, row, column), 32));
    };

    define append_data_anonymous = function(nodes: *.Nodes, id: whole_8): * {
        return .append_data(nodes, id, "", 0, 0);
    };

    define append_anonymous = function(nodes: *.Nodes, id: whole_8): * {
        return .append(nodes, id, "", 0, 0);
    };

    define append = function(nodes: *.Nodes, id: whole_8, file_name: *, row: whole_8, column: whole_8): * {
        declare nodes_buffer = &(.Nodes.>buffer(nodes));
        declare nodes_index = &(.Nodes.>index(nodes));
        declare node_pointer = autobuffer_get_size(nodes_buffer, *(whole_8.>(nodes_index), Node.SIZE), Node.SIZE);

        declare id_pointer = .get_id_pointer(nodes, whole_8.>(nodes_index));
        whole_8.<(id_pointer, id);

        declare location_data = .get_location_data(nodes, whole_8.>(nodes_index));
        Node.LocationData.<file(location_data, file_name);
        Node.LocationData.<row(location_data, row);
        Node.LocationData.<column(location_data, column);

        increment_whole_8_pointer(nodes_index, 1);

        return node_pointer;
    };

    define set_skip = function(nodes: *.Nodes, index: whole_8) {
        .set_id(nodes, index, Node.SKIP);
    };

    define set_id = function(nodes: *.Nodes, index: whole_8, id: whole_8) {
        declare node_id = .get_id_pointer(nodes, index);
        whole_8.<(node_id, id);
    };

    define append_structure = function(nodes: *.Nodes, name: *, size: whole_8) {
        declare size_string = any_24.>0();
        whole_8_to_string(size, &(size_string));

        declare define_data = Node.DefineData.pcast(.append_data_anonymous(nodes, Node.DEFINE));
        Node.DefineData.<name(define_data, name);

        // TODO: Make this type be based on the structure data
        declare structure_type = concatenate3_brk_allocate("structure[_:any_", &(size_string), "]");
        Node.DefineData.<type(define_data, structure_type);

        declare item_names = create_size_one_array8_brk_allocate("_");
        declare item_types = create_size_one_array8_brk_allocate(#array(concatenate2_brk_allocate("any_", &(size_string))));

        declare structure_data = Node.StructureData.pcast(.append_data_anonymous(nodes, Node.STRUCTURE));
        Node.StructureData.<item_names(structure_data, item_names);
        Node.StructureData.<item_types(structure_data, item_types);

        declare _ = .append_anonymous(nodes, Node.ENDDEFINE);
    };

    define append_structure_any = function(nodes: *.Nodes, name: *) {
        declare structure_data = Node.StructureData.pcast(.append_data_anonymous(nodes, Node.STRUCTURE));
        Node.StructureData.<name(structure_data, name);
        Node.StructureData.<item_names(structure_data, &empty);
        Node.StructureData.<item_types(structure_data, &empty);
        Node.StructureData.<is_internal(structure_data, true);
    };

    define append_function = function(nodes: *.Nodes, name: *, arguments: *, returns: *) {
        declare function_data = Node.FunctionData.pcast(.append_data_anonymous(nodes, Node.FUNCTION));
        function_data.name = name;
        function_data.argument_types = arguments;
        function_data.return_types = returns;
        declare _ = .append_anonymous(nodes, Node.ENDFUNCTION);
    };

    define copy = function(nodes_from: *.Nodes, nodes_to: *.Nodes, count: whole_8) {
        autobuffer_set(&nodes_to.buffer, nodes_from.buffer.buffer, nodes_to.index * Node.SIZE, count * Node.SIZE);
        nodes_to.index = nodes_to.index + count;
    };
};

define print_node_info = function(nodes: *Nodes.Nodes, index: whole_8) {
    declare id = Nodes.get_id(nodes, index);
    declare pointer_data = Nodes.get_pointer_data(nodes, index);
    if =(id, Node.RETRIEVE) {
        declare retrieve_data = Node.RetrieveData.pcast(pointer_data);
        print("Retrieve{names=");
        //if !(=(Node.RetrieveData.>name(retrieve_data), 0)) {
        //    print("'");
        //    declare i = 0;
        //    while <(i, array8_length(Node.RetrieveData.>name(retrieve_data))) {
        //        print(*.cast(array8_get(Node.RetrieveData.>name(retrieve_data), i)));
        //        print(", ");
        //        i = +(i, 1);
        //    };
        //    print("'");
        //};
        print(",name='");
        if !(=(Node.RetrieveData.>name(retrieve_data), 0)) {
            print(Node.RetrieveData.>name(retrieve_data));
        };
        println("'}");
    } else if =(id, Node.INVOKE_INTERNAL) {
        declare invoke_data = Node.InvokeInternalData.pcast(pointer_data);
        print("InternalInvoke{names=");
        declare names = Node.InvokeInternalData.>name(invoke_data);
        //if !(=(names, 0)) {
        //    print("'");
        //    declare i = 0;
        //    while <(i, array8_length(names)) {
        //        print(*.cast(array8_get(names, i)));
        //        print(", ");
        //        i = +(i, 1);
        //    };
        //    print("'");
        //};
        print(",name='");
        if !(=(Node.InvokeInternalData.>name(invoke_data), 0)) {
            print(Node.InvokeInternalData.>name(invoke_data));
        };
        println("'}");
    } else if =(id, Node.ASSIGN) {
        declare assign_data = Node.AssignData.pcast(pointer_data);
        print("Assign{names=");
        //declare names = Node.AssignData.>name(assign_data);
        //if !(=(names, 0)) {
        //    print("'");
        //    declare i = 0;
        //    while <(i, array8_length(names)) {
        //        print(*.cast(array8_get(names, i)));
        //        print(", ");
        //        i = +(i, 1);
        //    };
        //    print("'");
        //};
        print(",name='");
        if !(=(Node.AssignData.>name(assign_data), 0)) {
            print(Node.AssignData.>name(assign_data));
        };
        println("'}");
    } else if =(id, Node.DECLARE) {
        declare declare_data = Node.DeclareData.pcast(pointer_data);
        print("Declare{name='");
        print(Node.DeclareData.>name(declare_data));
        println("'}");
    } else if =(id, Node.INVOKE) {
        println("Invoke{}");
    } else if =(id, Node.NUMBER) {
        declare number_data = Node.NumberData.pcast(pointer_data);
        print("Number{value=")
        print_whole_8(Node.NumberData.>value(number_data));
        println("}");
    } else if =(id, Node.BOOLEAN) {
        println("Boolean{}")
    } else if =(id, Node.STRING) {
        println("String{}")
    } else if =(id, Node.SKIP) {
        println("Skip{}")
    } else if =(id, Node.ENDIFBLOCK) {
        declare data = Node.EndIfBlockData.pcast(pointer_data);
        print("EndIfBlock{is_last=")
        if data.is_last {
            print("true");
        } else {
            print("false");
        };
        print(",is_bare_else=");
        if data.is_bare_else {
            print("true");
        } else {
            print("false");
        };
        println("}");
    } else if =(id, Node.ENDSTATEMENT) {
        println("EndStatement{}")
    } else {
        print_whole_8(id);
        println("");
    };
};

macro #nodes_append_data(nodes, id, type, location) {
    type.pcast(Nodes.append_data(nodes, id, location))
};

macro #nodes_get_pointer_data(nodes, type, index) {
    type.pcast(Nodes.get_pointer_data(nodes, index))
};
