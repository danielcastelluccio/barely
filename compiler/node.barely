define NODE_FUNCTION = 0;
define NodeFunctionData = structure {
    name: *;
    argument_names: *;
    argument_types: *;
    argument_types_array: *;
    returns: *;
    returns2: *;
};

define NODE_ENDFUNCTION = 1;

define NODE_RETRIEVE = 2;
define NodeRetrieveData = structure {
    // array of strings
    name: *;
    name_single: *;
    coercion: *;
    uses_previous: boolean;
};

define NODE_STRING = 3;
define NodeStringData = structure {
    value: *;
};

define NODE_NUMBER = 4;
define NodeNumberData = structure {
    value: whole_8;
    // array of strings
    coersion: *;
};

define NODE_INVOKE = 5;

define NODE_DECLARE = 6;
define NodeDeclareData = structure {
    name: *;
    // array of strings
    type: *;
};

define NODE_ASSIGN = 7;
define NodeAssignData = structure {
    // array of strings
    name: *;
    name_single: *;
    uses_previous: boolean;
};

define NODE_RETURN = 8;

define NODE_STRUCTURE = 9;
define NodeStructureData = structure {
    name: *;
    item_names: *;
    item_types: *;
    is_internal: boolean;
};

define NODE_BOOLEAN = 10;
define NodeBooleanData = structure {
    value: boolean;
};

define NODE_JUMP_CONDITIONAL = 11;
define NodeJumpConditionalData = structure {
    target_id: whole_8;
    desired_state: boolean;
};

define NODE_TARGET = 12;
define NodeTargetData = structure {
    id: whole_8;
};

define NODE_JUMP = 13;
define NodeJumpData = structure {
    target_id: whole_8;
};

define NODE_DEFINE = 14;
define NodeDefineData = structure {
    name: *;
    type: *;
    data: *;
};

define NODE_INVOKE_INTERNAL = 15;
define NodeInvokeInternalData = structure {
    // array of strings
    name: *;
    name_single: *;
    uses_previous: boolean;
};

define NODE_SCOPE = 16;

define NODE_ENDSCOPE = 17;

define NODE_STARTIFBLOCK = 18;

define NODE_ENDIFBLOCK = 19;
define NodeEndIfBlockData = structure {
    id: whole_8;
    is_last: boolean;
    is_bare_else: boolean;
};

define NODE_ENDSTATEMENT = 20;

define NODE_ENDDEFINE = 21;
define NodeEndDefineData = structure {
    type: *;
};

define NODE_SKIP = 22;

define NODE_MODULE = 23;

define NODE_ENDMODULE = 24;

define NODE_SIZE = 80;

define NodeLocationData = structure {
    file: *;
    row: whole_8;
    column: whole_8;
};

define Nodes = structure {
    buffer: AutoBuffer;
    index: whole_8;
};

define nodes_new = function(size: whole_8): Nodes {
    declare nodes: Nodes;

    Nodes.<buffer(&(nodes), autobuffer_new(size * NODE_SIZE));
    Nodes.<index(&(nodes), 0);

    return nodes;
};

define nodes_get_id = function(nodes: *Nodes, index: whole_8): whole_8 {
    return autobuffer_get_whole_8(&(Nodes.>buffer(nodes)), *(index, NODE_SIZE));
};

define nodes_get_pointer_data = function(nodes: *Nodes, index: whole_8): * {
    return autobuffer_get(&(Nodes.>buffer(nodes)), +(*(index, NODE_SIZE), 32));
};

define nodes_get_id_pointer = function(nodes: *Nodes, index: whole_8): *whole_8 {
    return whole_8.pcast(nodes_get_pointer(nodes, index));
};

define nodes_get_location_data = function(nodes: *Nodes, index: whole_8): *NodeLocationData {
    return NodeLocationData.pcast(autobuffer_get(&(Nodes.>buffer(nodes)), +(*(index, NODE_SIZE), 8)));
};

define nodes_get_pointer = function(nodes: *Nodes, index: whole_8): * {
    return autobuffer_get(&(Nodes.>buffer(nodes)), *(index, NODE_SIZE));
};

define nodes_append_data = function(nodes: *Nodes, id: whole_8, file_name: *, row: whole_8, column: whole_8): * {
    return *.cast(+(nodes_append(nodes, id, file_name, row, column), 32));
};

define nodes_append_data_anonymous = function(nodes: *Nodes, id: whole_8): * {
    return nodes_append_data(nodes, id, "", 0, 0);
};

define nodes_append_anonymous = function(nodes: *Nodes, id: whole_8): * {
    return nodes_append(nodes, id, "", 0, 0);
};

define nodes_append = function(nodes: *Nodes, id: whole_8, file_name: *, row: whole_8, column: whole_8): * {
    declare nodes_buffer = &(Nodes.>buffer(nodes));
    declare nodes_index = &(Nodes.>index(nodes));
    declare node_pointer = autobuffer_get_size(nodes_buffer, *(whole_8.>(nodes_index), NODE_SIZE), NODE_SIZE);

    declare id_pointer = nodes_get_id_pointer(nodes, whole_8.>(nodes_index));
    whole_8.<(id_pointer, id);

    declare location_data = nodes_get_location_data(nodes, whole_8.>(nodes_index));
    NodeLocationData.<file(location_data, file_name);
    NodeLocationData.<row(location_data, row);
    NodeLocationData.<column(location_data, column);

    increment_whole_8_pointer(nodes_index, 1);

    return node_pointer;
};

define nodes_set_skip = function(nodes: *Nodes, index: whole_8) {
    nodes_set_id(nodes, index, NODE_SKIP);
};

define nodes_set_id = function(nodes: *Nodes, index: whole_8, id: whole_8) {
    declare node_id = nodes_get_id_pointer(nodes, index);
    whole_8.<(node_id, id);
};

define nodes_append_structure = function(nodes: *Nodes, name: *, size: whole_8) {
    declare size_string = any_24.>0();
    whole_8_to_string(size, &(size_string));

    declare define_data = NodeDefineData.pcast(nodes_append_data_anonymous(nodes, NODE_DEFINE));
    NodeDefineData.<name(define_data, name);

    // TODO: Make this type be based on the structure data
    declare structure_type = concatenate3_brk_allocate("structure[_:any_", &(size_string), "]");
    NodeDefineData.<type(define_data, structure_type);

    declare item_names = create_size_one_array8_brk_allocate("_");
    declare item_types = create_size_one_array8_brk_allocate(concatenate2_brk_allocate("any_", &(size_string)));

    declare structure_data = NodeStructureData.pcast(nodes_append_data_anonymous(nodes, NODE_STRUCTURE));
    NodeStructureData.<item_names(structure_data, item_names);
    NodeStructureData.<item_types(structure_data, item_types);

    declare _ = nodes_append_anonymous(nodes, NODE_ENDDEFINE);
};

define nodes_append_structure_any = function(nodes: *Nodes, name: *) {
    declare structure_data = NodeStructureData.pcast(nodes_append_data_anonymous(nodes, NODE_STRUCTURE));
    NodeStructureData.<name(structure_data, name);
    NodeStructureData.<item_names(structure_data, &(empty));
    NodeStructureData.<item_types(structure_data, &(empty));
    NodeStructureData.<is_internal(structure_data, true);
};

define nodes_append_function = function(nodes: *Nodes, name: *, arguments: *, returns: *) {
    declare function_data = NodeFunctionData.pcast(nodes_append_data_anonymous(nodes, NODE_FUNCTION));
    NodeFunctionData.<name(function_data, name);
    NodeFunctionData.<argument_types(function_data, arguments);
    NodeFunctionData.<returns(function_data, returns);
    declare _ = nodes_append_anonymous(nodes, NODE_ENDFUNCTION);
};

define nodes_copy = function(nodes_from: *Nodes, nodes_to: *Nodes, count: whole_8) {
    autobuffer_set(&nodes_to.buffer, nodes_from.buffer.buffer, nodes_to.index * NODE_SIZE, count * NODE_SIZE);
    nodes_to.index = nodes_to.index + count;
};

define print_node_info = function(nodes: *Nodes, index: whole_8) {
    declare id = nodes_get_id(nodes, index);
    declare pointer_data = nodes_get_pointer_data(nodes, index);
    if =(id, NODE_RETRIEVE) {
        declare retrieve_data = NodeRetrieveData.pcast(pointer_data);
        print("Retrieve{names=");
        //if !(=(NodeRetrieveData.>name(retrieve_data), 0)) {
        //    print("'");
        //    declare i = 0;
        //    while <(i, array8_length(NodeRetrieveData.>name(retrieve_data))) {
        //        print(*.cast(array8_get(NodeRetrieveData.>name(retrieve_data), i)));
        //        print(", ");
        //        i = +(i, 1);
        //    };
        //    print("'");
        //};
        print(",name='");
        if !(=(NodeRetrieveData.>name_single(retrieve_data), 0)) {
            print(NodeRetrieveData.>name_single(retrieve_data));
        };
        println("'}");
    } else if =(id, NODE_INVOKE_INTERNAL) {
        declare invoke_data = NodeInvokeInternalData.pcast(pointer_data);
        print("InternalInvoke{names=");
        declare names = NodeInvokeInternalData.>name(invoke_data);
        //if !(=(names, 0)) {
        //    print("'");
        //    declare i = 0;
        //    while <(i, array8_length(names)) {
        //        print(*.cast(array8_get(names, i)));
        //        print(", ");
        //        i = +(i, 1);
        //    };
        //    print("'");
        //};
        print(",name='");
        if !(=(NodeInvokeInternalData.>name_single(invoke_data), 0)) {
            print(NodeInvokeInternalData.>name_single(invoke_data));
        };
        println("'}");
    } else if =(id, NODE_ASSIGN) {
        declare assign_data = NodeAssignData.pcast(pointer_data);
        print("Assign{names=");
        //declare names = NodeAssignData.>name(assign_data);
        //if !(=(names, 0)) {
        //    print("'");
        //    declare i = 0;
        //    while <(i, array8_length(names)) {
        //        print(*.cast(array8_get(names, i)));
        //        print(", ");
        //        i = +(i, 1);
        //    };
        //    print("'");
        //};
        print(",name='");
        if !(=(NodeAssignData.>name_single(assign_data), 0)) {
            print(NodeAssignData.>name_single(assign_data));
        };
        println("'}");
    } else if =(id, NODE_DECLARE) {
        declare declare_data = NodeDeclareData.pcast(pointer_data);
        print("Declare{name='");
        print(NodeDeclareData.>name(declare_data));
        println("'}");
    } else if =(id, NODE_INVOKE) {
        println("Invoke{}");
    } else if =(id, NODE_NUMBER) {
        declare number_data = NodeNumberData.pcast(pointer_data);
        print("Number{value=")
        print_whole_8(NodeNumberData.>value(number_data));
        println("}");
    } else if =(id, NODE_BOOLEAN) {
        println("Boolean{}")
    } else if =(id, NODE_STRING) {
        println("String{}")
    } else if =(id, NODE_SKIP) {
        println("Skip{}")
    } else if =(id, NODE_ENDSTATEMENT) {
        println("EndStatement{}")
    } else {
        print_whole_8(id);
        println("");
    };
};

macro #nodes_append_data(nodes, id, type, location) {
    type.pcast(nodes_append_data(nodes, id, location))
};

macro #nodes_get_pointer_data(nodes, type, index) {
    type.pcast(nodes_get_pointer_data(nodes, index))
};
