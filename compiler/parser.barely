define tokenize_inner = function(buffer: *, tokens: *Tokens.Tokens, file_name: *, row_ptr: *whole_8, column_ptr: *whole_8) {
    declare buffer_length = length(buffer);

    if buffer_length == 0 {
        return;
    };

    declare column = column_ptr.*;
    declare row = row_ptr.*;

    if is_keyword(buffer) {
        declare keyword_data = #tokens_append_data(tokens, Token.KEYWORD, Token.KeywordData, file_name, row, column);
        keyword_data.keyword = copy_string_brk_allocate(buffer);
    } else if is_number(buffer) {
        declare number_data = #tokens_append_data(tokens, Token.NUMBER, Token.NumberData, file_name, row, column);
        Token.NumberData.<value(number_data, string_to_whole_8(buffer));
    } else if string=(buffer, "true") || string=(buffer, "false") {
        declare boolean_data = #tokens_append_data(tokens, Token.BOOLEAN, Token.BooleanData, file_name, row, column);
        boolean_data.value = string=(buffer, "true");
    } else {
        declare name_data = #tokens_append_data(tokens, Token.NAME, Token.NameData, file_name, row, column);
        name_data.name = copy_string_brk_allocate(buffer);
    };
    
    increment_whole_8_pointer(column_ptr, buffer_length);
};

define is_keyword = function(buffer: *): boolean {
    return if string=(buffer, "function") true
    else if string=(buffer, "declare") true
    else if string=(buffer, "structure") true
    else if string=(buffer, "module") true
    else if string=(buffer, "macro") true
    else if string=(buffer, "return") true
    else if string=(buffer, "if") true
    else if string=(buffer, "else") true
    else if string=(buffer, "while") true
    else if string=(buffer, "global") true
    else if string=(buffer, "define") true
    else if string=(buffer, "break") true
    else false;
};

define is_number = function(string: *): boolean {
    declare has_number = false;
    declare i = 0;
    while i < length(string) {
        declare character = whole_1.>(whole_1.pcast(+(string, i)));

        if character == ASCII.MINUS {
        } else if character < ASCII.ZERO {
            return false;
        } else if character > ASCII.NINE {
            return false;
        } else {
            has_number = true;
        };

        i = +(i, 1);
    };

    return has_number;
};

macro #handle_special_tokenize_arguments() {
    &buffer, tokens, file_name, &row, &column, &handled, &index
};

define tokenize = function(file_name: *, contents: *, tokens: *Tokens.Tokens) {
    declare row = 1;
    declare column = 1;

    declare buffer = autobuffer_buffer_new(64);

    declare in_quotes = false;
    declare in_comment = false;

    declare index = 0;
    declare contents_length = length(contents);
    while index < contents_length {
        declare character = any_1.pcast(contents + index).*;
        declare has_next = (index + 1) < contents_length;
        declare character_next = any_1.pcast(contents + index + 1).*;
        declare handled = false;

        if character == ASCII.SLASH {
            if (character_next == ASCII.SLASH) && has_next {
                in_comment = true;
                handled = true;
                index = index + 2;
                column = column + 2;
            };
        };

        if !in_quotes {
            if !in_comment {
                if !handled check_handle_special_character(character, ASCII.OPEN_PARENTHESIS, Token.OPEN_PARENTHESIS, #handle_special_tokenize_arguments());
                if !handled check_handle_special_character(character, ASCII.CLOSED_PARENTHESIS, Token.CLOSED_PARENTHESIS, #handle_special_tokenize_arguments());
                if !handled check_handle_special_character(character, ASCII.OPEN_CURLY_BRACKETS, Token.OPEN_CURLY_BRACKETS, #handle_special_tokenize_arguments());
                if !handled check_handle_special_character(character, ASCII.CLOSED_CURLY_BRACKETS, Token.CLOSED_CURLY_BRACKETS, #handle_special_tokenize_arguments());
                if !handled check_handle_special_character(character, ASCII.OPEN_BRACKET, Token.OPEN_BRACKET, #handle_special_tokenize_arguments());
                if !handled check_handle_special_character(character, ASCII.CLOSED_BRACKET, Token.CLOSED_BRACKET, #handle_special_tokenize_arguments());
                if !handled check_handle_special_character(character, ASCII.COMMA, Token.COMMA, #handle_special_tokenize_arguments());
                if !handled check_handle_special_character(character, ASCII.SEMICOLON, Token.SEMICOLON, #handle_special_tokenize_arguments());
                if !handled check_handle_special_character(character, ASCII.PERIOD, Token.PERIOD, #handle_special_tokenize_arguments());
                if !handled check_handle_special_character(character, ASCII.COLON, Token.COLON, #handle_special_tokenize_arguments());

                if !handled check_handle_break(character, ASCII.SPACE, #handle_special_tokenize_arguments());
                if !handled check_handle_break(character, ASCII.LINE_FEED, #handle_special_tokenize_arguments());
                if !handled check_handle_break(character, ASCII.TAB, #handle_special_tokenize_arguments());

                if !handled check_handle_single_operator(character, ASCII.PLUS, "+", #handle_special_tokenize_arguments());
                if |(character_next < ASCII.ZERO, character_next > ASCII.NINE) {
                    if !handled check_handle_single_operator(character, ASCII.MINUS, "-", #handle_special_tokenize_arguments());
                };
                if !handled check_handle_single_operator(character, ASCII.ASTERISK, "*", #handle_special_tokenize_arguments());
                if !handled check_handle_single_operator(character, ASCII.SLASH, "/", #handle_special_tokenize_arguments());
                if !handled check_handle_single_operator(character, ASCII.PERCENT, "%", #handle_special_tokenize_arguments());

                if has_next {
                    if !handled check_handle_double_operator(character, character_next, ASCII.EQUAL, ASCII.EQUAL, "==", #handle_special_tokenize_arguments());
                    if !handled check_handle_double_operator(character, character_next, ASCII.AMPERSAND, ASCII.AMPERSAND, "&&", #handle_special_tokenize_arguments());
                    if !handled check_handle_double_operator(character, character_next, ASCII.VERTICAL_BAR, ASCII.VERTICAL_BAR, "||", #handle_special_tokenize_arguments());
                };

                if !handled check_handle_single_prefix(character, ASCII.EXCLAMATION_POINT, "!", #handle_special_tokenize_arguments());
                if !handled check_handle_single_prefix(character, ASCII.AMPERSAND, "&", #handle_special_tokenize_arguments());
            };
        };

        if !in_comment {
            if character == ASCII.QUOTATION {
                if in_quotes {
                    declare buffer_length = length(buffer.autobuffer.buffer);
                    declare buffer_copy = copy_string_brk_allocate(buffer.autobuffer.buffer);

                    declare string_pointer_data = #tokens_append_data(tokens, Token.STRING, Token.StringData, file_name, row, column);
                    string_pointer_data.value = buffer_copy;

                    autobuffer_buffer_reset(&buffer);
                    column = column + buffer_length + 2;
                };

                in_quotes = !in_quotes;
                handled = true;
                index = index + 1;
            };
        };

        if character == ASCII.LINE_FEED {
            in_comment = false;

            column = 1;
            row = row + 1;

            if !handled {
                index = index + 1;
                handled = true;
            };
        };
        
        if !handled {
            if in_comment {
                index = index + 1;
            } else {
                autobuffer_buffer_push_any_1(&buffer, character);
                handled = true;
                index = index + 1;
            };
        };
    };
};

define check_handle_single_operator = function(character: any_1, wanted_character: any_1, internal_name: *, buffer: *AutoBufferBuffer, tokens: *Tokens.Tokens, file_name: *, row: *whole_8, column: *whole_8, handled: *boolean, index: *whole_8) {
    if character == wanted_character {
        tokenize_inner(buffer.autobuffer.buffer, tokens, file_name, row, column);

        tokenize_inner(internal_name, tokens, file_name, row, column);

        autobuffer_buffer_reset(buffer);
        column.* = column.* + 1;
        index.* = index.* + 1;
        handled.* = true;
    };
};

define check_handle_double_operator = function(character: any_1, character_next: any_1, wanted_character: any_1, wanted_character_next: any_1, internal_name: *, buffer: *AutoBufferBuffer, tokens: *Tokens.Tokens, file_name: *, row: *whole_8, column: *whole_8, handled: *boolean, index: *whole_8) {
    if &&(character == wanted_character, character_next == wanted_character_next) {
        tokenize_inner(buffer.autobuffer.buffer, tokens, file_name, row, column);

        tokenize_inner(internal_name, tokens, file_name, row, column);

        autobuffer_buffer_reset(buffer);
        column.* = column.* + 2;
        index.* = index.* + 2;
        handled.* = true;
    };
};

define check_handle_single_prefix = function(character: any_1, wanted_character: any_1, internal_name: *, buffer: *AutoBufferBuffer, tokens: *Tokens.Tokens, file_name: *, row: *whole_8, column: *whole_8, handled: *boolean, index: *whole_8) {
    if character == wanted_character {
        tokenize_inner(internal_name, tokens, file_name, row, column);

        autobuffer_buffer_reset(buffer);
        column.* = column.* + 1;
        index.* = index.* + 1;
        handled.* = true;
    };
};

define check_handle_special_character = function(current_character: any_1, desired_character: whole_1, token: whole_8, buffer: *AutoBufferBuffer, tokens: *Tokens.Tokens, file_name: *, row: *whole_8, column: *whole_8, handled: *boolean, index: *whole_8) {
    if current_character == desired_character {
        tokenize_inner(buffer.autobuffer.buffer, tokens, file_name, row, column);
        declare _ = Tokens.append(tokens, token, file_name, whole_8.>(row), whole_8.>(column));

        autobuffer_buffer_reset(buffer);
        column.* = column.* + 1;
        index.* = index.* + 1;
        handled.* = true;
    };
};

define check_handle_break = function(current_character: any_1, desired_character: whole_1, buffer: *AutoBufferBuffer, tokens: *Tokens.Tokens, file_name: *, row: *whole_8, column: *whole_8, handled: *boolean, index: *whole_8) {
    if current_character == desired_character {
        tokenize_inner(buffer.autobuffer.buffer, tokens, file_name, row, column);

        autobuffer_buffer_reset(buffer);
        column.* = column.* + 1;
        index.* = index.* + 1;
        handled.* = true;
    };
};

define get_token_location_data = function(tokens: *Tokens.Tokens, index: whole_8): *, whole_8, whole_8 {
    declare data = Tokens.get_location_data(tokens, index);
    return Token.LocationData.>file(data), Token.LocationData.>row(data), Token.LocationData.>column(data);
};

define print_token_error_beginning = function(tokens: *Tokens.Tokens, location: whole_8) {
    declare location_data = Tokens.get_location_data(tokens, location);
    print("[ERROR] ");
    print(Token.LocationData.>file(location_data));
    print(":");
    print_whole_8(Token.LocationData.>row(location_data));
    print(":");
    print_whole_8(Token.LocationData.>column(location_data));
    print(": ");
};

define parse_define = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    declare index = whole_8.>(index_pointer);
    declare name_token_pointer_data = Token.NameData.pcast(Tokens.get_pointer_data(tokens, +(index, 1)));
    declare name = Token.NameData.>name(name_token_pointer_data);

    declare type = *.cast(0);
    declare value_offset = if =(Tokens.get_id(tokens, +(index, 2)), Token.COLON) {
        declare type_token_pointer_data = Token.NameData.pcast(Tokens.get_pointer_data(tokens, +(index, 3)));
        type = Token.NameData.>name(type_token_pointer_data);
        5
    } else if Tokens.is_name(tokens, +(index, 2), "=") {
        3
    } else {
        print_token_error_beginning(tokens, +(index, 2));
        println("Unexpected token");
        exit(1);
        0
    };

    if =(Tokens.get_id(tokens, +(index, value_offset)), Token.NUMBER) {
        declare value_token_pointer_data = Token.NumberData.pcast(Tokens.get_pointer_data(tokens, +(index, value_offset)));

        declare value = brk_allocate(8);
        whole_8.<(whole_8.pcast(value), Token.NumberData.>value(value_token_pointer_data));
    };

    declare define_index = Nodes.>index(nodes);
    declare define_node_data = NodeDefineData.pcast(nodes_append_data(nodes, NODE_DEFINE, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeDefineData.<name(define_node_data, name);
    NodeDefineData.<type(define_node_data, type);

    increment_whole_8_pointer(index_pointer, value_offset);

    parse_individual(tokens, index_pointer, nodes);

    declare end_define_index = Nodes.>index(nodes);
    declare end_define_node_data = NodeEndDefineData.pcast(nodes_append_data(nodes, NODE_ENDDEFINE, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeEndDefineData.<type(end_define_node_data, type);

    increment_whole_8_pointer(index_pointer, 1);
};

define parse_structure = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    declare index = whole_8.>(index_pointer);

    declare member_names = autobuffer_new(40);
    declare member_types = autobuffer_new(40);
    declare member_index = 0;

    index = +(index, 2);

    declare seen_item_name = false;

    while !(=(Tokens.get_id(tokens, index), Token.CLOSED_CURLY_BRACKETS)) {
        declare id = Tokens.get_id(tokens, index);

        if =(id, Token.NAME) {
            if seen_item_name {
                autobuffer_array8_set(&(member_types), member_index, parse_name(tokens, &(index)));
                member_index = +(member_index, 1);
            } else {
                autobuffer_array8_set(&(member_names), member_index, parse_name(tokens, &(index)));
            };

            seen_item_name = !(seen_item_name);
        } else if =(id, Token.COLON) {
            index = +(index, 1);
        } else if =(id, Token.SEMICOLON) {
            index = +(index, 1);
        };
    };

    declare structure_data = NodeStructureData.pcast(nodes_append_data(nodes, NODE_STRUCTURE, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeStructureData.<item_names(structure_data, AutoBuffer.>buffer(&(member_names)));
    NodeStructureData.<item_types(structure_data, AutoBuffer.>buffer(&(member_types)));

    index = +(index, 1);

    whole_8.<(index_pointer, index);
};

define parse_name = function(tokens: *Tokens.Tokens, index_pointer: *whole_8): * {
    declare buffer = autobuffer_buffer_new(64);
    if =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.NAME) {
        declare token_name = Token.NameData.>name(Token.NameData.pcast(Tokens.get_pointer_data(tokens, whole_8.>(index_pointer))));
        autobuffer_buffer_push_string(&(buffer), token_name);
        increment_whole_8_pointer(index_pointer, 1);
    };

    declare inner = 0;
    while |(>(inner, 0), |(=(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.OPEN_BRACKET), &&(Tokens.is_name(tokens, -(whole_8.>(index_pointer), 1), "*"), |(=(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.NAME), =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.KEYWORD))))) {
        declare id = Tokens.get_id(tokens, whole_8.>(index_pointer));
        declare pointer_data = Tokens.get_pointer_data(tokens, whole_8.>(index_pointer));
        if =(id, Token.OPEN_BRACKET) {
            autobuffer_buffer_push_string(&(buffer), "[");
            inner = +(inner, 1);
        } else if =(id, Token.CLOSED_BRACKET) {
            autobuffer_buffer_push_string(&(buffer), "]");
            inner = -(inner, 1);
        } else if =(id, Token.COMMA) {
            autobuffer_buffer_push_string(&(buffer), ",");
        } else if =(id, Token.COLON) {
            autobuffer_buffer_push_string(&(buffer), ":");
        } else if =(id, Token.NAME) {
            autobuffer_buffer_push_string(&(buffer), Token.NameData.>name(Token.NameData.pcast(pointer_data)));
        } else if =(id, Token.KEYWORD) {
            autobuffer_buffer_push_string(&(buffer), Token.KeywordData.>keyword(Token.KeywordData.pcast(pointer_data)));
        };
        increment_whole_8_pointer(index_pointer, 1);
    };

    declare result = AutoBuffer.>buffer(&(AutoBufferBuffer.>autobuffer(&(buffer))));

    if =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.PERIOD) {
        increment_whole_8_pointer(index_pointer, 1);
        if is_only_asterisks(result) {
            result = concatenate3_brk_allocate(result, "@current_module.", parse_name(tokens, index_pointer));
        } else {
            result = concatenate3_brk_allocate(result, ".", parse_name(tokens, index_pointer));
        };
    };

    return result;
};

define parse_name_array = function(tokens: *Tokens.Tokens, index_pointer: *whole_8): * {
    declare buffer = autobuffer_buffer_new(32);
    declare array = autobuffer_new(24);
    declare array_index = 0;
    if =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.NAME) {
        declare token_name = Token.NameData.>name(Token.NameData.pcast(Tokens.get_pointer_data(tokens, whole_8.>(index_pointer))));
        autobuffer_buffer_push_string(&(buffer), token_name);
        increment_whole_8_pointer(index_pointer, 1);
    };

    declare inner = 0;
    while |(>(inner, 0), |(=(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.OPEN_BRACKET), &&(Tokens.is_name(tokens, -(whole_8.>(index_pointer), 1), "*"), |(=(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.NAME), =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.KEYWORD))))) {
        declare id = Tokens.get_id(tokens, whole_8.>(index_pointer));
        declare pointer_data = Tokens.get_pointer_data(tokens, whole_8.>(index_pointer));
        if =(id, Token.OPEN_BRACKET) {
            autobuffer_buffer_push_string(&(buffer), "[");
            inner = +(inner, 1);
        } else if =(id, Token.CLOSED_BRACKET) {
            autobuffer_buffer_push_string(&(buffer), "]");
            inner = -(inner, 1);
        } else if =(id, Token.COMMA) {
            autobuffer_buffer_push_string(&(buffer), ",");
        } else if =(id, Token.COLON) {
            autobuffer_buffer_push_string(&(buffer), ":");
        } else if =(id, Token.NAME) {
            autobuffer_buffer_push_string(&(buffer), Token.NameData.>name(Token.NameData.pcast(pointer_data)));
        } else if =(id, Token.KEYWORD) {
            autobuffer_buffer_push_string(&(buffer), Token.KeywordData.>keyword(Token.KeywordData.pcast(pointer_data)));
        };
        increment_whole_8_pointer(index_pointer, 1);
    };

    //if >(length(autobuffer_buffer_get_buffer_pointer(&(buffer))), 0) {
        autobuffer_array8_set(&(array), array_index, autobuffer_buffer_get_buffer_pointer(&(buffer)));
        array_index = +(array_index, 1);
    //};

    if =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.PERIOD) {
        increment_whole_8_pointer(index_pointer, 1);
        if is_only_asterisks(*.cast(autobuffer_array8_get(&(array), -(autobuffer_array8_length(&(array)), 1)))) {
            array_index = -(array_index, 1);
            declare first_index_contents = *.cast(autobuffer_array8_get(&(array), array_index));
            autobuffer_array8_set(&(array), array_index, concatenate2_brk_allocate(first_index_contents, "@current_module"));
            array_index = +(array_index, 1);
            declare next_array = parse_name_array(tokens, index_pointer);

            declare i = 0;
            while <(i, array8_length(next_array)) {
                autobuffer_array8_set(&(array), array_index, *.cast(array8_get(next_array, i)));
                array_index = +(array_index, 1);
                i = +(i, 1);
            };
        } else {
            declare next_array = parse_name_array(tokens, index_pointer);

            declare i = 0;
            while <(i, array8_length(next_array)) {
                autobuffer_array8_set(&(array), array_index, *.cast(array8_get(next_array, i)));
                array_index = +(array_index, 1);
                i = +(i, 1);
            };
        };
    };

    return AutoBuffer.>buffer(&(array));
};

define is_only_asterisks = function(string: *): boolean {
    declare i = 0;
    while <(i, length(string)) {
        declare character = any_1.>(any_1.pcast(+(string, i)));
        if !(=(character, ASCII.ASTERISK)) {
            return false;
        };
        i = +(i, 1);
    };

    return true;
};

define parse_function = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    declare index = whole_8.>(index_pointer);

    declare function_data = NodeFunctionData.pcast(nodes_append_data(nodes, NODE_FUNCTION, get_token_location_data(tokens, whole_8.>(index_pointer))));

    index = +(index, 2);

    declare function_argument_names, function_arguments, function_arguments_array, function_returns, function_returns2 = parse_function_definition(tokens, &(index), nodes);

    declare has_body = =(Tokens.get_id(tokens, index), Token.OPEN_CURLY_BRACKETS);

    NodeFunctionData.<argument_names(function_data, function_argument_names);
    NodeFunctionData.<argument_types_array(function_data, function_arguments_array);
    NodeFunctionData.<returns(function_data, function_returns);
    NodeFunctionData.<returns2(function_data, function_returns2);

    if has_body {
        index = +(index, 1);

        declare _ = nodes_append(nodes, NODE_SCOPE, get_token_location_data(tokens, index));
        while !(=(Tokens.get_id(tokens, index), Token.CLOSED_CURLY_BRACKETS)) {
            parse_statement(tokens, &(index), nodes);
        };

        index = +(index, 1);

        
        if !(=(nodes_get_id(nodes, -(Nodes.>index(nodes), 1)), NODE_RETURN)) {
            declare _ = nodes_append(nodes, NODE_RETURN, get_token_location_data(tokens, -(index, 1)));
        };

        declare _ = nodes_append(nodes, NODE_ENDSCOPE, get_token_location_data(tokens, index));
    };

    declare _ = nodes_append(nodes, NODE_ENDFUNCTION, get_token_location_data(tokens, index));

    whole_8.<(index_pointer, index);
};

define parse_function_definition = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes): *, *, *, *, * {
    declare index = whole_8.>(index_pointer);

    declare function_argument_names = autobuffer_new(40);
    declare function_arguments = autobuffer_new(40);
    declare function_arguments_array = autobuffer_new(40);
    declare function_returns = autobuffer_new(40);
    declare function_returns2 = autobuffer_new(40);

    declare is_name = true;
    declare arguments_index = 0;
    while !(=(Tokens.get_id(tokens, index), Token.CLOSED_PARENTHESIS)) {
        declare id = Tokens.get_id(tokens, index);

        if =(id, Token.NAME) {
            declare token_name = Token.NameData.>name(Token.NameData.pcast(Tokens.get_pointer_data(tokens, index)));

            if is_name {
                autobuffer_array8_set(&(function_argument_names), arguments_index, token_name);
                index = +(index, 1);
            } else {
                token_name = parse_name_array(tokens, &(index));
                autobuffer_array8_set(&(function_arguments_array), arguments_index, token_name);
                arguments_index = +(arguments_index, 1);
            };

            is_name = !(is_name);
        } else if |(=(id, Token.COMMA), =(id, Token.COLON)) {
            index = +(index, 1);
        };
    };
    
    index = +(index, 1);

    declare returns_index = 0;
    while &&(!(=(Tokens.get_id(tokens, index), Token.OPEN_CURLY_BRACKETS)), !(=(Tokens.get_id(tokens, index), Token.SEMICOLON))) {
        declare id = Tokens.get_id(tokens, index);

        if |(=(id, Token.NAME), =(id, Token.PERIOD)) {
            declare initialIndex = index;
            declare token_name = parse_name(tokens, &(index));
            autobuffer_array8_set(&(function_returns), returns_index, token_name);
            index = initialIndex;
            declare token_name2 = parse_name_array(tokens, &(index));
            autobuffer_array8_set(&(function_returns2), returns_index, token_name2);
            returns_index = +(returns_index, 1);
        } else if |(=(id, Token.COMMA), =(id, Token.COLON)) {
            index = +(index, 1);
        };
    };

    whole_8.<(index_pointer, index);

    return AutoBuffer.>buffer(&(function_argument_names)), AutoBuffer.>buffer(&(function_arguments)), AutoBuffer.>buffer(&(function_arguments_array)), AutoBuffer.>buffer(&(function_returns)), AutoBuffer.>buffer(&(function_returns2));
};

define parse_invoke_parenthesis = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    increment_whole_8_pointer(index_pointer, 1);

    parse_multiple_expressions(tokens, index_pointer, nodes, Token.CLOSED_PARENTHESIS);

    increment_whole_8_pointer(index_pointer, 1);
};

define parse_invoke_parenthesis_ending = function(tokens: *Tokens.Tokens, index_in: whole_8, nodes: *Nodes) {
    declare index = index_in;

    declare inner = 0:integer_8;
    while |(>(inner, 0:integer_8), =(Tokens.get_id(tokens, index), Token.OPEN_PARENTHESIS)) {
        declare id = Tokens.get_id(tokens, index);
        if =(id, Token.OPEN_PARENTHESIS) {
            if =(inner, 0:integer_8) {
                declare inside_index = +(index, 1);
                declare inside_inner = 1:integer_8;
                while >(inside_inner, 0:integer_8) {
                    declare id3 = Tokens.get_id(tokens, inside_index);
                    if =(id3, Token.OPEN_PARENTHESIS) {
                        inside_inner = +(inside_inner, 1:integer_8);
                    } else if =(id3, Token.CLOSED_PARENTHESIS) {
                        inside_inner = -(inside_inner, 1:integer_8);
                    } else if =(id3, Token.SEMICOLON) {
                        print_token_error_beginning(tokens, index);
                        println("Unclosed parenthesis");
                        exit(1);
                    };

                    inside_index = +(inside_index, 1);
                };
                parse_invoke_parenthesis_ending(tokens, inside_index, nodes);
                parse_invoke_parenthesis(tokens, &(index), nodes);
                return;
            } else {
                inner = +(inner, 1:integer_8);
                index = +(index, 1);
            };
        } else if =(id, Token.CLOSED_PARENTHESIS) {
            inner = -(inner, 1:integer_8);
            index = +(index, 1);
        };
    };
};

define parse_expression = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes_in: *Nodes) {
    declare index = whole_8.>(index_pointer);

    declare id = Tokens.get_id(tokens, index);
    declare pointer_data = Tokens.get_pointer_data(tokens, index);

    declare nodes_temp = nodes_new();
    declare nodes = &(nodes_temp);

    declare nodes_index = Nodes.>index(nodes);
    declare nodes_initial_index = Nodes.>index(nodes_in);

    check_parse_simple_expressions(tokens, &(index), nodes, id, pointer_data);

    if =(id, Token.OPEN_CURLY_BRACKETS) {
        declare _ = nodes_append(nodes, NODE_SCOPE, get_token_location_data(tokens, index));
        index = +(index, 1);
        while !(=(Tokens.get_id(tokens, index), Token.CLOSED_CURLY_BRACKETS)) {
            parse_statement(tokens, &(index), nodes);
        };
        index = +(index, 1);
        declare _ = nodes_append(nodes, NODE_ENDSCOPE, get_token_location_data(tokens, index));
    };

    if =(id, Token.OPEN_PARENTHESIS) {
        index = +(index, 1);
        parse_expression(tokens, &(index), nodes);
        index = +(index, 1);
    };

    if =(id, Token.KEYWORD) {
        declare name_value = Token.NameData.>name(Token.NameData.pcast(Tokens.get_pointer_data(tokens, whole_8.>(index_pointer))));
        if string=(name_value, "if") {
            parse_if(tokens, &(index), nodes);
        };
    };

    check_parse_invoke_parenthesis_chain(tokens, &(index), nodes, nodes_in);

    whole_8.<(index_pointer, index);

    declare next_id = Tokens.get_id(tokens, index);
    if =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.PERIOD) {
        increment_whole_8_pointer(index_pointer, 1);
        parse_expression(tokens, index_pointer, nodes_in);
    };

    if =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.NAME) {
        // TODO: This check should be removed once everything is converted and we don't need to old way of callin)g
        if !(=(Tokens.get_id(tokens, +(whole_8.>(index_pointer), 1)), Token.OPEN_PARENTHESIS)) {
            declare name = Token.NameData.>name(Token.NameData.pcast(Tokens.get_pointer_data(tokens, whole_8.>(index_pointer))));

            declare _ = check_parse_operator(tokens, index_pointer, nodes_in, name, "+", "+");
            declare _ = check_parse_operator(tokens, index_pointer, nodes_in, name, "-", "-");
            declare _ = check_parse_operator(tokens, index_pointer, nodes_in, name, "*", "*");
            declare _ = check_parse_operator(tokens, index_pointer, nodes_in, name, "/", "/");
            declare _ = check_parse_operator(tokens, index_pointer, nodes_in, name, "%", "%");
            declare _ = check_parse_operator(tokens, index_pointer, nodes_in, name, "&&", "&&");
            declare _ = check_parse_operator(tokens, index_pointer, nodes_in, name, "||", "|");
            declare _ = check_parse_operator(tokens, index_pointer, nodes_in, name, ">", ">");
            declare _ = check_parse_operator(tokens, index_pointer, nodes_in, name, "<", "<");
            declare _ = check_parse_operator(tokens, index_pointer, nodes_in, name, "==", "=");
        };
    };
};

define check_parse_invoke_parenthesis_chain = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes, nodes_in: *Nodes) {
    declare index = whole_8.>(index_pointer);

    declare nodes_moved_count = Nodes.>index(nodes);

    declare nodes_index = Nodes.>index(nodes);

    parse_invoke_parenthesis_ending(tokens, index, nodes_in);

    declare nodes_in_index = Nodes.>index(nodes_in);

    autobuffer_set(&(Nodes.>buffer(nodes_in)), AutoBuffer.>buffer(&(Nodes.>buffer(nodes))), *(Nodes.>index(nodes_in), NODE_SIZE), *(nodes_moved_count, NODE_SIZE));
    Nodes.<index(nodes_in, +(Nodes.>index(nodes_in), nodes_moved_count));

    if =(Tokens.get_id(tokens, index), Token.OPEN_PARENTHESIS) {
        parse_invoke_parenthesis_chain(tokens, &(index), nodes_in, nodes_in_index);
    };

    whole_8.<(index_pointer, index);
};

define check_parse_operator = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes, parsed_name: *, wanted_name: *, internal_name: *): boolean {
    if string=(parsed_name, wanted_name) {
        increment_whole_8_pointer(index_pointer, 1);
        parse_expression(tokens, index_pointer, nodes);

        declare operator_data = NodeInvokeInternalData.pcast(nodes_append_data(nodes, NODE_INVOKE_INTERNAL, get_token_location_data(tokens, -(whole_8.>(index_pointer), 1))));
        NodeInvokeInternalData.<name_single(operator_data, internal_name);
        return true;
    };

    return false;
};

define check_parse_simple_expressions = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes, token_id: whole_8, token_pointer_data: *) {
    declare index = whole_8.>(index_pointer);

    if =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.NAME) {
        // TODO: This check should be removed once everything is converted and we don't need to old way of callin)g
        if !(=(Tokens.get_id(tokens, +(whole_8.>(index_pointer), 1)), Token.OPEN_PARENTHESIS)) {
            declare name = Token.NameData.>name(Token.NameData.pcast(Tokens.get_pointer_data(tokens, whole_8.>(index_pointer))));

            if check_parse_operator(tokens, index_pointer, nodes, name, "!", "!") { return; }; // TODO: I have no idea why the syntax with the bar return is not working
            if check_parse_operator(tokens, index_pointer, nodes, name, "&", "&") { return; };
        };
    };

    if =(token_id, Token.PERIOD) {
        declare retrieve_node_data = NodeRetrieveData.pcast(nodes_append_data(nodes, NODE_RETRIEVE, get_token_location_data(tokens, index)));
        NodeRetrieveData.<name_single(retrieve_node_data, "@current_module");
        index = +(index, 1);

        parse_expression(tokens, &(index), nodes);
    };

    if =(token_id, Token.NAME) {
        //declare names_buffer = autobuffer_new(24);
        //declare j = 0;

        //index = -(index, 1);

        //declare retrieve_node_data = NodeRetrieveData.pcast(nodes_append_data(nodes, NODE_RETRIEVE, get_token_location_data(tokens, index)));

        //declare name_count = 0;
        //declare name_name: * = *.cast(0);
        //declare first = true;
        //while |(=(Tokens.get_id(tokens, index), Token.PERIOD), first) {
        //    index = +(index, 1);

        //    if !(=(name_name, 0)) {
        //        autobuffer_array8_set(&(names_buffer), j, name_name);
        //        j = +(j, 1);
        //    };

        //    declare name_data = Token.NameData.pcast(Tokens.get_pointer_data(tokens, index));
        //    name_name = Token.NameData.>name(name_data);

        //    index = +(index, 1);
        //    name_count = +(name_count, 1);
        //    first = false;
        //};

        //declare i = 0;
        //while <(i, *(-(name_count, 1), 2)) {
        //    declare _ = nodes_append(nodes, NODE_SKIP, get_token_location_data(tokens, index));
        //    i = +(i, 1);
        //};

        //autobuffer_array8_set(&(names_buffer), j, name_name);
        //NodeRetrieveData.<name(retrieve_node_data, AutoBuffer.>buffer(&(names_buffer)));

        //if =(Tokens.get_id(tokens, index), Token.COLON) {
        //    index = +(index, 1);
        //    declare name = parse_name(tokens, &(index));
        //    NodeRetrieveData.<coercion(retrieve_node_data, name);
        //};
        declare last_id = Tokens.get_id(tokens, -(index, 1));

        declare name_data = Token.NameData.pcast(Tokens.get_pointer_data(tokens, index));
        declare retrieve_node_data = NodeRetrieveData.pcast(nodes_append_data(nodes, NODE_RETRIEVE, get_token_location_data(tokens, index)));
        NodeRetrieveData.<name_single(retrieve_node_data, Token.NameData.>name(name_data));
        index = +(index, 1);
        if =(Tokens.get_id(tokens, index), Token.COLON) {
            index = +(index, 1);
            declare name = parse_name(tokens, &(index));
            NodeRetrieveData.<coercion(retrieve_node_data, name);
        };

        if =(last_id, Token.PERIOD) {
            NodeRetrieveData.<uses_previous(retrieve_node_data, true);
        };

        declare _ = nodes_append(nodes, NODE_SKIP, get_token_location_data(tokens, index));
        declare _ = nodes_append(nodes, NODE_SKIP, get_token_location_data(tokens, index));
    };

    if =(token_id, Token.STRING) {
        declare string_value = Token.StringData.>value(Token.StringData.pcast(token_pointer_data));
        declare string_pointer_data = NodeStringData.pcast(nodes_append_data(nodes, NODE_STRING, get_token_location_data(tokens, index)));
        NodeStringData.<value(string_pointer_data, string_value);

        index = +(index, 1);
    };

    if =(token_id, Token.NUMBER) {
        declare number_token_data = Token.NumberData.pcast(token_pointer_data);
        declare number_value = Token.NumberData.>value(number_token_data);
        declare number_node_data = NodeNumberData.pcast(nodes_append_data(nodes, NODE_NUMBER, get_token_location_data(tokens, index)));
        NodeNumberData.<value(number_node_data, number_value);

        index = +(index, 1);

        declare coerced_value = "whole_8";
        if =(Tokens.get_id(tokens, index), Token.COLON) {
            index = +(index, 1);

            coerced_value = parse_name_array(tokens, &(index));
            NodeNumberData.<coersion(number_node_data, coerced_value);
        };

        // TODO: Making sure that numbers fit in the type they are declared to be
        // probably need to retain some information about the input string in order to do this correctly

        //declare number_size, number_signedness = type_string_to_size_byte(coerced_value);
        //if !(check_number_fits(tokens, number_size, number_signedness, number_value)) {
        //    print_token_error_beginning(tokens, -(Tokens.Tokens.>index(tokens), 1));
        //    print("Number literal '");
        //    print(autobuffer_buffer_get_buffer_pointer(&(number_buffer)));
        //    print("' cannot fit in type '");
        //    print(autobuffer_buffer_get_buffer_pointer(&(type_buffer)));
        //    print("_");
        //    print(autobuffer_buffer_get_buffer_pointer(&(size_buffer)));
        //    println("'");
        //    exit(1);
        //};
    };

    if =(token_id, Token.BOOLEAN) {
        declare boolean_value = Token.BooleanData.>value(Token.BooleanData.pcast(token_pointer_data));
        declare boolean_node_data = NodeBooleanData.pcast(nodes_append_data(nodes, NODE_BOOLEAN, get_token_location_data(tokens, index)));
        NodeBooleanData.<value(boolean_node_data, boolean_value);

        index = +(index, 1);
    };

    whole_8.<(index_pointer, index);
};

define check_number_fits = function(size_bytes: whole_8, wants_signed: boolean, input_string: *): boolean {
    declare size_bits = 2;
    declare m = 1;
    while <(m, *(size_bytes, 8)) {
        size_bits = *(2, size_bits);
        m = +(m, 1);
    };
    size_bits = -(size_bits, 1);
    if wants_signed {
        size_bits = /(size_bits, 2);
    };

    declare number = 0;

    declare is_input_negative = =(any_1.>(any_1.pcast(input_string)), ASCII.MINUS);
    if is_input_negative {
        if wants_signed {
            number = -(string_to_whole_8(+(input_string, 1)), 1);
        } else {
            return false;
        };
    } else {
        number = string_to_whole_8(input_string);
    };

    return !(>(number, size_bits));
};

define parse_invoke_parenthesis_chain = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes, previous_retrieve_index: whole_8) {
    declare index = whole_8.>(index_pointer);
    declare inner = 0:integer_8;

    declare is_first = true;

    while |(>(inner, 0:integer_8), =(Tokens.get_id(tokens, index), Token.OPEN_PARENTHESIS)) {
        declare id2 = Tokens.get_id(tokens, index);
        if =(id2, Token.OPEN_PARENTHESIS) {
            if =(inner, 0:integer_8) {
                declare is_special = false;
                declare is_pointer = false;
                declare retrieve_data = NodeRetrieveData.pcast(nodes_get_pointer_data(nodes, previous_retrieve_index));
                declare retrieve_name = NodeRetrieveData.>name_single(retrieve_data);
                declare uses_previous = NodeRetrieveData.>uses_previous(retrieve_data);
                if is_first {
                    is_special = is_special_function(retrieve_name);
                };

                if is_special {
                    nodes_set_skip(nodes, previous_retrieve_index);

                    declare invoke_data = NodeInvokeInternalData.pcast(nodes_append_data(nodes, NODE_INVOKE_INTERNAL, get_token_location_data(tokens, whole_8.>(index_pointer))));
                    NodeInvokeInternalData.<name_single(invoke_data, retrieve_name);
                    NodeInvokeInternalData.<uses_previous(invoke_data, uses_previous);
                } else {
                    declare _ = nodes_append(nodes, NODE_INVOKE, get_token_location_data(tokens, whole_8.>(index_pointer)));
                };

                is_first = false;
            };
            inner = +(inner, 1:integer_8);
        } else if =(id2, Token.CLOSED_PARENTHESIS) {
            inner = -(inner, 1:integer_8);
        };
        index = +(index, 1);
    };

    whole_8.<(index_pointer, index);
};

define is_special_function = function(name: *): boolean {
    return if string=(name, "+") {
        true
    } else if string=(name, "-") {
        true
    } else if string=(name, "*") {
        true
    } else if string=(name, "/") {
        true
    } else if string=(name, "%") {
        true
    } else if string=(name, "=") {
        true
    } else if string=(name, ">") {
        true
    } else if string=(name, "<") {
        true
    } else if string=(name, "&") {
        true
    } else if string=(name, "!") {
        true
    } else if string=(name, "|") {
        true
    } else if string=(name, "&&") {
        true
    } else if string_length=(name, "<", 1) {
        true
    } else if string_length=(name, ">", 1) {
        true
    } else if string_length=(name, "cast", 4) {
        true
    } else if string_length=(name, "pcast", 5) {
        true
    } else if &&(string_length=(name, "size", 4), =(length(name), 4)) {
        true
    } else if string_length=(name, "@syscall", 8) {
        true
    } else {
        false
    };
};

define parse_if = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    declare index = whole_8.>(index_pointer);

    declare end_target = get_target_id();

    declare end_if: *NodeEndIfBlockData;

    while =(Tokens.get_id(tokens, index), Token.KEYWORD) {
        declare target = get_target_id();
        declare token_data = Token.KeywordData.pcast(Tokens.get_pointer_data(tokens, index));
        declare token_index = index;

        declare is_bare_else = false;

        if Tokens.is_keyword(tokens, token_index, "if") {
            index = +(index, 1);

            parse_expression(tokens, &(index), nodes);
            declare conditional_jump_data = NodeJumpConditionalData.pcast(nodes_append_data(nodes, NODE_JUMP_CONDITIONAL, get_token_location_data(tokens, index)));
            NodeJumpConditionalData.<target_id(conditional_jump_data, target);
        } else if &&(Tokens.is_keyword(tokens, token_index, "else"), Tokens.is_keyword(tokens, token_index, "if")) {
            index = +(index, 2);

            parse_expression(tokens, &(index), nodes);
            declare conditional_jump_data = NodeJumpConditionalData.pcast(nodes_append_data(nodes, NODE_JUMP_CONDITIONAL, get_token_location_data(tokens, index)));
            NodeJumpConditionalData.<target_id(conditional_jump_data, target);
        } else {
            is_bare_else = true;
            index = +(index, 1);
        };

        declare _ = nodes_append(nodes, NODE_STARTIFBLOCK, get_token_location_data(tokens, index));
        parse_expression(tokens, &(index), nodes);

        declare jump_data = NodeJumpData.pcast(nodes_append_data(nodes, NODE_JUMP, get_token_location_data(tokens, index)));
        NodeJumpData.<target_id(jump_data, end_target);

        end_if = NodeEndIfBlockData.pcast(nodes_append_data(nodes, NODE_ENDIFBLOCK, get_token_location_data(tokens, -(index, 1))));
        NodeEndIfBlockData.<id(end_if, end_target);
        NodeEndIfBlockData.<is_bare_else(end_if, is_bare_else);

        declare target_node_data = NodeTargetData.pcast(nodes_append_data(nodes, NODE_TARGET, get_token_location_data(tokens, index)));
        NodeTargetData.<id(target_node_data, target);
    };

    NodeEndIfBlockData.<is_last(end_if, true);

    declare target_node_data = NodeTargetData.pcast(nodes_append_data(nodes, NODE_TARGET, get_token_location_data(tokens, index)));
    NodeTargetData.<id(target_node_data, end_target);

    whole_8.<(index_pointer, index);
};

declare target_id: whole_8;

declare while_target_id_stack: AutoBufferStack8;

define get_target_id = function(): whole_8 {
    declare return_ = target_id;
    target_id = +(target_id, 1);

    return return_;
};

define parse_statement = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    while =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.COMMA) {
        increment_whole_8_pointer(index_pointer, 1);
    };

    declare done_anything = false;

    if Tokens.is_keyword(tokens, whole_8.>(index_pointer), "declare") {
        parse_declare(tokens, index_pointer, nodes);
        done_anything = true;
    };

    if &&(Tokens.is_keyword(tokens, whole_8.>(index_pointer), "return"), !(done_anything)) {
        parse_return(tokens, index_pointer, nodes);
        done_anything = true;
        return;
    };

    if &&(Tokens.is_keyword(tokens, whole_8.>(index_pointer), "while"), !(done_anything)) {
        parse_while(tokens, index_pointer, nodes);
        done_anything = true;
    };

    if !(done_anything) {
        if check_parse_assign(tokens, index_pointer, nodes) {
            done_anything = true;
        };
    };

    if &&(Tokens.is_keyword(tokens, whole_8.>(index_pointer), "break"), !(done_anything)) {
        parse_break(tokens, index_pointer, nodes);
        done_anything = true;
    };

    if !(done_anything) {
        parse_expression(tokens, index_pointer, nodes);
        if =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.SEMICOLON) {
            declare _ = nodes_append(nodes, NODE_ENDSTATEMENT, get_token_location_data(tokens, whole_8.>(index_pointer)));
            increment_whole_8_pointer(index_pointer, 1);
        };
    } else {
        declare _ = nodes_append(nodes, NODE_ENDSTATEMENT, get_token_location_data(tokens, -(whole_8.>(index_pointer), 1)));
    };
};

define parse_break = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    declare jump_data = NodeJumpData.pcast(nodes_append_data(nodes, NODE_JUMP, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeJumpData.<target_id(jump_data, whole_8.cast(autobuffer_stack8_peek(&(while_target_id_stack))));

    increment_whole_8_pointer(index_pointer, 2);
};

define parse_return = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    increment_whole_8_pointer(index_pointer, 1);

    parse_multiple_expressions(tokens, index_pointer, nodes, Token.SEMICOLON);

    declare node = nodes_append(nodes, NODE_RETURN, get_token_location_data(tokens, whole_8.>(index_pointer)));
    increment_whole_8_pointer(index_pointer, 1);
};

define check_parse_assign = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes): boolean {
    declare is_assign = true;
    declare index = whole_8.>(index_pointer);
    while true {
        if =(Tokens.get_id(tokens, index), Token.NAME) {
            declare name = Token.NameData.>name(Token.NameData.pcast(Tokens.get_pointer_data(tokens, index)));
            if !(=(Tokens.get_id(tokens, +(index, 1)), Token.OPEN_PARENTHESIS)) {
                if string=(name, "=") {
                    break;
                };
            };
        } else if =(Tokens.get_id(tokens, index), Token.KEYWORD) {
            is_assign = false;
            break;
        } else if =(Tokens.get_id(tokens, index), Token.SEMICOLON) {
            is_assign = false;
            break;
        };
        index = +(index, 1);
    };

    if is_assign {
        parse_assign(tokens, index_pointer, nodes);
        return true;
    };

    return false;
};

define parse_assign = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    declare names = autobuffer_new(40);
    declare name_index = 0;

    declare index = whole_8.>(index_pointer);
    declare saved_index = index;

    while !(Tokens.is_name(tokens, index, "=")) {
        index = +(index, 1);
    };
    index = +(index, 1);

    parse_multiple_expressions(tokens, &(index), nodes, Token.SEMICOLON);

    index = +(index, 1);

    declare start_stack = autobuffer_stack8_new(24);

    autobuffer_stack8_push(&(start_stack), saved_index);

    declare is_first = true;
    while true {
        while &&(!(=(Tokens.get_id(tokens, saved_index), Token.COMMA)), !(Tokens.is_name(tokens, saved_index, "="))) {
            saved_index = +(saved_index, 1);
        };

        if Tokens.is_name(tokens, saved_index, "=") {
            break;
        };

        if =(Tokens.get_id(tokens, saved_index), Token.COMMA) {
            saved_index = +(saved_index, 1);
        };

        autobuffer_stack8_push(&(start_stack), saved_index);
    };
    //while |(is_first, =(Tokens.get_id(tokens, saved_index), Token.COMMA)) {
    //    if =(Tokens.get_id(tokens, saved_index), Token.COMMA) {
    //        saved_index = +(saved_index, 1);
    //    };

    //    is_first = false;
    //};

    while >(AutoBufferStack8.>index(&(start_stack)), 0) {
        declare start = whole_8.cast(autobuffer_stack8_pop(&(start_stack)));

        parse_expression(tokens, &(start), nodes);
        declare retrieve_data = NodeRetrieveData.pcast(nodes_get_pointer_data(nodes, -(Nodes.>index(nodes), 3)));
        declare name = NodeRetrieveData.>name_single(retrieve_data);
        declare uses_previous = NodeRetrieveData.>uses_previous(retrieve_data);

        nodes_set_id(nodes, -(Nodes.>index(nodes), 3), NODE_ASSIGN);
        declare assign_data = NodeAssignData.pcast(retrieve_data);
        NodeAssignData.<name_single(assign_data, name);
        NodeAssignData.<uses_previous(assign_data, uses_previous);
    };

    whole_8.<(index_pointer, index);
};

define parse_while = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    increment_whole_8_pointer(index_pointer, 1);

    declare target1 = get_target_id();

    declare target2 = get_target_id();

    declare target_node1_data = NodeTargetData.pcast(nodes_append_data(nodes, NODE_TARGET, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeTargetData.<id(target_node1_data, target1);

    parse_expression(tokens, index_pointer, nodes);
    declare conditional_jump_data = NodeJumpConditionalData.pcast(nodes_append_data(nodes, NODE_JUMP_CONDITIONAL, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeJumpConditionalData.<target_id(conditional_jump_data, target2);
    NodeJumpConditionalData.<desired_state(conditional_jump_data, false);
    declare _ = nodes_append(nodes, NODE_ENDSTATEMENT, get_token_location_data(tokens, whole_8.>(index_pointer)));

    autobuffer_stack8_push(&(while_target_id_stack), target2);
    parse_expression(tokens, index_pointer, nodes);
    declare _ = autobuffer_stack8_pop(&(while_target_id_stack));

    declare jump_node_data = NodeJumpData.pcast(nodes_append_data(nodes, NODE_JUMP, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeJumpData.<target_id(jump_node_data, target1);

    declare target_node2_data = NodeTargetData.pcast(nodes_append_data(nodes, NODE_TARGET, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeTargetData.<id(target_node2_data, target2);

    increment_whole_8_pointer(index_pointer, 1);
};

define parse_declare = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    declare index = whole_8.>(index_pointer);

    declare parse_expression, variable_names, variable_types = parse_declare_variable_declaration(tokens, &(index), nodes);

    if parse_expression {
        index = +(index, 1);

        parse_multiple_expressions(tokens, &(index), nodes, Token.SEMICOLON);
    };

    declare i = 0;
    while !(=(array8_get(variable_names, i), 0)) {
        declare node_data = NodeDeclareData.pcast(nodes_append_data(nodes, NODE_DECLARE, get_token_location_data(tokens, index)));
        NodeDeclareData.<name(node_data, *.cast(array8_get(variable_names, i)));
        NodeDeclareData.<type(node_data, *.cast(array8_get(variable_types, i)));

        i = +(i, 1);
    };

    if parse_expression {
        declare temp = array8_length(variable_names);
        declare i = -(array8_length(variable_names), 1);
        while <(i, temp) {
            declare node_data = NodeAssignData.pcast(nodes_append_data(nodes, NODE_ASSIGN, get_token_location_data(tokens, whole_8.>(index_pointer))));
            NodeAssignData.<name_single(node_data, *.cast(array8_get(variable_names, i)));

            i = -(i, 1);
        };
    };

    index = +(index, 1);
    whole_8.<(index_pointer, index);
};

define parse_declare_variable_declaration = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes): boolean, *, * {
    declare index = whole_8.>(index_pointer);
    index = +(index, 1);

    declare names = autobuffer_new(40);
    declare types = autobuffer_new(40);

    declare name_index = 0;
    declare seen_item_name = false;
    declare parse_expression = false;
    while true {
        declare id = Tokens.get_id(tokens, index);
        if =(id, Token.COMMA) {
            name_index = +(name_index, 1);
            seen_item_name = false;
        };

        if =(id, Token.NAME) {
            declare name_value = Token.NameData.>name(Token.NameData.pcast(Tokens.get_pointer_data(tokens, index)));
            if seen_item_name {
                declare name = parse_name_array(tokens, &(index));
                autobuffer_array8_set(&(types), name_index, name);
            } else {
                name_value = parse_name(tokens, &(index));
                autobuffer_array8_set(&(names), name_index, name_value);
                autobuffer_array8_set(&(types), name_index, create_size_zero_array8_brk_allocate());
                seen_item_name = true;
            };
        } else {
            index = +(index, 1);
        };

        if =(Tokens.get_id(tokens, index), Token.NAME) {
            declare name_value = Token.NameData.>name(Token.NameData.pcast(Tokens.get_pointer_data(tokens, index)));
            if string=(name_value, "=") {
                parse_expression = true;
                break;
            };
        };
        if =(Tokens.get_id(tokens, index), Token.SEMICOLON) {
            parse_expression = false;
            break;
        };
    };

    whole_8.<(index_pointer, index);
    return parse_expression, AutoBuffer.>buffer(&(names)), AutoBuffer.>buffer(&(types));
};

define parse_multiple_expressions = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes, breaker: whole_8) {
    while !(=(Tokens.get_id(tokens, whole_8.>(index_pointer)), breaker)) {
        if =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.COMMA) {
            increment_whole_8_pointer(index_pointer, 1);
        } else if |(|(=(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.SEMICOLON), =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.CLOSED_PARENTHESIS)), =(Tokens.get_id(tokens, whole_8.>(index_pointer)), Token.CLOSED_CURLY_BRACKETS)) {
            print_token_error_beginning(tokens, whole_8.>(index_pointer));
            println("Unexpected token");
            exit(1);
        } else {
            parse_expression(tokens, index_pointer, nodes);
        };
    };
};

define parse_module = function(tokens: *Tokens.Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    declare _ = nodes_append(nodes, NODE_MODULE, get_token_location_data(tokens, whole_8.>(index_pointer)));

    increment_whole_8_pointer(index_pointer, 2);

    parse_multiple(tokens, index_pointer, nodes, Token.CLOSED_CURLY_BRACKETS);

    declare _ = nodes_append(nodes, NODE_ENDMODULE, get_token_location_data(tokens, whole_8.>(index_pointer)));

    increment_whole_8_pointer(index_pointer, 1);
};

define parse_individual = function(tokens: *Tokens.Tokens, index: *whole_8, nodes: *Nodes) {
    declare id = Tokens.get_id(tokens, whole_8.>(index));
    if =(id, Token.KEYWORD) {
        declare keyword_data = Token.KeywordData.pcast(Tokens.get_pointer_data(tokens, whole_8.>(index)));
        declare keyword = Token.KeywordData.>keyword(keyword_data);

        if string=(keyword, "function") {
            parse_function(tokens, index, nodes);
        };

        if string=(keyword, "structure") {
            parse_structure(tokens, index, nodes);
        };

        if string=(keyword, "module") {
            parse_module(tokens, index, nodes);
        };

        if string=(keyword, "define") {
            parse_define(tokens, index, nodes);
        };

        if string=(keyword, "declare") {
            parse_declare(tokens, index, nodes);
        };
    } else {
        parse_expression(tokens, index, nodes);
    };
};

define parse_multiple = function(tokens: *Tokens.Tokens, index: *whole_8, nodes: *Nodes, ending: whole_8) {
    declare Tokens.count = Tokens.Tokens.>index(tokens);
    while &&(!(=(Tokens.get_id(tokens, whole_8.>(index)), ending)), <(whole_8.>(index), Tokens.Tokens.>index(tokens))) {
        parse_individual(tokens, index, nodes);
    };
};

define parse = function(tokens: *Tokens.Tokens, nodes: *Nodes) {
    declare index = 0;
    parse_multiple(tokens, &(index), nodes, 0);
};
