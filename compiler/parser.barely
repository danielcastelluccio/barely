define tokenize_inner = function(auto_buffer: *AutoBuffer, tokens: *Tokens, file_name: *, row: *whole_8, column: *whole_8) {
    variable buffer = AutoBuffer.>buffer(auto_buffer);
    variable buffer_length = length(AutoBuffer.>buffer(auto_buffer));

    if =(buffer_length, 0) {
        return;
    };

    variable is_keyword = if string=(buffer, "function") true
    else if string=(buffer, "variable") true
    else if string=(buffer, "structure") true
    else if string=(buffer, "module") true
    else if string=(buffer, "return") true
    else if string=(buffer, "if") true
    else if string=(buffer, "else") true
    else if string=(buffer, "while") true
    else if string=(buffer, "global") true
    else if string=(buffer, "define") true
    else if string=(buffer, "break") true
    else false;

    if is_keyword {
        variable copied_buffer = copy_string_brk_allocate(buffer);

        variable keyword_data = TokenKeywordData.*cast(tokens_append_data(tokens, TOKEN_KEYWORD, file_name, whole_8.>(row), whole_8.>(column)));
        TokenKeywordData.<keyword(keyword_data, copied_buffer);
    } else if is_number(buffer) {
        tokenize_number(tokens, buffer, file_name, whole_8.>(row), whole_8.>(column));
    } else if |(string=(buffer, "true"), string=(buffer, "false")) {
        variable boolean_data = TokenBooleanData.*cast(tokens_append_data(tokens, TOKEN_BOOLEAN, file_name, whole_8.>(row), whole_8.>(column)));
        TokenBooleanData.<value(boolean_data, string=(buffer, "true"));
    } else {
        variable copied_buffer = copy_string_brk_allocate(buffer);

        variable name_data = TokenNameData.*cast(tokens_append_data(tokens, TOKEN_NAME, file_name, whole_8.>(row), whole_8.>(column)));
        TokenNameData.<name(name_data, copied_buffer);
    };
    
    increment_whole_8_pointer(column, buffer_length);
};

define tokenize_number = function(tokens: *Tokens, buffer: *, file_name: *, row: whole_8, column: whole_8) {
    variable number_data = TokenNumberData.*cast(tokens_append_data(tokens, TOKEN_NUMBER, file_name, row, column));

    // 0 = actual number, 1 = whole/integer, 2 = size
    variable stage = 0;
    variable type_buffer = autobuffer_buffer_new(8);
    variable size_buffer = autobuffer_buffer_new(8);
    variable number_buffer = autobuffer_buffer_new(8);

    variable j = 0;
    while <(j, length(buffer)) {
        variable character = whole_1.>(whole_1.*cast(+(buffer, j)));
        if =(character, ASCII_UNDERSCORE) {
            stage = +(stage, 1);
        } else if =(stage, 1) {
            autobuffer_buffer_push_whole_1(&(type_buffer), character);
        } else if =(stage, 2) {
            autobuffer_buffer_push_whole_1(&(size_buffer), character);
        } else {
            autobuffer_buffer_push_whole_1(&(number_buffer), character);
        };
        
        j = +(j, 1);
    };

    if =(any_1.>(any_1.*cast(buffer)), ASCII_MINUS) {
        if =(AutoBufferBuffer.>index(&(type_buffer)), 0) {
            autobuffer_buffer_push_string(&(type_buffer), "integer");
        };
    } else {
        if =(AutoBufferBuffer.>index(&(type_buffer)), 0) {
            autobuffer_buffer_push_string(&(type_buffer), "whole");
        };
    };

    if =(AutoBufferBuffer.>index(&(size_buffer)), 0) {
        autobuffer_buffer_push_string(&(size_buffer), "8");
    };

    if string=(autobuffer_buffer_get_buffer_pointer(&(type_buffer)), "whole") {
        TokenNumberData.<type(number_data, 0);
    } else {
        TokenNumberData.<type(number_data, 1);
    };

    variable size_bytes = to_number(autobuffer_buffer_get_buffer_pointer(&(size_buffer)));

    if !(check_number_fits(tokens, size_bytes, TokenNumberData.>type(number_data), buffer)) {
        print_token_error_beginning(tokens, -(Tokens.>index(tokens), 1));
        print("Number literal '");
        print(autobuffer_buffer_get_buffer_pointer(&(number_buffer)));
        print("' cannot fit in type '");
        print(autobuffer_buffer_get_buffer_pointer(&(type_buffer)));
        print("_");
        print(autobuffer_buffer_get_buffer_pointer(&(size_buffer)));
        println("'");
        exit(1);
    };

    TokenNumberData.<size(number_data, size_bytes);
    TokenNumberData.<value(number_data, to_number_size_signed(buffer, size_bytes, false));
};

define check_number_fits = function(tokens: *Tokens, size_bytes: whole_8, type: whole_8, buffer: *): boolean {
    variable size_bits = 2;
    variable m = 1;
    while <(m, *(size_bytes, 8)) {
        size_bits = *(2, size_bits);
        m = +(m, 1);
    };
    size_bits = -(size_bits, 1);
    if =(type, 1) {
        size_bits = /(size_bits, 2);
    };

    variable number = 0;

    if =(any_1.>(any_1.*cast(buffer)), ASCII_MINUS) {
        if =(type, 0) {
            number = +(size_bits, 1);
        } else {
            number = -(to_number(+(buffer, 1)), 1);
        };
    } else {
        number = to_number(buffer);
    };

    return !(>(number, size_bits));
};

define tokenize = function(file_name: *, contents: *, tokens: *Tokens) {
    variable index = 0;
    variable row = 1;
    variable column = 1;
    variable column_cache = 1;

    variable contents_length = length(contents);

    variable buffer = autobuffer_new(64);
    variable buffer_index = 0;

    variable in_quotes = false;
    variable in_comment = false;

    while <(index, contents_length) {
        variable character_pointer = any_1.*cast(+(contents, index));
        variable character_pointer_next = any_1.*cast(+(contents, +(index, 1)));
        variable handled = false;

        if !(in_quotes) {
            if !(in_comment) {
                // a macro would probably be better suited for this
                handle_special_character(any_1.>(character_pointer), ASCII_OPEN_PARENTHESIS, TOKEN_OPEN_PARENTHESIS, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
                handle_special_character(any_1.>(character_pointer), ASCII_CLOSED_PARENTHESIS, TOKEN_CLOSED_PARENTHESIS, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
                handle_special_character(any_1.>(character_pointer), ASCII_OPEN_CURLY_BRACKETS, TOKEN_OPEN_CURLY_BRACKETS, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
                handle_special_character(any_1.>(character_pointer), ASCII_CLOSED_CURLY_BRACKETS, TOKEN_CLOSED_CURLY_BRACKETS, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
                handle_special_character(any_1.>(character_pointer), ASCII_OPEN_BRACKET, TOKEN_OPEN_BRACKET, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
                handle_special_character(any_1.>(character_pointer), ASCII_CLOSED_BRACKET, TOKEN_CLOSED_BRACKET, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
                handle_special_character(any_1.>(character_pointer), ASCII_COMMA, TOKEN_COMMA, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
                handle_special_character(any_1.>(character_pointer), ASCII_SEMICOLON, TOKEN_SEMICOLON, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
                handle_special_character(any_1.>(character_pointer), ASCII_PERIOD, TOKEN_PERIOD, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
                handle_special_character(any_1.>(character_pointer), ASCII_COLON, TOKEN_COLON, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));

                handle_break(any_1.>(character_pointer), ASCII_SPACE, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
                handle_break(any_1.>(character_pointer), ASCII_LINE_FEED, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
                handle_break(any_1.>(character_pointer), ASCII_TAB, &(buffer), &(buffer_index), tokens, file_name, &(row), &(column), &(handled));
            };
        };

        if !(in_comment) {
            if =(any_1.>(character_pointer), ASCII_QUOTATION) {
                if in_quotes {
                    variable buffer_length = length(AutoBuffer.>buffer(&(buffer)));
                    variable buffer_copy = copy_string_brk_allocate(AutoBuffer.>buffer(&(buffer)));

                    variable string_pointer_data = TokenStringData.*cast(tokens_append_data(tokens, TOKEN_STRING, file_name, row, column));
                    TokenStringData.<value(string_pointer_data, buffer_copy);

                    autobuffer_reset(&(buffer));
                    buffer_index = 0;
                    column = +(+(column, buffer_length), 2);
                };

                in_quotes = !(in_quotes);
                handled = true;
            };
        };
        if =(any_1.>(character_pointer), ASCII_SLASH) {
            if =(any_1.>(character_pointer_next), ASCII_SLASH) {
                in_comment = true;
                handled = true;
            };
            column = +(column, 1);
        };

        if !(handled) {
            if !(in_comment) {
                autobuffer_set_any_1(&(buffer), any_1.>(any_1.*cast(character_pointer)), buffer_index);

                buffer_index = +(buffer_index, 1);
            };
        };

        if =(any_1.>(character_pointer), ASCII_LINE_FEED) {
            in_comment = false;
            handled = true;
            autobuffer_reset(&(buffer));
            buffer_index = 0;

            column = 1;
            row = +(row, 1);
        };

        index = +(index, 1);
    };
};

define handle_special_character = function(current_character: any_1, desired_character: whole_1, token: whole_8, buffer: *AutoBuffer, buffer_index: *whole_8, tokens: *Tokens, file_name: *, row: *whole_8, column: *whole_8, handled: *boolean) {
    if =(current_character, desired_character) {
        tokenize_inner(buffer, tokens, file_name, row, column);
        boolean.<(handled, true);
        autobuffer_reset(buffer);
        whole_8.<(buffer_index, 0);

        variable _ = tokens_append(tokens, token, file_name, whole_8.>(row), whole_8.>(column));
        increment_whole_8_pointer(column, 1);
    };
};

define handle_break = function(current_character: any_1, desired_character: whole_1, buffer: *AutoBuffer, buffer_index: *whole_8, tokens: *Tokens, file_name: *, row: *whole_8, column: *whole_8, handled: *boolean) {
    if =(current_character, desired_character) {
        tokenize_inner(buffer, tokens, file_name, row, column);
        boolean.<(handled, true);
        autobuffer_reset(buffer);
        whole_8.<(buffer_index, 0);

        increment_whole_8_pointer(column, 1);
    };
};

define get_token_location_data = function(tokens: *Tokens, index: whole_8): *, whole_8, whole_8 {
    variable data = tokens_get_location_data(tokens, index);
    return TokenLocationData.>file(data), TokenLocationData.>row(data), TokenLocationData.>column(data);
};

define print_token_error_beginning = function(tokens: *Tokens, location: whole_8) {
    variable location_data = tokens_get_location_data(tokens, location);
    print("[ERROR] ");
    print(TokenLocationData.>file(location_data));
    print(":");
    print_whole_8(TokenLocationData.>row(location_data));
    print(":");
    print_whole_8(TokenLocationData.>column(location_data));
    print(": ");
};

define parse_define = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable index = whole_8.>(index_pointer);
    variable name_token_pointer_data = TokenNameData.*cast(tokens_get_pointer_data(tokens, +(index, 1)));
    variable name = TokenNameData.>name(name_token_pointer_data);

    variable type = *.cast(0);
    variable value_offset = if =(tokens_get_id(tokens, +(index, 2)), TOKEN_COLON) {
        variable type_token_pointer_data = TokenNameData.*cast(tokens_get_pointer_data(tokens, +(index, 3)));
        type = TokenNameData.>name(type_token_pointer_data);
        5
    } else {
        3
    };

    if =(tokens_get_id(tokens, +(index, value_offset)), TOKEN_NUMBER) {
        variable value_token_pointer_data = TokenNumberData.*cast(tokens_get_pointer_data(tokens, +(index, value_offset)));

        variable value = brk_allocate(8);
        whole_8.<(whole_8.*cast(value), TokenNumberData.>value(value_token_pointer_data));
    };

    if =(type, 0) {
        type = get_define_type(tokens, &(index), value_offset);
    };

    variable define_node_data = NodeDefineData.*cast(nodes_append_data(nodes, NODE_DEFINE, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeDefineData.<name(define_node_data, name);
    NodeDefineData.<type(define_node_data, type);

    increment_whole_8_pointer(index_pointer, value_offset);

    parse_individual(tokens, index_pointer, nodes, is_target_internal_function);

    variable end_define_node_data = NodeEndDefineData.*cast(nodes_append_data(nodes, NODE_ENDDEFINE, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeEndDefineData.<type(end_define_node_data, type);

    increment_whole_8_pointer(index_pointer, 1);
};

define get_define_type = function(tokens: *Tokens, index_pointer: *whole_8, value_offset: whole_8): * {
    variable index = whole_8.>(index_pointer);

    variable type = if =(tokens_get_id(tokens, +(index, value_offset)), TOKEN_NUMBER) {
        "whole_8"
    } else if tokens_is_keyword(tokens, +(index, value_offset), "function") {
        function_definition_to_type(tokens, &(index), value_offset)
    } else if tokens_is_keyword(tokens, +(index, value_offset), "structure") {
        structure_definition_to_type(tokens, &(index), value_offset)
    } else if tokens_is_keyword(tokens, +(index, value_offset), "module") {
        "module"
    } else {
        global_definition_to_type(tokens, &(index), value_offset)
    };

    whole_8.<(index_pointer, index);
    return type;
};

define function_definition_to_type = function(tokens: *Tokens, index_pointer: *whole_8, value_offset: whole_8): * {
    variable index = whole_8.>(index_pointer);

    variable index_temp = +(+(index, value_offset), 2);

    variable type_buffer = autobuffer_buffer_new(16);
    autobuffer_buffer_push_string(&(type_buffer), "*function[");

    variable is_type = false;
    while !(=(tokens_get_id(tokens, index_temp), TOKEN_CLOSED_PARENTHESIS)) {
        if =(tokens_get_id(tokens, index_temp), TOKEN_NAME) {
            if is_type {
                autobuffer_buffer_push_string(&(type_buffer), parse_name(tokens, &(index_temp)));
            } else {
                index_temp = +(index_temp, 1);
            };
            is_type = !(is_type);
        } else if =(tokens_get_id(tokens, index_temp), TOKEN_COLON) {
            index_temp = +(index_temp, 1);
        } else if =(tokens_get_id(tokens, index_temp), TOKEN_COMMA) {
            index_temp = +(index_temp, 1);
            autobuffer_buffer_push_string(&(type_buffer), ",");
        };
    };
    index_temp = +(index_temp, 1);

    autobuffer_buffer_push_string(&(type_buffer), ":");

    if !(=(tokens_get_id(tokens, index_temp), TOKEN_OPEN_CURLY_BRACKETS)) {
        index_temp = +(index_temp, 1);

        while !(=(tokens_get_id(tokens, index_temp), TOKEN_OPEN_CURLY_BRACKETS)) {
            if =(tokens_get_id(tokens, index_temp), TOKEN_NAME) {
                autobuffer_buffer_push_string(&(type_buffer), parse_name(tokens, &(index_temp)));
            } else {
                index_temp = +(index_temp, 1);
                autobuffer_buffer_push_string(&(type_buffer), ",");
            };
        };
    };

    autobuffer_buffer_push_string(&(type_buffer), "]");

    whole_8.<(index_pointer, index)

    AutoBuffer.>buffer(&(AutoBufferBuffer.>autobuffer(&(type_buffer))))
};

define structure_definition_to_type = function(tokens: *Tokens, index_pointer: *whole_8, value_offset: whole_8): * {
    variable index = whole_8.>(index_pointer);

    variable index_temp = +(+(index, value_offset), 2);

    variable type_buffer = autobuffer_buffer_new(16);
    autobuffer_buffer_push_string(&(type_buffer), "structure[");

    variable added_any = false;

    while !(=(tokens_get_id(tokens, index_temp), TOKEN_CLOSED_CURLY_BRACKETS)) {
        if =(tokens_get_id(tokens, index_temp), TOKEN_NAME) {
            autobuffer_buffer_push_string(&(type_buffer), parse_name(tokens, &(index_temp)));
        } else if =(tokens_get_id(tokens, index_temp), TOKEN_COLON) {
            index_temp = +(index_temp, 1);
            autobuffer_buffer_push_string(&(type_buffer), ":");
        } else if =(tokens_get_id(tokens, index_temp), TOKEN_SEMICOLON) {
            index_temp = +(index_temp, 1);
            autobuffer_buffer_push_string(&(type_buffer), ",");
            added_any = true;
        };
    };
    index_temp = +(index_temp, 1);

    if added_any {
        AutoBufferBuffer.<index(&(type_buffer), -(AutoBufferBuffer.>index(&(type_buffer)), 1));
    };

    autobuffer_buffer_push_string(&(type_buffer), "]");

    whole_8.<(index_pointer, index)

    AutoBuffer.>buffer(&(AutoBufferBuffer.>autobuffer(&(type_buffer))))
};

define global_definition_to_type = function(tokens: *Tokens, index_pointer: *whole_8, value_offset: whole_8): * {
    variable index = whole_8.>(index_pointer);

    variable global_type_name = TokenNameData.>name(TokenNameData.*cast(tokens_get_pointer_data(tokens, +(+(index, value_offset), 2))));
    variable global_type = concatenate3_brk_allocate("global[", global_type_name, "]");

    whole_8.<(index_pointer, index)

    global_type
};

define parse_global = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    variable index = whole_8.>(index_pointer);
    variable type_token_pointer_data = TokenNameData.*cast(tokens_get_pointer_data(tokens, +(index, 2)));
    variable type = TokenNameData.>name(type_token_pointer_data);

    variable global_node_data = NodeGlobalData.*cast(nodes_append_data(nodes, NODE_GLOBAL, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeGlobalData.<type(global_node_data, type);

    increment_whole_8_pointer(index_pointer, 4);
};

define parse_structure = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes) {
    variable index = whole_8.>(index_pointer);

    variable member_names = autobuffer_new(40);
    variable member_types = autobuffer_new(40);
    variable member_index = 0;

    index = +(index, 2);

    variable seen_item_name = false;

    while !(=(tokens_get_id(tokens, index), TOKEN_CLOSED_CURLY_BRACKETS)) {
        variable id = tokens_get_id(tokens, index);

        if =(id, TOKEN_NAME) {
            if seen_item_name {
                autobuffer_array8_set(&(member_types), member_index, parse_name(tokens, &(index)));
                member_index = +(member_index, 1);
            } else {
                autobuffer_array8_set(&(member_names), member_index, parse_name(tokens, &(index)));
            };

            seen_item_name = !(seen_item_name);
        } else if =(id, TOKEN_COLON) {
            index = +(index, 1);
        } else if =(id, TOKEN_SEMICOLON) {
            index = +(index, 1);
        };
    };

    variable structure_data = NodeStructureData.*cast(nodes_append_data(nodes, NODE_STRUCTURE, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeStructureData.<item_names(structure_data, AutoBuffer.>buffer(&(member_names)));
    NodeStructureData.<item_types(structure_data, AutoBuffer.>buffer(&(member_types)));

    index = +(index, 1);

    whole_8.<(index_pointer, index);
};

define parse_name = function(tokens: *Tokens, index_pointer: *whole_8): * {
    variable buffer = autobuffer_buffer_new(64);
    variable token_name = TokenNameData.>name(TokenNameData.*cast(tokens_get_pointer_data(tokens, whole_8.>(index_pointer))));
    autobuffer_buffer_push_string(&(buffer), token_name);
    increment_whole_8_pointer(index_pointer, 1);

    variable inner = 0;
    while |(>(inner, 0), =(tokens_get_id(tokens, whole_8.>(index_pointer)), TOKEN_OPEN_BRACKET)) {
        variable id = tokens_get_id(tokens, whole_8.>(index_pointer));
        variable pointer_data = tokens_get_pointer_data(tokens, whole_8.>(index_pointer));
        if =(id, TOKEN_OPEN_BRACKET) {
            autobuffer_buffer_push_string(&(buffer), "[");
            inner = +(inner, 1);
        } else if =(id, TOKEN_CLOSED_BRACKET) {
            autobuffer_buffer_push_string(&(buffer), "]");
            inner = -(inner, 1);
        } else if =(id, TOKEN_COMMA) {
            autobuffer_buffer_push_string(&(buffer), ",");
        } else if =(id, TOKEN_COLON) {
            autobuffer_buffer_push_string(&(buffer), ":");
        } else if =(id, TOKEN_NAME) {
            autobuffer_buffer_push_string(&(buffer), TokenNameData.>name(TokenNameData.*cast(pointer_data)));
        };
        increment_whole_8_pointer(index_pointer, 1);
    };

    return AutoBuffer.>buffer(&(AutoBufferBuffer.>autobuffer(&(buffer))));
};

define parse_function = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable index = whole_8.>(index_pointer);

    variable function_data = NodeFunctionData.*cast(nodes_append_data(nodes, NODE_FUNCTION, get_token_location_data(tokens, whole_8.>(index_pointer))));

    index = +(index, 2);

    variable function_argument_names, function_arguments, function_returns = parse_function_definition(tokens, &(index), nodes);

    variable has_body = =(tokens_get_id(tokens, index), TOKEN_OPEN_CURLY_BRACKETS);

    NodeFunctionData.<argument_names(function_data, function_argument_names);
    NodeFunctionData.<argument_types(function_data, function_arguments);
    NodeFunctionData.<returns(function_data, function_returns);

    if has_body {
        index = +(index, 1);

        variable _ = nodes_append(nodes, NODE_SCOPE, get_token_location_data(tokens, index));
        while !(=(tokens_get_id(tokens, index), TOKEN_CLOSED_CURLY_BRACKETS)) {
            parse_statement(tokens, &(index), nodes, is_target_internal_function);
        };

        index = +(index, 1);

        
        if !(=(nodes_get_id(nodes, -(Nodes.>index(nodes), 1)), NODE_RETURN)) {
            variable _ = nodes_append(nodes, NODE_RETURN, get_token_location_data(tokens, -(index, 1)));
        };

        variable _ = nodes_append(nodes, NODE_ENDSCOPE, get_token_location_data(tokens, index));
    };

    variable _ = nodes_append(nodes, NODE_ENDFUNCTION, get_token_location_data(tokens, index));

    whole_8.<(index_pointer, index);
};

define parse_function_definition = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes): *, *, * {
    variable index = whole_8.>(index_pointer);

    variable function_argument_names = autobuffer_new(40);
    variable function_arguments = autobuffer_new(40);
    variable function_returns = autobuffer_new(40);

    variable is_name = true;
    variable arguments_index = 0;
    while !(=(tokens_get_id(tokens, index), TOKEN_CLOSED_PARENTHESIS)) {
        variable id = tokens_get_id(tokens, index);

        if =(id, TOKEN_NAME) {
            variable token_name = TokenNameData.>name(TokenNameData.*cast(tokens_get_pointer_data(tokens, index)));

            if is_name {
                autobuffer_array8_set(&(function_argument_names), arguments_index, token_name);
                index = +(index, 1);
            } else {
                token_name = parse_name(tokens, &(index));
                autobuffer_array8_set(&(function_arguments), arguments_index, token_name);
                arguments_index = +(arguments_index, 1);
            };

            is_name = !(is_name);
        } else if |(=(id, TOKEN_COMMA), =(id, TOKEN_COLON)) {
            index = +(index, 1);
        };
    };
    
    index = +(index, 1);

    variable returns_index = 0;
    while &&(!(=(tokens_get_id(tokens, index), TOKEN_OPEN_CURLY_BRACKETS)), !(=(tokens_get_id(tokens, index), TOKEN_SEMICOLON))) {
        variable id = tokens_get_id(tokens, index);

        if =(id, TOKEN_NAME) {
            variable token_name = parse_name(tokens, &(index));

            autobuffer_array8_set(&(function_returns), returns_index, token_name);
            returns_index = +(returns_index, 1);
        } else if |(=(id, TOKEN_COMMA), =(id, TOKEN_COLON)) {
            index = +(index, 1);
        };

    };

    whole_8.<(index_pointer, index);

    return AutoBuffer.>buffer(&(function_argument_names)), AutoBuffer.>buffer(&(function_arguments)), AutoBuffer.>buffer(&(function_returns));
};

define parse_invoke_parenthesis = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    increment_whole_8_pointer(index_pointer, 1);

    parse_multiple_expressions(tokens, index_pointer, nodes, is_target_internal_function, TOKEN_CLOSED_PARENTHESIS);

    increment_whole_8_pointer(index_pointer, 1);
};

define parse_invoke_parenthesis_ending = function(tokens: *Tokens, index_in: whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable index = index_in;

    variable inner = 0_integer_8;
    while |(>(inner, 0_integer_8), =(tokens_get_id(tokens, index), TOKEN_OPEN_PARENTHESIS)) {
        variable id = tokens_get_id(tokens, index);
        if =(id, TOKEN_OPEN_PARENTHESIS) {
            if =(inner, 0_integer_8) {
                variable inside_index = +(index, 1);
                variable inside_inner = 1_integer_8;
                while >(inside_inner, 0_integer_8) {
                    variable id3 = tokens_get_id(tokens, inside_index);
                    if =(id3, TOKEN_OPEN_PARENTHESIS) {
                        inside_inner = +(inside_inner, 1_integer_8);
                    } else if =(id3, TOKEN_CLOSED_PARENTHESIS) {
                        inside_inner = -(inside_inner, 1_integer_8);
                    } else if =(id3, TOKEN_SEMICOLON) {
                        print_token_error_beginning(tokens, index);
                        println("Unclosed parenthesis");
                        exit(1);
                    };

                    inside_index = +(inside_index, 1);
                };
                parse_invoke_parenthesis_ending(tokens, inside_index, nodes, is_target_internal_function);
                parse_invoke_parenthesis(tokens, &(index), nodes, is_target_internal_function);
                return;
            } else {
                inner = +(inner, 1_integer_8);
                index = +(index, 1);
            };
        } else if =(id, TOKEN_CLOSED_PARENTHESIS) {
            inner = -(inner, 1_integer_8);
            index = +(index, 1);
        };
    };
};

define parse_expression = function(tokens: *Tokens, index_pointer: *whole_8, nodes_in: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable index = whole_8.>(index_pointer);

    variable id = tokens_get_id(tokens, index);
    variable pointer_data = tokens_get_pointer_data(tokens, index);

    variable nodes_temp = nodes_new();
    variable nodes = &(nodes_temp);

    variable nodes_index = Nodes.>index(nodes);
    variable nodes_initial_index = Nodes.>index(nodes_in);

    check_parse_simple_expressions(tokens, &(index), nodes, id, pointer_data);

    if =(id, TOKEN_OPEN_CURLY_BRACKETS) {
        variable _ = nodes_append(nodes, NODE_SCOPE, get_token_location_data(tokens, index));
        index = +(index, 1);
        while !(=(tokens_get_id(tokens, index), TOKEN_CLOSED_CURLY_BRACKETS)) {
            parse_statement(tokens, &(index), nodes, is_target_internal_function);
        };
        index = +(index, 1);
        variable _ = nodes_append(nodes, NODE_ENDSCOPE, get_token_location_data(tokens, index));
    };

    if =(id, TOKEN_KEYWORD) {
        variable name_value = TokenNameData.>name(TokenNameData.*cast(tokens_get_pointer_data(tokens, whole_8.>(index_pointer))));
        if string=(name_value, "if") {
            parse_if(tokens, &(index), nodes, is_target_internal_function);
        };
    };

    check_parse_invoke_parenthesis_chain(tokens, &(index), nodes, nodes_in, is_target_internal_function);

    if =(tokens_get_id(tokens, index), TOKEN_PERIOD) {
        parse_period(tokens, &(index), nodes_in, nodes_initial_index, is_target_internal_function);
    };

    whole_8.<(index_pointer, index);
};

define check_parse_invoke_parenthesis_chain = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, nodes_in: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable index = whole_8.>(index_pointer);

    variable nodes_moved_count = Nodes.>index(nodes);

    variable nodes_index = Nodes.>index(nodes);

    parse_invoke_parenthesis_ending(tokens, index, nodes_in, is_target_internal_function);

    autobuffer_set(&(Nodes.>buffer(nodes_in)), AutoBuffer.>buffer(&(Nodes.>buffer(nodes))), *(Nodes.>index(nodes_in), NODE_SIZE), *(nodes_moved_count, NODE_SIZE));
    Nodes.<index(nodes_in, +(Nodes.>index(nodes_in), nodes_moved_count));

    if =(tokens_get_id(tokens, index), TOKEN_OPEN_PARENTHESIS) {
        variable previous_retrieve_name = NodeRetrieveData.>name(NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(nodes_index, 1))));

        parse_invoke_parenthesis_chain(tokens, &(index), nodes_in, previous_retrieve_name, is_target_internal_function);
    };

    whole_8.<(index_pointer, index);
};

define check_parse_simple_expressions = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, token_id: whole_8, token_pointer_data: *) {
    variable index = whole_8.>(index_pointer);

    if =(token_id, TOKEN_NAME) {
        variable retrieve_name = TokenNameData.>name(TokenNameData.*cast(token_pointer_data));
        variable retrieve_node_data = NodeRetrieveData.*cast(nodes_append_data(nodes, NODE_RETRIEVE, get_token_location_data(tokens, index)));
        NodeRetrieveData.<name(retrieve_node_data, retrieve_name);

        index = +(index, 1);
    };

    if =(token_id, TOKEN_STRING) {
        variable string_value = TokenStringData.>value(TokenStringData.*cast(token_pointer_data));
        variable string_pointer_data = NodeStringData.*cast(nodes_append_data(nodes, NODE_STRING, get_token_location_data(tokens, index)));
        NodeStringData.<value(string_pointer_data, string_value);

        index = +(index, 1);
    };

    if =(token_id, TOKEN_NUMBER) {
        variable number_token_data = TokenNumberData.*cast(token_pointer_data);
        variable number_node_data = NodeNumberData.*cast(nodes_append_data(nodes, NODE_NUMBER, get_token_location_data(tokens, index)));
        NodeNumberData.<value(number_node_data, TokenNumberData.>value(number_token_data));
        NodeNumberData.<type(number_node_data, TokenNumberData.>type(number_token_data));
        NodeNumberData.<size(number_node_data, TokenNumberData.>size(number_token_data));

        index = +(index, 1);
    };

    if =(token_id, TOKEN_BOOLEAN) {
        variable boolean_value = TokenBooleanData.>value(TokenBooleanData.*cast(token_pointer_data));
        variable boolean_node_data = NodeBooleanData.*cast(nodes_append_data(nodes, NODE_BOOLEAN, get_token_location_data(tokens, index)));
        NodeBooleanData.<value(boolean_node_data, boolean_value);

        index = +(index, 1);
    };

    whole_8.<(index_pointer, index);
};

define parse_period = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, nodes_initial_index: whole_8, is_target_internal_function: *function[*:boolean]) {
    variable index = whole_8.>(index_pointer);

    variable before_period_size = *(-(Nodes.>index(nodes), nodes_initial_index), NODE_SIZE);
    variable before_period_cached = brk_allocate(before_period_size);
    copy(+(AutoBuffer.>buffer(&(Nodes.>buffer(nodes))), *(nodes_initial_index, NODE_SIZE)), before_period_cached, before_period_size);

    Nodes.<index(nodes, nodes_initial_index);

    index = +(index, 1);
    parse_expression(tokens, &(index), nodes, is_target_internal_function);

    if =(nodes_get_id(nodes, -(Nodes.>index(nodes), 1)), NODE_INVOKE) {
        Nodes.<index(nodes, -(Nodes.>index(nodes), 1));
    };

    variable invoke_data = NodeInvokeData.*cast(nodes_get_pointer_data(nodes, Nodes.>index(nodes)));
    variable is_invoke = =(nodes_get_id(nodes, Nodes.>index(nodes)), NODE_INVOKE);
    variable name = NodeInvokeData.>name(invoke_data);
    variable is_pointer = NodeInvokeData.>is_pointer(invoke_data);

    variable nodes_index_before_cached = Nodes.>index(nodes);
    copy(before_period_cached, +(AutoBuffer.>buffer(&(Nodes.>buffer(nodes))), *(Nodes.>index(nodes), NODE_SIZE)), before_period_size);
    variable retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, nodes_index_before_cached));
    if =(nodes_get_id(nodes, -(nodes_index_before_cached, 1)), NODE_RETRIEVE) {
        NodeRetrieveData.<is_module(retrieve_data, true);
    };

    Nodes.<index(nodes, +(Nodes.>index(nodes), /(before_period_size, NODE_SIZE)));

    if is_pointer {
        variable invoke_data = NodeInvokeData.*cast(nodes_append_data(nodes, NODE_INVOKE, get_token_location_data(tokens, index)));
        NodeInvokeData.<has_specifier(invoke_data, true);
        NodeInvokeData.<is_pointer(invoke_data, true);
    } else if is_invoke {
        variable invoke_data = NodeInvokeData.*cast(nodes_append_data(nodes, NODE_INVOKE, get_token_location_data(tokens, index)));
        NodeInvokeData.<name(invoke_data, name);
        NodeInvokeData.<has_specifier(invoke_data, true);
        nodes_index_before_cached = +(nodes_index_before_cached, 1);
    };
    parse_period_non_internal(tokens, index, nodes, nodes_index_before_cached);

    whole_8.<(index_pointer, index);
};

define parse_period_non_internal = function(tokens: *Tokens, index: whole_8, nodes: *Nodes, nodes_index_before_cached: whole_8) {
    variable nodes_index_before = nodes_index_before_cached;
    variable function_retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(nodes_index_before_cached, 1)));
    variable function_name = NodeRetrieveData.>name(function_retrieve_data);

    variable count = 0;
    variable before_index = -(nodes_index_before_cached, 1);
    while =(nodes_get_id(nodes, before_index), NODE_RETRIEVE) {
        variable retrieve_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, before_index));
        if !(NodeRetrieveData.>is_module(retrieve_data)) {
            break;
        };

        count = +(count, 1);
        before_index = +(before_index, 1);
    };

    if =(count, 0) {
        NodeRetrieveData.<using_module(function_retrieve_data, true);
    };
};

define parse_invoke_parenthesis_chain = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, previous_retrieve_name: *, is_target_internal_function: *function[*:boolean]) {
    variable index = whole_8.>(index_pointer);
    variable inner = 0_integer_8;

    variable is_first = true;

    while |(>(inner, 0_integer_8), =(tokens_get_id(tokens, index), TOKEN_OPEN_PARENTHESIS)) {
        variable id2 = tokens_get_id(tokens, index);
        if =(id2, TOKEN_OPEN_PARENTHESIS) {
            if =(inner, 0_integer_8) {
                variable is_special = false;
                variable is_pointer = false;
                variable retrieve_name = previous_retrieve_name;
                if is_first {
                    is_special = is_special_function(retrieve_name, is_target_internal_function);
                    if string=(retrieve_name, "&") {
                        is_pointer = true;
                    };
                };

                if is_special {
                    nodes_set_skip(nodes, -(Nodes.>index(nodes), 1));

                    if is_pointer {
                        variable _ = nodes_append(nodes, NODE_POINTER, get_token_location_data(tokens, whole_8.>(index_pointer)));
                    } else {
                        variable invoke_data = NodeInvokeData.*cast(nodes_append_data(nodes, NODE_INVOKE, get_token_location_data(tokens, whole_8.>(index_pointer))));
                        NodeInvokeData.<name(invoke_data, retrieve_name);
                    };
                } else {
                    variable invoke_data = NodeInvokeData.*cast(nodes_append_data(nodes, NODE_INVOKE, get_token_location_data(tokens, whole_8.>(index_pointer))));
                    NodeInvokeData.<is_pointer(invoke_data, true);
                };

                is_first = false;
            };
            inner = +(inner, 1_integer_8);
        } else if =(id2, TOKEN_CLOSED_PARENTHESIS) {
            inner = -(inner, 1_integer_8);
        };
        index = +(index, 1);
    };

    whole_8.<(index_pointer, index);
};

define is_special_function = function(name: *, is_target_internal_function: *function[*:boolean]): boolean {
    return if string=(name, "+") {
        true
    } else if string=(name, "-") {
        true
    } else if string=(name, "*") {
        true
    } else if string=(name, "/") {
        true
    } else if string=(name, "%") {
        true
    } else if string=(name, "=") {
        true
    } else if string=(name, ">") {
        true
    } else if string=(name, "<") {
        true
    } else if string=(name, "&") {
        true
    } else if string=(name, "!") {
        true
    } else if string=(name, "|") {
        true
    } else if string=(name, "&&") {
        true
    } else if string_length=(name, "<", 1) {
        true
    } else if string_length=(name, ">", 1) {
        true
    } else if string_length=(name, "cast", 4) {
        true
    } else if string_length=(name, "*cast", 5) {
        true
    } else if is_target_internal_function(name) {
        true
    } else {
        false
    };
};

define parse_if = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable index = whole_8.>(index_pointer);

    variable end_target = get_target_id();

    variable end_if: *NodeEndIfBlockData;

    while =(tokens_get_id(tokens, index), TOKEN_KEYWORD) {
        variable target = get_target_id();
        variable token_data = TokenKeywordData.*cast(tokens_get_pointer_data(tokens, index));
        variable token_index = index;

        if tokens_is_keyword(tokens, token_index, "if") {
            index = +(index, 1);

            parse_expression(tokens, &(index), nodes, is_target_internal_function);
            variable conditional_jump_data = NodeJumpConditionalData.*cast(nodes_append_data(nodes, NODE_JUMP_CONDITIONAL, get_token_location_data(tokens, index)));
            NodeJumpConditionalData.<target_id(conditional_jump_data, target);
        } else if &&(tokens_is_keyword(tokens, token_index, "else"), tokens_is_keyword(tokens, token_index, "if")) {
            index = +(index, 2);

            parse_expression(tokens, &(index), nodes, is_target_internal_function);
            variable conditional_jump_data = NodeJumpConditionalData.*cast(nodes_append_data(nodes, NODE_JUMP_CONDITIONAL, get_token_location_data(tokens, index)));
            NodeJumpConditionalData.<target_id(conditional_jump_data, target);
        } else {
            index = +(index, 1);
        };

        variable _ = nodes_append(nodes, NODE_STARTIFBLOCK, get_token_location_data(tokens, index));
        parse_expression(tokens, &(index), nodes, is_target_internal_function);

        variable jump_data = NodeJumpData.*cast(nodes_append_data(nodes, NODE_JUMP, get_token_location_data(tokens, index)));
        NodeJumpData.<target_id(jump_data, end_target);

        end_if = NodeEndIfBlockData.*cast(nodes_append_data(nodes, NODE_ENDIFBLOCK, get_token_location_data(tokens, index)));
        NodeEndIfBlockData.<id(end_if, end_target);

        variable target_node_data = NodeTargetData.*cast(nodes_append_data(nodes, NODE_TARGET, get_token_location_data(tokens, index)));
        NodeTargetData.<id(target_node_data, target);
    };

    NodeEndIfBlockData.<is_last(end_if, true);

    variable target_node_data = NodeTargetData.*cast(nodes_append_data(nodes, NODE_TARGET, get_token_location_data(tokens, index)));
    NodeTargetData.<id(target_node_data, end_target);

    whole_8.<(index_pointer, index);
};

define target_id = global(whole_8);

define while_target_id_stack = global(AutoBufferStack8);

define get_target_id = function(): whole_8 {
    variable return_ = target_id;
    target_id = +(target_id, 1);

    return return_;
};

define parse_statement = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    while =(tokens_get_id(tokens, whole_8.>(index_pointer)), TOKEN_COMMA) {
        increment_whole_8_pointer(index_pointer, 1);
    };

    variable done_anything = false;

    if tokens_is_keyword(tokens, whole_8.>(index_pointer), "variable") {
        parse_declare_variable(tokens, index_pointer, nodes, is_target_internal_function);
        done_anything = true;
    };

    if &&(tokens_is_keyword(tokens, whole_8.>(index_pointer), "return"), !(done_anything)) {
        parse_return(tokens, index_pointer, nodes, is_target_internal_function);
        done_anything = true;
        return;
    };

    if &&(tokens_is_keyword(tokens, whole_8.>(index_pointer), "while"), !(done_anything)) {
        parse_while(tokens, index_pointer, nodes, is_target_internal_function);
        done_anything = true;
    };

    if !(done_anything) {
        if check_parse_assign(tokens, index_pointer, nodes, is_target_internal_function) {
            done_anything = true;
        };
    };

    if &&(tokens_is_keyword(tokens, whole_8.>(index_pointer), "break"), !(done_anything)) {
        parse_break(tokens, index_pointer, nodes, is_target_internal_function);
        done_anything = true;
    };

    if !(done_anything) {
        parse_expression(tokens, index_pointer, nodes, is_target_internal_function);
        if =(tokens_get_id(tokens, whole_8.>(index_pointer)), TOKEN_SEMICOLON) {
            variable _ = nodes_append(nodes, NODE_ENDSTATEMENT, get_token_location_data(tokens, whole_8.>(index_pointer)));
            increment_whole_8_pointer(index_pointer, 1);
        };
    } else {
        variable _ = nodes_append(nodes, NODE_ENDSTATEMENT, get_token_location_data(tokens, -(whole_8.>(index_pointer), 1)));
    };
};

define parse_break = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable jump_data = NodeJumpData.*cast(nodes_append_data(nodes, NODE_JUMP, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeJumpData.<target_id(jump_data, whole_8.cast(autobuffer_stack8_peek(&(while_target_id_stack))));

    increment_whole_8_pointer(index_pointer, 2);
};

define parse_return = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    increment_whole_8_pointer(index_pointer, 1);

    parse_multiple_expressions(tokens, index_pointer, nodes, is_target_internal_function, TOKEN_SEMICOLON);

    variable node = nodes_append(nodes, NODE_RETURN, get_token_location_data(tokens, whole_8.>(index_pointer)));
    increment_whole_8_pointer(index_pointer, 1);
};

define check_parse_assign = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]): boolean {
    variable is_assign = true;
    variable index = whole_8.>(index_pointer);
    while true {
        if =(tokens_get_id(tokens, index), TOKEN_COMMA) {
            index = +(index, 1);
        } else if =(tokens_get_id(tokens, index), TOKEN_NAME) {
            variable name = TokenNameData.>name(TokenNameData.*cast(tokens_get_pointer_data(tokens, index)));
            if string=(name, "=") {
                break;
            };
            index = +(index, 1);
        } else {
            is_assign = false;
            break;
        };
    };

    if is_assign {
        parse_assign(tokens, index_pointer, nodes, is_target_internal_function);
        return true;
    };

    return false;
};

define parse_assign = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable names = autobuffer_new(40);
    variable name_index = 0;

    variable index = whole_8.>(index_pointer);
    while true {
        if =(tokens_get_id(tokens, index), TOKEN_COMMA) {
            index = +(index, 1);
        } else {
            variable name = TokenNameData.>name(TokenNameData.*cast(tokens_get_pointer_data(tokens, index)));
            autobuffer_stack8_legacy_push(&(names), &(name_index), name);
            index = +(index, 1);
        };

        if =(tokens_get_id(tokens, index), TOKEN_NAME) {
            if string=(TokenNameData.>name(TokenNameData.*cast(tokens_get_pointer_data(tokens, index))), "=") {
                break;
            };
        };
    };

    index = +(index, 1);

    parse_multiple_expressions(tokens, &(index), nodes, is_target_internal_function, TOKEN_SEMICOLON);

    index = +(index, 1);

    variable temp = autobuffer_array8_length(&(names));
    variable i = -(autobuffer_array8_length(&(names)), 1);
    while <(i, temp) {
        variable assign_node_data = NodeAssignData.*cast(nodes_append_data(nodes, NODE_ASSIGN, get_token_location_data(tokens, whole_8.>(index_pointer))));
        NodeAssignData.<name(assign_node_data, *.cast(autobuffer_array8_get(&(names), i)));
        i = -(i, 1);
    };

    whole_8.<(index_pointer, index);
};

define parse_while = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    increment_whole_8_pointer(index_pointer, 1);

    variable target1 = get_target_id();

    variable target2 = get_target_id();

    variable target_node1_data = NodeTargetData.*cast(nodes_append_data(nodes, NODE_TARGET, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeTargetData.<id(target_node1_data, target1);

    parse_expression(tokens, index_pointer, nodes, is_target_internal_function);
    variable conditional_jump_data = NodeJumpConditionalData.*cast(nodes_append_data(nodes, NODE_JUMP_CONDITIONAL, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeJumpConditionalData.<target_id(conditional_jump_data, target2);
    NodeJumpConditionalData.<desired_state(conditional_jump_data, false);
    variable _ = nodes_append(nodes, NODE_ENDSTATEMENT, get_token_location_data(tokens, whole_8.>(index_pointer)));

    autobuffer_stack8_push(&(while_target_id_stack), target2);
    parse_expression(tokens, index_pointer, nodes, is_target_internal_function);
    variable _ = autobuffer_stack8_pop(&(while_target_id_stack));

    variable jump_node_data = NodeJumpData.*cast(nodes_append_data(nodes, NODE_JUMP, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeJumpData.<target_id(jump_node_data, target1);

    variable target_node2_data = NodeTargetData.*cast(nodes_append_data(nodes, NODE_TARGET, get_token_location_data(tokens, whole_8.>(index_pointer))));
    NodeTargetData.<id(target_node2_data, target2);

    increment_whole_8_pointer(index_pointer, 1);
};

define parse_declare_variable = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable index = whole_8.>(index_pointer);

    variable parse_expression, variable_names = parse_declare_variable_declaration(tokens, &(index), nodes);

    if parse_expression {
        index = +(index, 1);

        parse_multiple_expressions(tokens, &(index), nodes, is_target_internal_function, TOKEN_SEMICOLON);

        variable temp = array8_length(variable_names);
        variable i = -(array8_length(variable_names), 1);
        while <(i, temp) {
            variable node_data = NodeAssignData.*cast(nodes_append_data(nodes, NODE_ASSIGN, get_token_location_data(tokens, whole_8.>(index_pointer))));
            NodeAssignData.<name(node_data, *.cast(array8_get(variable_names, i)));

            i = -(i, 1);
        };
    };

    index = +(index, 1);
    whole_8.<(index_pointer, index);
};

define parse_declare_variable_declaration = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes): boolean, * {
    variable index = whole_8.>(index_pointer);
    index = +(index, 1);

    variable names = autobuffer_new(40);
    variable types = autobuffer_new(40);

    variable name_index = 0;
    variable seen_item_name = false;
    variable parse_expression = false;
    while true {
        variable id = tokens_get_id(tokens, index);
        if =(id, TOKEN_COMMA) {
            name_index = +(name_index, 1);
            seen_item_name = false;
        };

        if =(id, TOKEN_NAME) {
            variable name_value = TokenNameData.>name(TokenNameData.*cast(tokens_get_pointer_data(tokens, index)));
            if seen_item_name {
                autobuffer_array8_set(&(types), name_index, name_value);
            } else {
                autobuffer_array8_set(&(names), name_index, name_value);
                autobuffer_array8_set(&(types), name_index, "");
                seen_item_name = true;
            };
        };

        index = +(index, 1);

        if =(tokens_get_id(tokens, index), TOKEN_NAME) {
            variable name_value = TokenNameData.>name(TokenNameData.*cast(tokens_get_pointer_data(tokens, index)));
            if string=(name_value, "=") {
                parse_expression = true;
                break;
            };
        };
        if =(tokens_get_id(tokens, index), TOKEN_SEMICOLON) {
            parse_expression = false;
            break;
        };
    };

    variable i = 0;
    while !(=(autobuffer_array8_get(&(names), i), 0)) {
        variable node_data = NodeDeclareData.*cast(nodes_append_data(nodes, NODE_DECLARE, get_token_location_data(tokens, whole_8.>(index_pointer))));
        NodeDeclareData.<name(node_data, *.cast(autobuffer_array8_get(&(names), i)));
        NodeDeclareData.<type(node_data, *.cast(autobuffer_array8_get(&(types), i)));

        i = +(i, 1);
    };

    whole_8.<(index_pointer, index);
    return parse_expression, AutoBuffer.>buffer(&(names));
};

define parse_multiple_expressions = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean], breaker: whole_8) {
    while !(=(tokens_get_id(tokens, whole_8.>(index_pointer)), breaker)) {
        if =(tokens_get_id(tokens, whole_8.>(index_pointer)), TOKEN_COMMA) {
            increment_whole_8_pointer(index_pointer, 1);
        } else if |(=(tokens_get_id(tokens, whole_8.>(index_pointer)), TOKEN_SEMICOLON), =(tokens_get_id(tokens, whole_8.>(index_pointer)), TOKEN_CLOSED_PARENTHESIS)) {
            print_token_error_beginning(tokens, whole_8.>(index_pointer));
            println("Unexpected token");
        } else {
            parse_expression(tokens, index_pointer, nodes, is_target_internal_function);
        };
    };
};

define parse_module = function(tokens: *Tokens, index_pointer: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable _ = nodes_append(nodes, NODE_MODULE, get_token_location_data(tokens, whole_8.>(index_pointer)));

    increment_whole_8_pointer(index_pointer, 2);

    parse_multiple(tokens, index_pointer, nodes, is_target_internal_function, TOKEN_CLOSED_CURLY_BRACKETS);

    variable _ = nodes_append(nodes, NODE_ENDMODULE, get_token_location_data(tokens, whole_8.>(index_pointer)));

    increment_whole_8_pointer(index_pointer, 1);
};

define parse_individual = function(tokens: *Tokens, index: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable id = tokens_get_id(tokens, whole_8.>(index));
    if =(id, TOKEN_KEYWORD) {
        variable keyword_data = TokenKeywordData.*cast(tokens_get_pointer_data(tokens, whole_8.>(index)));
        variable keyword = TokenKeywordData.>keyword(keyword_data);

        if string=(keyword, "function") {
            parse_function(tokens, index, nodes, is_target_internal_function);
        };

        if string=(keyword, "structure") {
            parse_structure(tokens, index, nodes);
        };

        if string=(keyword, "global") {
            parse_global(tokens, index, nodes);
        };

        if string=(keyword, "module") {
            parse_module(tokens, index, nodes, is_target_internal_function);
        };

        if string=(keyword, "define") {
            parse_define(tokens, index, nodes, is_target_internal_function);
        };
    } else {
        parse_expression(tokens, index, nodes, is_target_internal_function);
    };
};

define parse_multiple = function(tokens: *Tokens, index: *whole_8, nodes: *Nodes, is_target_internal_function: *function[*:boolean], ending: whole_8) {
    variable tokens_count = Tokens.>index(tokens);
    while !(=(tokens_get_id(tokens, whole_8.>(index)), ending)) {
        parse_individual(tokens, index, nodes, is_target_internal_function);
    };
};

define parse = function(tokens: *Tokens, nodes: *Nodes, is_target_internal_function: *function[*:boolean]) {
    variable index = 0;
    parse_multiple(tokens, &(index), nodes, is_target_internal_function, 0);
};
