define is_type2 = function(wanted: *, given: *, nodes: *Nodes, defines_map: HashMap): boolean {
    if string=(wanted, given) {
        return true;
    };

    if string=(wanted, "*") {
        if string_length=(given, "*", 1) {
            return true;
        };
    };

    if string_length=(wanted, "*", 1) {
        if string_length=(given, "*", 1) {
            return is_type2(+(wanted, 1), +(given, 1), nodes, defines_map);
        };
    };

    variable defined = @cast_*(hashmap_string_get(&(defines_map), given));
    if !(=(defined, 0)) {
        return string=(defined, wanted);
    };

    defined = @cast_*(hashmap_string_get(&(defines_map), wanted));
    if !(=(defined, 0)) {
        return string=(defined, given);
    };

    if string_length=(wanted, "any_", 4) {
        variable size = to_number(@cast_*(+(wanted, 4)));
        return =(size, get_size_linux_x86-642(given, nodes));
    };

    return false;
};

define is_type = function(wanted: *, given: *, nodes: *Nodes): boolean {
    if string=(wanted, given) {
        return true;
    };

    if string=(wanted, "*") {
        if string_length=(given, "*", 1) {
            return true;
        };
    };

    if string_length=(wanted, "any_", 4) {
        variable size = to_number(@cast_*(+(wanted, 4)));
        return =(size, get_size_linux_x86-642(given, nodes));
    };

    return false;
};

define is_signed = function(type: *, nodes: *Nodes): whole_8 {
    variable cached_signedness = @cast_whole_8(hashmap_string_get2(&(cached_signedness_map), type));
    if !(=(cached_signedness, 999)) {
        return cached_signedness;
    };

    if string_length=(type, "*", 1) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };

    if string_length=(type, "whole", 5) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "any", 3) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "integer", 7) {
        hashmap_string_put(&(cached_signedness_map), type, 1);
        return 1;
    };

    variable node_count = Nodes.>index(nodes);
    variable i = 0;
    while <(i, node_count) {
        if =(nodes_get_id(nodes, i), NODE_STRUCTURE) {
            variable pointer = @cast_*NodeStructureData(nodes_get_pointer_data(nodes, i));
            variable name = NodeStructureData.>name(pointer);

            if !(=(name, 0)) {
                variable member_types = NodeStructureData.>item_types(pointer);
                if string=(type, name) {
                    variable is_signed2 = is_signed(@cast_*(array8_get(member_types, 0)), nodes);
                    hashmap_string_put(&(cached_signedness_map), type, is_signed2);
                    return is_signed2;
                };
            };
        };
        i = +(i, 1);
    };

    return 0;
};

define print_node_error_beginning = function(nodes: *Nodes, location: whole_8) {
    variable location_data = nodes_get_location_data(nodes, location);
    print("[ERROR] ");
    print(NodeLocationData.>file(location_data));
    print(":");
    print_whole_8(NodeLocationData.>row(location_data));
    print(":");
    print_whole_8(NodeLocationData.>column(location_data));
    print(": ");
};

define type_check = function(nodes: *Nodes) {
    variable node_count = Nodes.>index(nodes);

    variable function_arguments_array = autobuffer_new(1024);
    variable function_argument_names_array = autobuffer_new(1024);
    variable function_returns_array = autobuffer_new(1024);

    variable function_arguments_map = hashmap_new(1024);
    variable function_argument_names_map = hashmap_new(1024);
    variable function_returns_map = hashmap_new(1024);

    variable globals_map = hashmap_new(512);
    variable defines_map = hashmap_new(512);

    variable define_values_map = hashmap_new(512);

    variable structure_members_array = autobuffer_new(1024);
    variable structure_member_names_array = autobuffer_new(1024);

    variable has_main = false;

    variable function_id = 0;

    variable define_function_index = 0;
    variable define_structure_index = 0;
    
    variable i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            variable function_data = @cast_*NodeFunctionData(pointer_data);
            variable function_name = NodeFunctionData.>name(function_data);
            
            if !(=(function_name, 0)) {
                variable function_index_found = hashmap_string_get(&(function_arguments_map), function_name);
                if &&(!(=(function_index_found, 0)), !(string_length=(function_name, "structure[", 10))) {
                    print_node_error_beginning(nodes, i);
                    print("Function '");
                    print(function_name);
                    println("' already defined");
                    exit(1);
                };

                if string=(function_name, "main") {
                    has_main = true;
                };

                hashmap_string_put(&(function_arguments_map), function_name, NodeFunctionData.>argument_types(function_data));
                hashmap_string_put(&(function_argument_names_map), function_name, NodeFunctionData.>argument_names(function_data));
                hashmap_string_put(&(function_returns_map), function_name, NodeFunctionData.>returns(function_data));
            } else {
                autobuffer_array8_set(&(function_arguments_array), function_id, NodeFunctionData.>argument_types(function_data));
                autobuffer_array8_set(&(function_argument_names_array), function_id, NodeFunctionData.>argument_names(function_data));
                autobuffer_array8_set(&(function_returns_array), function_id, NodeFunctionData.>returns(function_data));
                function_id = +(function_id, 1);
            };
        };

        if =(id, NODE_STRUCTURE) {
            variable structure_data = @cast_*NodeStructureData(pointer_data);

            if =(NodeStructureData.>name(structure_data), 0) {
                autobuffer_array8_set(&(structure_members_array), define_structure_index, NodeStructureData.>item_types(structure_data));
                autobuffer_array8_set(&(structure_member_names_array), define_structure_index, NodeStructureData.>item_names(structure_data));
                define_structure_index = +(define_structure_index, 1);
            };
        };

        if =(id, NODE_GLOBAL) {
            variable global_data = @cast_*NodeGlobalData(pointer_data);
            variable global_name = NodeGlobalData.>name(global_data);
            variable global_type = NodeGlobalData.>type(global_data);

            hashmap_string_put(&(globals_map), global_name, global_type);
        };

        if =(id, NODE_DEFINE) {
            variable define_data = @cast_*NodeDefineData(pointer_data);
            variable define_name = NodeDefineData.>name(define_data);
            variable define_type = NodeDefineData.>type(define_data);

            hashmap_string_put(&(defines_map), define_name, define_type);
            //println(define_name);

            if &&(string=(define_name, "main"), string_length=(define_type, "*function[", 10)) {
                has_main = true;
            };

            variable define_value: any_8;
            if string_length=(define_type, "*function", 9) {
                define_value = define_function_index;
            } else if string_length=(define_type, "structure", 9) {
                define_value = define_structure_index;
            } else {
                define_value = NodeNumberData.>value(@cast_*NodeNumberData(nodes_get_pointer_data(nodes, +(i, 1))));
            };

            hashmap_string_put(&(define_values_map), define_name, define_value);
        };

        i = +(i, 1);
    };

    if !(has_main) {
        println("[ERROR] No 'main' function defined");
        exit(1);
    };

    variable current_function: *;
    variable current_function_id: whole_8;

    variable variable_scopes_types_map = autobuffer_new(64);
    variable variable_scope_types_pointer = 0;
    variable variable_scopes_declares_map = autobuffer_new(64);
    variable variable_scope_declares_pointer = 0;

    variable stack = autobuffer_new(64);
    variable stack_pointer = 0;

    variable scopes = autobuffer_new(64);
    variable scope_pointer = 0;

    variable if_blocks = autobuffer_new(64);
    variable if_block_pointer = 0;

    variable if_block_results = autobuffer_new(64);

    function_id = 0;

    i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);
        variable done_anything = false;

        //print_node_info(nodes, i);

        if =(id, NODE_FUNCTION) {
            current_function = NodeFunctionData.>name(@cast_*NodeFunctionData(pointer_data));

            if =(current_function, 0) {
                current_function_id = function_id;
                function_id = +(function_id, 1);
            };

            stack_pointer = 0;
            done_anything = true;
        } else if =(id, NODE_NUMBER) {
            variable number_data = @cast_*NodeNumberData(pointer_data);

            variable number_type = autobuffer_new(16);
            variable number_type_index = 0;

            if =(NodeNumberData.>type(number_data), 0) {
                autobuffer_push_string(&(number_type), &(number_type_index), "whole_");
            } else {
                autobuffer_push_string(&(number_type), &(number_type_index), "integer_");
            };

            autobuffer_string_push_whole_8(&(number_type), &(number_type_index), NodeNumberData.>size(number_data));

            autobuffer_stack8_push(&(stack), &(stack_pointer), AutoBuffer->buffer(&(number_type)));
            done_anything = true;
        } else if =(id, NODE_BOOLEAN) {
            autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");
            done_anything = true;
        } else if =(id, NODE_STRING) {
            autobuffer_stack8_push(&(stack), &(stack_pointer), "*");
            done_anything = true;
        } else if =(id, NODE_INVOKE) {
            variable invoke_data = @cast_*NodeInvokeData(pointer_data);
            variable has_specifier = NodeInvokeData.>has_specifier(invoke_data);
            variable function_name = NodeInvokeData.>name(invoke_data);

            if &&(!(has_specifier), string_length=(function_name, "@cast_", 6)) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    println("Cast ran out of stack values");
                    exit(1);
                };

                variable popped = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable to_push = @cast_*(+(function_name, 6));

                if !(=(get_size_linux_x86-643(popped, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(to_push, nodes, define_values_map, structure_members_array))) {
                    print_node_error_beginning(nodes, i);
                    print("Cast wants equal sized types, given '");
                    print(popped);
                    print("' and casts to '");
                    print(to_push);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), to_push);
            } else if &&(!(has_specifier), string=(function_name, "+")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '+' ran out of stack values");
                    exit(1);
                };

                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '+' wants matching arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "+_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "-")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '-' ran out of stack values");
                    exit(1);
                };

                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '-' wants matching arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "-_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "*")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '*' ran out of stack values");
                    exit(1);
                };

                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '*' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "*_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "/")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '/' ran out of stack values");
                    exit(1);
                };

                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '/' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "/_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "%")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '%' ran out of stack values");
                    exit(1);
                };

                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '%' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "%_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "=")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '=' ran out of stack values");
                    exit(1);
                };

                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '=' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "=_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, ">")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '>' ran out of stack values");
                    exit(1);
                };

                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '>' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), ">_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "<")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '<' ran out of stack values");
                    exit(1);
                };

                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '<' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "<_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else {
                variable found_function = false;

                if NodeInvokeData.>has_specifier(invoke_data) {
                    variable popped = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                    variable function_name_new = brk_allocate(+(+(length(popped), length(function_name)), 1));
                    copy(popped, function_name_new, length(popped));
                    copy(function_name, +(function_name_new, length(popped)), length(function_name));

                    function_name = function_name_new;
                    NodeInvokeData.<name(invoke_data, function_name);
                    NodeInvokeData.<has_specifier(invoke_data, false);

                    variable previous = @cast_*whole_8(nodes_get_pointer(nodes, -(i, 1)));
                    whole_8<-(previous, NODE_SKIP);
                };

                if =(hashmap_string_get(&(function_arguments_map), function_name), 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke target '");
                    print(function_name);
                    println("' not found");
                    exit(1);
                };

                variable arguments = @cast_*(hashmap_string_get(&(function_arguments_map), function_name));
                variable returns = @cast_*(hashmap_string_get(&(function_returns_map), function_name));

                variable length = array8_length(arguments);
                variable k = 0;
                while <(k, length) {
                    if =(stack_pointer, 0) {
                        print_node_error_beginning(nodes, i);
                        print("Invoke of '");
                        print(function_name);
                        println("' ran out of stack values");
                        exit(1);
                    };

                    variable given = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                    variable wanted = @cast_*(array8_get(arguments, -(-(length, k), 1)));
                    if !(is_type2(wanted, given, nodes, defines_map)) {
                        print_node_error_beginning(nodes, i);
                        print("Invoke of '");
                        print(function_name);
                        print("' wants '");
                        print(wanted);
                        print("', given '");
                        print(given);
                        println("'");
                        exit(1);
                    };

                    k = +(k, 1);
                };

                variable k = 0;
                while !(=(array8_get(returns, k), 0)) {
                    variable return_value = @cast_*(array8_get(returns, k));
                    autobuffer_stack8_push(&(stack), &(stack_pointer), return_value);

                    k = +(k, 1);
                };
            };

            done_anything = true;
        } else if =(id, NODE_DECLARE) {
            variable declare_data = @cast_*NodeDeclareData(pointer_data);
            variable variable_name = NodeDeclareData.>name(declare_data);
            variable variable_type = NodeDeclareData.>type(declare_data);

            hashmap_string_put(@cast_*HashMap(autobuffer_array8_get(&(variable_scopes_types_map), -(variable_scope_types_pointer, 1))), variable_name, variable_type);
            hashmap_string_put(@cast_*HashMap(autobuffer_array8_get(&(variable_scopes_declares_map), -(variable_scope_declares_pointer, 1))), variable_name, i);

            done_anything = true;
        } else if =(id, NODE_ASSIGN) {
            variable assign_data = @cast_*NodeAssignData(pointer_data);
            variable variable_name = NodeAssignData.>name(assign_data);

            variable scope_index = -(variable_scope_types_pointer, 1);
            variable variable_type = @cast_*(0);
            while &&(=(variable_type, 0), <(scope_index, variable_scope_types_pointer)) {
                variable_type = @cast_*(hashmap_string_get(@cast_*HashMap(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name));
                scope_index = -(scope_index, 1);
            };
            scope_index = +(scope_index, 1);

            if =(stack_pointer, 0) {
                print_node_error_beginning(nodes, i);
                println("Assign ran out of stack values");
                exit(1);
            };

            variable popped_stack = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

            if !(=(variable_type, 0)) {
                if string=(variable_type, "") {
                    variable_type = popped_stack;

                    hashmap_string_put(@cast_*HashMap(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name, popped_stack);

                    variable variable_declare3 = hashmap_string_get(@cast_*HashMap(autobuffer_array8_get(&(variable_scopes_declares_map), scope_index)), variable_name);
                    variable variable_declare4 = @cast_*NodeDeclareData(nodes_get_pointer_data(nodes, @cast_whole_8(variable_declare3)));
                    NodeDeclareData.<type(variable_declare4, variable_type);
                };

                if !(is_type(variable_type, popped_stack, nodes)) {
                    print_node_error_beginning(nodes, i);
                    print("Assign of ");
                    print(variable_name);
                    print(" wants '");
                    print(variable_type);
                    print("', given '");
                    print(popped_stack);
                    println("'");
                    exit(1);
                };
            } else {
                variable_type = @cast_*(hashmap_string_get(&(globals_map), variable_name));

                if !(is_type(variable_type, popped_stack, nodes)) {
                    print_node_error_beginning(nodes, i);
                    print("Assign of ");
                    print(variable_name);
                    print(" wants '");
                    print(variable_type);
                    print("', given '");
                    print(popped_stack);
                    println("'");
                    exit(1);
                };
            };

            done_anything = true;
        } else if =(id, NODE_RETRIEVE) {
            variable variable_name = NodeRetrieveData.>name(@cast_*NodeRetrieveData(nodes_get_pointer_data(nodes, i)));

            variable scope_index = -(variable_scope_types_pointer, 1);
            variable variable_type = @cast_*(0);
            while &&(=(variable_type, 0), <(scope_index, variable_scope_types_pointer)) {
                variable_type = @cast_*(hashmap_string_get(@cast_*HashMap(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name));
                scope_index = -(scope_index, 1);
            };
            scope_index = +(scope_index, 1);

            if !(=(variable_type, 0)) {
                autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
            } else {
                variable function_argument_names2 = @cast_*(if =(current_function, 0) { autobuffer_array8_get(&(function_argument_names_array), current_function_id) } else { hashmap_string_get(&(function_argument_names_map), current_function) });
                variable function_arguments2 = @cast_*(if =(current_function, 0) { autobuffer_array8_get(&(function_arguments_array), current_function_id) } else { hashmap_string_get(&(function_arguments_map), current_function) });

                variable_type = stringarray_get(function_argument_names2, function_arguments2, variable_name, array8_length(function_arguments2));
                if !(=(variable_type, 0)) {
                    autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
                } else {
                    variable_type = @cast_*(hashmap_string_get(&(globals_map), variable_name));

                    if !(=(variable_type, 0)) {
                        autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
                    } else {
                        variable_type = @cast_*(hashmap_string_get(&(defines_map), variable_name));

                        if !(=(variable_type, 0)) {
                            autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
                        } else {
                            if !(=(hashmap_string_get(&(function_arguments_map), variable_name), 0)) {
                                variable function_type_buffer = autobuffer_new(64);
                                variable function_type_buffer_index = 0;

                                autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), "*function[");
                                variable function_arguments2 = @cast_*(hashmap_string_get(&(function_arguments_map), variable_name));
                                variable j = 0;
                                while !(=(array8_get(function_arguments2, j), 0)) {
                                    variable function_argument = @cast_*(array8_get(function_arguments2, j));
                                    autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), function_argument);
                                    autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), ",");
                                    j = +(j, 1);
                                };
                                if >(j, 0) {
                                    function_type_buffer_index = -(function_type_buffer_index, 1);
                                };

                                autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), ":");

                                variable function_returns2 = @cast_*(hashmap_string_get(&(function_returns_map), variable_name));
                                variable j = 0;
                                while !(=(array8_get(function_returns2, j), 0)) {
                                    variable function_return = @cast_*(array8_get(function_returns2, j));
                                    autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), function_return);
                                    autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), ",");
                                    j = +(j, 1);
                                };
                                if >(j, 0) {
                                    function_type_buffer_index = -(function_type_buffer_index, 1);
                                };

                                autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), "]");
                                autobuffer_stack8_push(&(stack), &(stack_pointer), AutoBuffer->buffer(&(function_type_buffer)));
                            } else {
                                if string=(variable_name, "&") {
                                    autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_&");
                                } else if string=(variable_name, "+") {
                                    autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_+");
                                } else if string=(variable_name, "-") {
                                    autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_-");
                                } else if string=(variable_name, "*") {
                                    autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_*");
                                } else if string=(variable_name, "/") {
                                    autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_/");
                                } else if string=(variable_name, "%") {
                                    autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_%");
                                } else if string=(variable_name, "=") {
                                    autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_=");
                                } else if string=(variable_name, ">") {
                                    autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_>");
                                } else if string=(variable_name, "<") {
                                    autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_<");
                                } else {
                                    print_node_error_beginning(nodes, i);
                                    print("Retrieve target '");
                                    print(variable_name);
                                    println("' not found");
                                    exit(1);
                                };
                            };
                        };
                    };
                };
            };

            done_anything = true;
        } else if =(id, NODE_RETURN) {
            variable function_returns2 = @cast_*(if =(current_function, 0) { autobuffer_array8_get(&(function_returns_array), current_function_id) } else { hashmap_string_get(&(function_returns_map), current_function) });

            variable temp = array8_length(function_returns2);
            variable j = -(temp, 1);
            while <(j, temp) {
                variable function_return = @cast_*(array8_get(function_returns2, j));

                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    println("Return ran out of stack values");
                    exit(1);
                };

                variable stack_popped = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                
                if !(is_type(function_return, stack_popped, nodes)) {
                    print_node_error_beginning(nodes, i);
                    print("Return wants '");
                    print(function_return);
                    print("', given '");
                    print(stack_popped);
                    println("'");
                    exit(1);
                };

                j = -(j, 1);
            };

            if !(=(stack_pointer, 0)) {
                print_node_error_beginning(nodes, i);
                println("Return has extra stack values");
                exit(1);
            };

            done_anything = true;
        } else if =(id, NODE_POINTER) {
            if =(stack_pointer, 0) {
                print_node_error_beginning(nodes, i);
                println("Pointer ran out of stack values");
                exit(1);
            };

            variable popped = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
            variable allocated = brk_allocate(+(length(popped), 2));
            copy("*", allocated, 1);
            copy(popped, @cast_*(+(allocated, 1)), length(popped));
            autobuffer_stack8_push(&(stack), &(stack_pointer), allocated);
            done_anything = true;
        } else if =(id, NODE_JUMP_CONDITIONAL) {
            if =(stack_pointer, 0) {
                print_node_error_beginning(nodes, i);
                println("Conditional jump ran out of stack values");
                exit(1);
            };

            variable popped = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
            if !(string=(popped, "boolean")) {
                print_node_error_beginning(nodes, i);
                print("Conditional Jump (if/while) wants 'boolean', given '");
                print(popped);
                println("'");
                exit(1);
            };
            done_anything = true;
        } else if =(id, NODE_SCOPE) {
            variable new_hashmap = hashmap_new(512);
            variable allocated = brk_allocate(24);
            HashMap.<(@cast_*HashMap(allocated), new_hashmap);
            autobuffer_stack8_push(&(variable_scopes_types_map), &(variable_scope_types_pointer), allocated);

            variable new_hashmap = hashmap_new(512);
            variable allocated = brk_allocate(24);
            HashMap.<(@cast_*HashMap(allocated), new_hashmap);
            autobuffer_stack8_push(&(variable_scopes_declares_map), &(variable_scope_declares_pointer), allocated);
        } else if =(id, NODE_ENDSCOPE) {
            variable _ = autobuffer_stack8_pop(&(variable_scopes_types_map), &(variable_scope_types_pointer));
            variable _ = autobuffer_stack8_pop(&(variable_scopes_declares_map), &(variable_scope_declares_pointer));
        } else if =(id, NODE_STARTIFBLOCK) {
            autobuffer_stack8_push(&(if_blocks), &(if_block_pointer), stack_pointer);
        } else if =(id, NODE_ENDIFBLOCK) {
            variable end_if_id = NodeEndIfBlockData.>id(@cast_*NodeEndIfBlockData(pointer_data));
            variable start_stack = @cast_whole_8(autobuffer_stack8_pop(&(if_blocks), &(if_block_pointer)));
            variable previous_results = @cast_*(autobuffer_array8_get(&(if_block_results), end_if_id));
            
            variable size = *(8, -(stack_pointer, start_stack));
            if =(previous_results, 0) {
                previous_results = brk_allocate(+(8, size));
                variable array = autobuffer_get_size(&(stack), *(8, start_stack), size);
                copy(array, previous_results, size);

                autobuffer_array8_set(&(if_block_results), end_if_id, previous_results);
            } else {
                variable array = autobuffer_get_size(&(stack), *(8, start_stack), size);
                variable previous_array = previous_results;

                variable max_size = size;
                if >(*(array8_length(previous_array), 8), size) {
                    size = *(array8_length(previous_array), 8);
                };

                variable j = 0;
                while <(j, /(size, 8)) {
                    variable previous_value = @cast_*(array8_get(previous_array, j));
                    variable value = @cast_*(array8_get(array, j));

                    variable error = false;

                    if =(value, 0) {
                        error = true;
                    } else if =(previous_value, 0) {
                        error = true;
                    } else if !(string=(value, previous_value)) {
                        error = true;
                    } else {
                        variable _ = autobuffer_stack8_pop(&(stack), &(stack_pointer));
                    };

                    if error {
                        print_node_error_beginning(nodes, i);
                        println("If does not have matching branch results");
                        exit(1);
                    };

                    j = +(j, 1);
                };
            };

            done_anything = true;
        } else if =(id, NODE_INVOKE_POINTER) {
            variable function_type = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

            if string_length=(function_type, "*function_", 10) {
                variable function_name = +(function_type, 10);
                if string=(function_name, "&") {
                    variable popped = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                    variable allocated = brk_allocate(+(length(popped), 2));
                    copy("*", allocated, 1);
                    copy(popped, @cast_*(+(allocated, 1)), length(popped));
                    autobuffer_stack8_push(&(stack), &(stack_pointer), allocated);

                    NodeInvokePointerData.<ignore(@cast_*NodeInvokePointerData(pointer_data), true);
                };// else if string=(function_name, "+") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '+' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '+' wants matching arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "+_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
                //} else if string=(function_name, "-") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '-' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '-' wants matching arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "-_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
                //} else if string=(function_name, "*") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '*' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '*' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "*_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
                //} else if string=(function_name, "/") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '/' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '/' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "/_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
                //} else if string=(function_name, "%") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '%' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '%' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "%_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
                //} else if string=(function_name, "=") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '=' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '=' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "=_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
                //} else if string=(function_name, ">") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '>' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '>' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), ">_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
                //} else if string=(function_name, "<") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '<' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '<' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "<_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
                //};
            } else {
                if string_length=(function_type, "*function[", 10) {
                    variable current_argument_buffer = autobuffer_new(64);
                    variable current_argument_buffer_index = 0;

                    variable arguments_buffer = autobuffer_new(64);
                    variable arguments_buffer_index = 0;

                    variable inner = 0;
                    variable j = 10;
                    while |(!(=(whole_1->(@cast_*whole_1(+(function_type, j))), 58_whole_1)), >(inner, 0)) {
                        variable character = whole_1->(@cast_*whole_1(+(function_type, j)));
                        if &&(|(=(character, 93_whole_1), =(character, 44_whole_1)), =(inner, 0)) {
                            autobuffer_array8_set(&(arguments_buffer), arguments_buffer_index, AutoBuffer->buffer(&(current_argument_buffer)));
                            arguments_buffer_index = +(arguments_buffer_index, 1);

                            current_argument_buffer = autobuffer_new(64);
                            current_argument_buffer_index = 0;
                        } else {
                            autobuffer_push_whole_1(&(current_argument_buffer), &(current_argument_buffer_index), character);
                        };

                        if =(character, 91_whole_1) {
                            inner = +(inner, 1);
                        } else if =(character, 93_whole_1) {
                            inner = -(inner, 1);
                        };
                        j = +(j, 1);
                    };
                    if >(length(AutoBuffer->buffer(&(current_argument_buffer))), 0) {
                        autobuffer_array8_set(&(arguments_buffer), arguments_buffer_index, AutoBuffer->buffer(&(current_argument_buffer)));
                        arguments_buffer_index = +(arguments_buffer_index, 1);
                    };

                    variable k = @cast_integer_8(arguments_buffer_index);
                    while >(k, 0_integer_8) {
                        k = -(k, 1_integer_8);

                        if =(stack_pointer, 0) {
                            print_node_error_beginning(nodes, i);
                            print("Invoke of '");
                            if =(nodes_get_id(nodes, -(i, 1)), NODE_RETRIEVE) {
                                variable previous_node_data = @cast_*NodeRetrieveData(nodes_get_pointer_data(nodes, -(i, 1)));
                                print(NodeRetrieveData.>name(previous_node_data));
                            } else {
                                print("unknown");
                            };
                            println("' ran out of stack values");
                            exit(1);
                        };

                        variable given = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                        variable wanted = @cast_*(autobuffer_array8_get(&(arguments_buffer), @cast_whole_8(k)));

                        if !(is_type2(wanted, given, nodes, defines_map)) {
                            print_node_error_beginning(nodes, i);
                            print("Invoke of '");

                            if =(nodes_get_id(nodes, -(i, 1)), NODE_RETRIEVE) {
                                variable previous_node_data = @cast_*NodeRetrieveData(nodes_get_pointer_data(nodes, -(i, 1)));
                                print(NodeRetrieveData.>name(previous_node_data));
                            } else {
                                print("unknown");
                            };

                            print("' wants '");
                            print(wanted);
                            print("', given '");
                            print(given);
                            println("'");
                            exit(1);
                        };
                    };

                    inner = 0;
                    current_argument_buffer = autobuffer_new(64);
                    current_argument_buffer_index = 0;

                    j = +(j, 1);

                    while |(!(=(whole_1->(@cast_*whole_1(+(function_type, j))), 93_whole_1)), >(inner, 0)) {
                        variable character = whole_1->(@cast_*whole_1(+(function_type, j)));
                        if &&(|(=(character, 58_whole_1), =(character, 44_whole_1)), =(inner, 0)) {
                            variable return_ = AutoBuffer->buffer(&(current_argument_buffer));
                            autobuffer_stack8_push(&(stack), &(stack_pointer), return_);

                            current_argument_buffer = autobuffer_new(64);
                            current_argument_buffer_index = 0;
                        } else {
                            autobuffer_push_whole_1(&(current_argument_buffer), &(current_argument_buffer_index), character);
                        };

                        if =(character, 91_whole_1) {
                            inner = +(inner, 1);
                        } else if =(character, 93_whole_1) {
                            inner = -(inner, 1);
                        };
                        j = +(j, 1);
                    };

                    if >(length(AutoBuffer->buffer(&(current_argument_buffer))), 0) {
                        autobuffer_stack8_push(&(stack), &(stack_pointer), AutoBuffer->buffer(&(current_argument_buffer)));
                    };
                } else {
                    print_node_error_beginning(nodes, i);
                    print("Attempting to invoke non function pointer '");
                    print(function_type);
                    println("'");
                    exit(1);
                };
            };

            done_anything = true;
        } else if =(id, NODE_JUMP) {
            done_anything = true;
        } else if =(id, NODE_TARGET) {
            done_anything = true;
        } else if =(id, NODE_ENDFUNCTION) {
            current_function = @cast_*(0);
            done_anything = true;
        } else if =(id, NODE_STRUCTURE) {
            done_anything = true;
        } else if =(id, NODE_GLOBAL) {
            done_anything = true;
        } else if =(id, NODE_DEFINE) {
            done_anything = true;
        } else if =(id, NODE_ENDDEFINE) {
            done_anything = true;
        } else if =(id, NODE_ENDSTATEMENT) {
            if !(=(stack_pointer, 0)) {
                print_node_error_beginning(nodes, i);
                println("Statement end has extra stack values");
                while !(=(stack_pointer, 0)) {
                    println(@cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer))));
                };
                exit(1);

            };
            done_anything = true;
        } else if !(done_anything) {
            print("Unhandled ");
            print_whole_8(id);
            println("");
        };

        i = +(i, 1);
    };
};
