function is_type(wanted: *, given: *, nodes: *Nodes): boolean {
    if string=(wanted, given) {
        return true;
    };

    if string=(wanted, "*") {
        if string_length=(given, "*", 1) {
            return true;
        };
    };

    if string_length=(wanted, "any_", 4) {
        variable size = to_number(@cast_*(+(wanted, 4)));
        return =(size, get_size_linux_x86-642(given, nodes));
    };

    return false;
};

function is_signed(type: *, nodes: *Nodes): whole_8 {
    variable cached_signedness = @cast_whole_8(hashmap_string_get(&(cached_signedness_map), type));
    if !(=(cached_signedness, 999)) {
        return cached_signedness;
    };

    if string_length=(type, "*", 1) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };

    if string_length=(type, "whole", 5) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "any", 3) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "integer", 7) {
        hashmap_string_put(&(cached_signedness_map), type, 1);
        return 1;
    };

    variable node_count = Nodes->index(nodes);
    variable i = 0;
    while <(i, node_count) {
        if =(nodes_get_id(nodes, i), NODE_STRUCTURE) {
            variable pointer = @cast_*NodeStructureData(nodes_get_pointer_data(nodes, i));
            variable name = NodeStructureData->name(pointer);
            variable member_types = NodeStructureData->item_types(pointer);
            if string=(type, name) {
                variable is_signed = is_signed(@cast_*(array8_get(member_types, 0)), nodes);
                hashmap_string_put(&(cached_signedness_map), type, is_signed);
                return is_signed;
            };
        };
        i = +(i, 1);
    };

    return 0;
};

function print_node_error_beginning(nodes: *Nodes, location: whole_8) {
    variable location_data = nodes_get_location_data(nodes, location);
    print("[ERROR] ");
    print(NodeLocationData->file(location_data));
    print(":");
    print_whole_8(NodeLocationData->row(location_data));
    print(":");
    print_whole_8(NodeLocationData->column(location_data));
    print(": ");
};

function type_check(nodes: *Nodes) {
    variable node_count = Nodes->index(nodes);

    variable function_arguments_map = hashmap_new(1024);
    variable function_argument_names_map = hashmap_new(1024);
    variable function_returns_map = hashmap_new(1024);

    variable globals_map = hashmap_new(512);
    variable constants_map = hashmap_new(512);

    variable has_main = false;
    
    variable i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            variable function_data = @cast_*NodeFunctionData(pointer_data);
            variable function_name = NodeFunctionData->name(function_data);

            variable function_index_found = hashmap_string_get(&(function_arguments_map), function_name);
            if !(=(function_index_found, 0)) {
                print_node_error_beginning(nodes, i);
                print("Function '");
                print(function_name);
                println("' already defined");
                exit(1);
            };

            if string=(function_name, "main") {
                has_main = true;
            };

            hashmap_string_put(&(function_arguments_map), function_name, NodeFunctionData->argument_types(function_data));
            hashmap_string_put(&(function_argument_names_map), function_name, NodeFunctionData->argument_names(function_data));
            hashmap_string_put(&(function_returns_map), function_name, NodeFunctionData->returns(function_data));
        };

        if =(id, NODE_GLOBAL) {
            variable global_data = @cast_*NodeGlobalData(pointer_data);
            variable global_name = NodeGlobalData->name(global_data);
            variable global_type = NodeGlobalData->type(global_data);

            hashmap_string_put(&(globals_map), global_name, global_type);
        };

        if =(id, NODE_CONSTANT) {
            variable constant_data = @cast_*NodeConstantData(pointer_data);
            variable constant_name = NodeConstantData->name(constant_data);
            variable constant_type = NodeConstantData->type(constant_data);

            hashmap_string_put(&(constants_map), constant_name, constant_type);
        };

        i = +(i, 1);
    };

    if !(has_main) {
        println("[ERROR] No 'main' function defined");
        exit(1);
    };

    variable current_function: *;

    variable variable_scopes_types_map = autobuffer_new(64);
    variable variable_scope_types_pointer = 0;
    variable variable_scopes_declares_map = autobuffer_new(64);
    variable variable_scope_declares_pointer = 0;

    variable stack = autobuffer_new(64);
    variable stack_pointer: whole_8;

    variable scopes = autobuffer_new(64);
    variable scope_pointer = 0;

    i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);
        variable done_anything = false;

        if =(id, NODE_FUNCTION) {
            current_function = NodeFunctionData->name(@cast_*NodeFunctionData(pointer_data));
            done_anything = true;
        } else if =(id, NODE_NUMBER) {
            variable number_data = @cast_*NodeNumberData(pointer_data);

            variable number_type = autobuffer_new(16);
            variable number_type_index = 0;

            if =(NodeNumberData->type(number_data), 0) {
                autopush_string(&(number_type), &(number_type_index), "whole_");
            } else {
                autopush_string(&(number_type), &(number_type_index), "integer_");
            };

            autobuffer_string_push_whole_8(&(number_type), &(number_type_index), NodeNumberData->size(number_data));

            autobuffer_stack8_push(&(stack), &(stack_pointer), AutoBuffer->buffer(&(number_type)));
            done_anything = true;
        } else if =(id, NODE_BOOLEAN) {
            autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");
            done_anything = true;
        } else if =(id, NODE_STRING) {
            autobuffer_stack8_push(&(stack), &(stack_pointer), "*");
            done_anything = true;
        } else if =(id, NODE_INVOKE) {
            variable invoke_data = @cast_*NodeInvokeData(pointer_data);
            variable function_name = NodeInvokeData->name(invoke_data);

            if string_length=(function_name, "@cast_", 6) {
                variable popped = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable to_push = @cast_*(+(function_name, 6));

                if !(=(get_size_linux_x86-642(popped, nodes), get_size_linux_x86-642(to_push, nodes))) {
                    print_node_error_beginning(nodes, i);
                    print("Cast wants equal sized types, given '");
                    print(popped);
                    print("' and casts to '");
                    print(to_push);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), to_push);
            } else if string=(function_name, "+") {
                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '+' wants matching arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "+_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData<-name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if string=(function_name, "-") {
                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '-' wants matching arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "-_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData<-name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if string=(function_name, "*") {
                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '*' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "*_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData<-name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if string=(function_name, "/") {
                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '/' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "/_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData<-name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if string=(function_name, "%") {
                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '%' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "%_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData<-name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if string=(function_name, "=") {
                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '=' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "=_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData<-name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if string=(function_name, ">") {
                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '>' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), ">_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData<-name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else if string=(function_name, "<") {
                variable first = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '<' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "<_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData<-name(invoke_data, AutoBuffer->buffer(&(new_+_name)));
            } else {
                variable found_function = false;

                if =(hashmap_string_get(&(function_arguments_map), function_name), 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke target '");
                    print(function_name);
                    println("' not found");
                    exit(1);
                };

                variable arguments = @cast_*(hashmap_string_get(&(function_arguments_map), function_name));
                variable returns = @cast_*(hashmap_string_get(&(function_returns_map), function_name));

                variable length = array8_length(arguments);
                variable k = 0;
                while <(k, length) {
                    variable given = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                    variable wanted = @cast_*(array8_get(arguments, -(-(length, k), 1)));
                    if !(is_type(wanted, given, nodes)) {
                        print_node_error_beginning(nodes, i);
                        print("Invoke of ");
                        print(function_name);
                        print(" wants '");
                        print(wanted);
                        print("', given '");
                        print(given);
                        println("'");
                        exit(1);
                    };

                    k = +(k, 1);
                };

                variable k = 0;
                while !(=(array8_get(returns, k), 0)) {
                    variable return_value = @cast_*(array8_get(returns, k));
                    autobuffer_stack8_push(&(stack), &(stack_pointer), return_value);

                    k = +(k, 1);
                };
            };

            done_anything = true;
        } else if =(id, NODE_DECLARE) {
            variable declare_data = @cast_*NodeDeclareData(pointer_data);
            variable variable_name = NodeDeclareData->name(declare_data);
            variable variable_type = NodeDeclareData->type(declare_data);

            //println(current_function);
            //println(variable_name);
            //print_whole_8(variable_scope_types_pointer);
            //println("");

            hashmap_string_put(@cast_*HashMap(autoarray8_get(&(variable_scopes_types_map), -(variable_scope_types_pointer, 1))), variable_name, variable_type);
            hashmap_string_put(@cast_*HashMap(autoarray8_get(&(variable_scopes_declares_map), -(variable_scope_declares_pointer, 1))), variable_name, i);

            done_anything = true;
        } else if =(id, NODE_ASSIGN) {
            variable assign_data = @cast_*NodeAssignData(pointer_data);
            variable variable_name = NodeAssignData->name(assign_data);

            variable scope_index = -(variable_scope_types_pointer, 1);
            variable variable_type = @cast_*(0);
            while &&(=(variable_type, 0), <(scope_index, variable_scope_types_pointer)) {
                variable_type = @cast_*(hashmap_string_get(@cast_*HashMap(autoarray8_get(&(variable_scopes_types_map), scope_index)), variable_name));
                scope_index = -(scope_index, 1);
            };
            scope_index = +(scope_index, 1);

            variable popped_stack = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

            if !(=(variable_type, 0)) {
                if string=(variable_type, "") {
                    variable_type = popped_stack;

                    hashmap_string_put(@cast_*HashMap(autoarray8_get(&(variable_scopes_types_map), scope_index)), variable_name, popped_stack);

                    variable variable_declare3 = hashmap_string_get(@cast_*HashMap(autoarray8_get(&(variable_scopes_declares_map), scope_index)), variable_name);
                    variable variable_declare4 = @cast_*NodeDeclareData(nodes_get_pointer_data(nodes, @cast_whole_8(variable_declare3)));
                    NodeDeclareData<-type(variable_declare4, variable_type);
                };

                if !(is_type(variable_type, popped_stack, nodes)) {
                    print_node_error_beginning(nodes, i);
                    print("Assign of ");
                    print(variable_name);
                    print(" wants '");
                    print(variable_type);
                    print("', given '");
                    print(popped_stack);
                    println("'");
                    exit(1);
                };
            } else {
                variable_type = @cast_*(hashmap_string_get(&(globals_map), variable_name));

                if !(is_type(variable_type, popped_stack, nodes)) {
                    print_node_error_beginning(nodes, i);
                    print("Assign of ");
                    print(variable_name);
                    print(" wants '");
                    print(variable_type);
                    print("', given '");
                    print(popped_stack);
                    println("'");
                    exit(1);
                };
            };

            done_anything = true;
        } else if =(id, NODE_RETRIEVE) {
            variable variable_name = NodeRetrieveData->name(@cast_*NodeRetrieveData(nodes_get_pointer_data(nodes, i)));

            variable scope_index = -(variable_scope_types_pointer, 1);
            variable variable_type = @cast_*(0);
            while &&(=(variable_type, 0), <(scope_index, variable_scope_types_pointer)) {
                variable_type = @cast_*(hashmap_string_get(@cast_*HashMap(autoarray8_get(&(variable_scopes_types_map), scope_index)), variable_name));
                scope_index = -(scope_index, 1);
            };
            scope_index = +(scope_index, 1);

            if !(=(variable_type, 0)) {
                autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
            } else {
                variable function_argument_names2 = @cast_*(hashmap_string_get(&(function_argument_names_map), current_function));
                variable function_arguments2 = @cast_*(hashmap_string_get(&(function_arguments_map), current_function));

                variable_type = stringarray_get(function_argument_names2, function_arguments2, variable_name, array8_length(function_arguments2));
                if !(=(variable_type, 0)) {
                    autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
                } else {
                    variable_type = @cast_*(hashmap_string_get(&(globals_map), variable_name));

                    if !(=(variable_type, 0)) {
                        autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
                    } else {
                        variable_type = @cast_*(hashmap_string_get(&(constants_map), variable_name));

                        if !(=(variable_type, 0)) {
                            autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
                        } else {
                            print_node_error_beginning(nodes, i);
                            print("Retrieve target '");
                            print(variable_name);
                            println("' not found");
                            exit(1);
                        };
                    };
                };
            };

            done_anything = true;
        } else if =(id, NODE_RETURN) {
            variable function_returns2 = @cast_*(hashmap_string_get(&(function_returns_map), current_function));

            variable temp = array8_length(function_returns2);
            variable j = -(temp, 1);
            while <(j, temp) {
                variable function_return = @cast_*(array8_get(function_returns2, j));
                variable stack_popped = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                
                if !(is_type(function_return, stack_popped, nodes)) {
                    print_node_error_beginning(nodes, i);
                    print("Return wants '");
                    print(function_return);
                    print("', given '");
                    print(stack_popped);
                    println("'");
                    exit(1);
                };

                j = -(j, 1);
            };

            done_anything = true;
        } else if =(id, NODE_POINTER) {
            variable popped = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
            variable allocated = brk_allocate(+(length(popped), 2));
            copy("*", allocated, 1);
            copy(popped, @cast_*(+(allocated, 1)), length(popped));
            autobuffer_stack8_push(&(stack), &(stack_pointer), allocated);
            done_anything = true;
        } else if =(id, NODE_JUMP_CONDITIONAL) {
            variable popped = @cast_*(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
            if !(string=(popped, "boolean")) {
                print_node_error_beginning(nodes, i);
                print("Conditional Jump (if/while) wants 'boolean', given '");
                print(popped);
                println("'");
                exit(1);
            };
            done_anything = true;
        } else if =(id, NODE_SCOPE) {
            variable hashmap_new = hashmap_new(512);
            variable allocated = brk_allocate(24);
            HashMap<-(@cast_*HashMap(allocated), hashmap_new);
            autobuffer_stack8_push(&(variable_scopes_types_map), &(variable_scope_types_pointer), allocated);

            variable hashmap_new = hashmap_new(512);
            variable allocated = brk_allocate(24);
            HashMap<-(@cast_*HashMap(allocated), hashmap_new);
            autobuffer_stack8_push(&(variable_scopes_declares_map), &(variable_scope_declares_pointer), allocated);
        } else if =(id, NODE_ENDSCOPE) {
            variable _ = autobuffer_stack8_pop(&(variable_scopes_types_map), &(variable_scope_types_pointer));
            variable _ = autobuffer_stack8_pop(&(variable_scopes_declares_map), &(variable_scope_declares_pointer));
        } else if =(id, NODE_JUMP) {
            done_anything = true;
        } else if =(id, NODE_TARGET) {
            done_anything = true;
        } else if =(id, NODE_ENDFUNCTION) {
            done_anything = true;
        } else if =(id, NODE_STRUCTURE) {
            done_anything = true;
        } else if =(id, NODE_GLOBAL) {
            done_anything = true;
        } else if =(id, NODE_CONSTANT) {
            done_anything = true;
        } else if =(id, NODE_INCLUDE) {
            done_anything = true;
        } else if =(id, NODE_ZERO) {
            variable zero_data = @cast_*NodeZeroData(pointer_data);
            variable type2 = NodeZeroData->type(zero_data);
            autobuffer_stack8_push(&(stack), &(stack_pointer), type2);
            done_anything = true;
        } else if !(done_anything) {
            print("Unhandled ");
            print_whole_8(id);
        };

        i = +(i, 1);
    };
};

