define is_type = function(wanted: *, given: *, nodes: *Nodes, defines_map: HashMap, structure_members_array: AutoBuffer): boolean {
    if string=(wanted, given) {
        return true;
    };

    if string=(wanted, "*") {
        if string_length=(given, "*", 1) {
            return true;
        };
    };

    if string_length=(wanted, "*", 1) {
        if string_length=(given, "*", 1) {
            return is_type(+(wanted, 1), +(given, 1), nodes, defines_map, structure_members_array);
        };
    };

    variable defined = *.cast(hashmap_string_get(&(defines_map), given));
    if !(=(defined, 0)) {
        if string=(defined, wanted) {
            return true;
        };
    };

    defined = *.cast(hashmap_string_get(&(defines_map), wanted));
    if !(=(defined, 0)) {
        if string=(defined, given) {
            return true;
        };
    };

    if string_length=(wanted, "global[", 7) {
        return string_length=(+(wanted, 7), given, -(length(wanted), 8));
    };

    if string_length=(given, "global[", 7) {
        return string_length=(+(given, 7), wanted, -(length(given), 8));
    };

    if |(&&(string=(wanted, "*structure[_:any_8]"), string=(given, "structure[_:any_8]")), &&(string=(given, "structure[_:any_8]"), string=(wanted, "*structure[_:any_8]"))) {
        return true;
    };

    if string_length=(wanted, "any_", 4) {
        variable size = to_number(*.cast(+(wanted, 4)));
        return =(size, get_size_linux_x86-643(given, nodes, defines_map, structure_members_array));
    };

    return false;
};

define is_signed = function(type: *, nodes: *Nodes): whole_8 {
    variable cached_signedness = whole_8.cast(hashmap_string_get2(&(cached_signedness_map), type));
    if !(=(cached_signedness, 999)) {
        return cached_signedness;
    };

    if string_length=(type, "*", 1) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };

    if string_length=(type, "whole", 5) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "any", 3) {
        hashmap_string_put(&(cached_signedness_map), type, 0);
        return 0;
    };
    if string_length=(type, "integer", 7) {
        hashmap_string_put(&(cached_signedness_map), type, 1);
        return 1;
    };

    variable node_count = Nodes.>index(nodes);
    variable i = 0;
    while <(i, node_count) {
        if =(nodes_get_id(nodes, i), NODE_STRUCTURE) {
            variable pointer = NodeStructureData.*cast(nodes_get_pointer_data(nodes, i));
            variable name = NodeStructureData.>name(pointer);

            if !(=(name, 0)) {
                variable member_types = NodeStructureData.>item_types(pointer);
                if string=(type, name) {
                    variable is_signed2 = is_signed(*.cast(array8_get(member_types, 0)), nodes);
                    hashmap_string_put(&(cached_signedness_map), type, is_signed2);
                    return is_signed2;
                };
            };
        };
        i = +(i, 1);
    };

    hashmap_string_put(&(cached_signedness_map), type, 0);
    return 0;
};

define print_node_error_beginning = function(nodes: *Nodes, location: whole_8) {
    variable location_data = nodes_get_location_data(nodes, location);
    print("[ERROR] ");
    print(NodeLocationData.>file(location_data));
    print(":");
    print_whole_8(NodeLocationData.>row(location_data));
    print(":");
    print_whole_8(NodeLocationData.>column(location_data));
    print(": ");
};

define type_check = function(nodes: *Nodes) {
    variable node_count = Nodes.>index(nodes);

    variable function_arguments_array = autobuffer_new(1024);
    variable function_argument_names_array = autobuffer_new(1024);
    variable function_returns_array = autobuffer_new(1024);

    variable function_arguments_map = hashmap_new(1024);
    variable function_argument_names_map = hashmap_new(1024);
    variable function_returns_map = hashmap_new(1024);

    variable globals_map = hashmap_new(512);
    variable globals_array = autobuffer_new(512);

    variable defines_map = hashmap_new(512);

    variable define_values_map = hashmap_new(512);

    variable structure_members_array = autobuffer_new(1024);
    variable structure_member_names_array = autobuffer_new(1024);

    variable has_main = false;

    variable function_id = 0;

    variable define_function_index = 0;
    variable define_structure_index = 0;
    variable define_global_index = 0;
    
    variable i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            variable function_data = NodeFunctionData.*cast(pointer_data);
            variable function_name = NodeFunctionData.>name(function_data);
            
            if !(=(function_name, 0)) {
                variable function_index_found = hashmap_string_get(&(function_arguments_map), function_name);
                if &&(!(=(function_index_found, 0)), !(string_length=(function_name, "structure[", 10))) {
                    print_node_error_beginning(nodes, i);
                    print("Function '");
                    print(function_name);
                    println("' already defined");
                    exit(1);
                };

                if string=(function_name, "main") {
                    has_main = true;
                };

                hashmap_string_put(&(function_arguments_map), function_name, NodeFunctionData.>argument_types(function_data));
                hashmap_string_put(&(function_argument_names_map), function_name, NodeFunctionData.>argument_names(function_data));
                hashmap_string_put(&(function_returns_map), function_name, NodeFunctionData.>returns(function_data));
            } else {
                autobuffer_array8_set(&(function_arguments_array), function_id, NodeFunctionData.>argument_types(function_data));
                autobuffer_array8_set(&(function_argument_names_array), function_id, NodeFunctionData.>argument_names(function_data));
                autobuffer_array8_set(&(function_returns_array), function_id, NodeFunctionData.>returns(function_data));
                function_id = +(function_id, 1);
            };
        };

        if =(id, NODE_STRUCTURE) {
            variable structure_data = NodeStructureData.*cast(pointer_data);

            if =(NodeStructureData.>name(structure_data), 0) {
                autobuffer_array8_set(&(structure_members_array), define_structure_index, NodeStructureData.>item_types(structure_data));
                autobuffer_array8_set(&(structure_member_names_array), define_structure_index, NodeStructureData.>item_names(structure_data));
                define_structure_index = +(define_structure_index, 1);
            };
        };

        if =(id, NODE_GLOBAL) {
            variable global_data = NodeGlobalData.*cast(pointer_data);
            variable global_name = NodeGlobalData.>name(global_data);
            variable global_type = NodeGlobalData.>type(global_data);

            if !(=(global_name, 0)) {
                hashmap_string_put(&(globals_map), global_name, global_type);
            } else {
                autobuffer_array8_set(&(globals_array), define_global_index, global_type);
                define_global_index = +(define_global_index, 1);
            };
        };

        if =(id, NODE_DEFINE) {
            variable define_data = NodeDefineData.*cast(pointer_data);
            variable define_name = NodeDefineData.>name(define_data);
            variable define_type = NodeDefineData.>type(define_data);

            hashmap_string_put(&(defines_map), define_name, define_type);

            if &&(string=(define_name, "main"), string_length=(define_type, "*function[", 10)) {
                has_main = true;
            };

            variable define_value: any_8;
            if string_length=(define_type, "*function", 9) {
                define_value = define_function_index;
            } else if string_length=(define_type, "structure", 9) {
                define_value = define_structure_index;
            } else if string_length=(define_type, "global", 6) {
                define_value = define_global_index;
            } else {
                define_value = NodeNumberData.>value(NodeNumberData.*cast(nodes_get_pointer_data(nodes, +(i, 1))));
            };

            hashmap_string_put(&(define_values_map), define_name, define_value);
        };

        i = +(i, 1);
    };

    if !(has_main) {
        println("[ERROR] No 'main' function defined");
        exit(1);
    };

    variable current_function: *;
    variable current_function_id: whole_8;

    variable variable_scopes_types_map = autobuffer_new(64);
    variable variable_scope_types_pointer = 0;
    variable variable_scopes_declares_map = autobuffer_new(64);
    variable variable_scope_declares_pointer = 0;

    variable stack = autobuffer_new(64);
    variable stack_pointer = 0;

    variable scopes = autobuffer_new(64);
    variable scope_pointer = 0;

    variable if_blocks = autobuffer_new(64);
    variable if_block_pointer = 0;

    variable if_block_results = autobuffer_new(64);

    function_id = 0;

    i = 0;
    while <(i, node_count) {
        variable id = nodes_get_id(nodes, i);
        variable pointer_data = nodes_get_pointer_data(nodes, i);

        if =(id, NODE_FUNCTION) {
            current_function = NodeFunctionData.>name(NodeFunctionData.*cast(pointer_data));

            if =(current_function, 0) {
                current_function_id = function_id;
                function_id = +(function_id, 1);
            };

            stack_pointer = 0;
        } else if =(id, NODE_NUMBER) {
            variable number_data = NodeNumberData.*cast(pointer_data);

            variable number_type = autobuffer_new(16);
            variable number_type_index = 0;

            if =(NodeNumberData.>type(number_data), 0) {
                autobuffer_push_string(&(number_type), &(number_type_index), "whole_");
            } else {
                autobuffer_push_string(&(number_type), &(number_type_index), "integer_");
            };

            autobuffer_string_push_whole_8(&(number_type), &(number_type_index), NodeNumberData.>size(number_data));

            autobuffer_stack8_push(&(stack), &(stack_pointer), AutoBuffer.>buffer(&(number_type)));
        } else if =(id, NODE_BOOLEAN) {
            autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");
        } else if =(id, NODE_STRING) {
            autobuffer_stack8_push(&(stack), &(stack_pointer), "*");
        } else if =(id, NODE_INVOKE) {
            variable invoke_data = NodeInvokeData.*cast(pointer_data);
            variable has_specifier = NodeInvokeData.>has_specifier(invoke_data);
            variable function_name = NodeInvokeData.>name(invoke_data);

            if &&(!(has_specifier), string_length=(function_name, "@cast_", 6)) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    println("Cast ran out of stack values");
                    exit(1);
                };

                variable popped = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable to_push = *.cast(+(function_name, 6));

                if !(=(get_size_linux_x86-643(popped, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(to_push, nodes, define_values_map, structure_members_array))) {
                    print_node_error_beginning(nodes, i);
                    print("Cast wants equal sized types, given '");
                    print(popped);
                    print("' and casts to '");
                    print(to_push);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), to_push);
            } else if &&(!(has_specifier), string=(function_name, "+")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '+' ran out of stack values");
                    exit(1);
                };

                variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                // removed signdness check -- probably need to add it back
                if !(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '+' wants matching arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "+_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "-")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '-' ran out of stack values");
                    exit(1);
                };

                variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if !(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '-' wants matching arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "-_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "*")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '*' ran out of stack values");
                    exit(1);
                };

                variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if !(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '*' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "*_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "/")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '/' ran out of stack values");
                    exit(1);
                };

                variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if !(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '/' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "/_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "%")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '%' ran out of stack values");
                    exit(1);
                };

                variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if !(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '%' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "%_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "=")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '=' ran out of stack values");
                    exit(1);
                };

                variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if !(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '=' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "=_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, ">")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '>' ran out of stack values");
                    exit(1);
                };

                variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if !(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '>' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), ">_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
            } else if &&(!(has_specifier), string=(function_name, "<")) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '<' ran out of stack values");
                    exit(1);
                };

                variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if !(=(get_size_linux_x86-643(first, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(second, nodes, define_values_map, structure_members_array))) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke of '<' has incompatable arguments, given '");
                    print(first);
                    print("' and '");
                    print(second);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                variable new_+_name = autobuffer_new(16);
                autobuffer_set(&(new_+_name), "<_", 0, 2);
                autobuffer_set(&(new_+_name), first, 2, length(first));

                NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
            } else if &&(has_specifier, |(string=(function_name, "cast"), string=(function_name, "*cast"))) {
                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    println("Cast ran out of stack values");
                    exit(1);
                };

                variable to_push = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if string=(function_name, "*cast") {
                    variable new_to_push = brk_allocate(+(length(to_push), 2));
                    copy("*", new_to_push, 1);
                    copy(to_push, +(new_to_push, 1), length(to_push));
                    to_push = new_to_push;
                };

                variable popped = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                if !(=(get_size_linux_x86-643(popped, nodes, define_values_map, structure_members_array), get_size_linux_x86-643(to_push, nodes, define_values_map, structure_members_array))) {
                    print_node_error_beginning(nodes, i);
                    print("Cast wants equal sized types, given '");
                    print(popped);
                    print("' and casts to '");
                    print(to_push);
                    println("'");
                    exit(1);
                };

                autobuffer_stack8_push(&(stack), &(stack_pointer), to_push);

                variable previous = whole_8.*cast(nodes_get_pointer(nodes, -(i, 1)));
                whole_8.<(previous, NODE_SKIP);
            } else {
                variable found_function = false;

                if has_specifier {
                    variable popped = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                    variable function_name_new = brk_allocate(+(+(length(popped), length(function_name)), 1));
                    copy(popped, function_name_new, length(popped));
                    copy(function_name, +(function_name_new, length(popped)), length(function_name));

                    function_name = function_name_new;
                    NodeInvokeData.<name(invoke_data, function_name);
                    NodeInvokeData.<has_specifier(invoke_data, false);

                    variable previous = whole_8.*cast(nodes_get_pointer(nodes, -(i, 1)));
                    whole_8.<(previous, NODE_SKIP);
                };

                if =(hashmap_string_get(&(function_arguments_map), function_name), 0) {
                    print_node_error_beginning(nodes, i);
                    print("Invoke target '");
                    print(function_name);
                    println("' not found");
                    exit(1);
                };

                variable arguments = *.cast(hashmap_string_get(&(function_arguments_map), function_name));
                variable returns = *.cast(hashmap_string_get(&(function_returns_map), function_name));

                variable length = array8_length(arguments);
                variable k = 0;
                while <(k, length) {
                    if =(stack_pointer, 0) {
                        print_node_error_beginning(nodes, i);
                        print("Invoke of '");
                        print(function_name);
                        println("' ran out of stack values");
                        exit(1);
                    };

                    variable given = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                    variable wanted = *.cast(array8_get(arguments, -(-(length, k), 1)));
                    if !(is_type(wanted, given, nodes, defines_map, structure_members_array)) {
                        print_node_error_beginning(nodes, i);
                        print("Invoke of '");
                        print(function_name);
                        print("' wants '");
                        print(wanted);
                        print("', given '");
                        print(given);
                        println("'");
                        exit(1);
                    };

                    k = +(k, 1);
                };

                variable k = 0;
                while !(=(array8_get(returns, k), 0)) {
                    variable return_value = *.cast(array8_get(returns, k));
                    autobuffer_stack8_push(&(stack), &(stack_pointer), return_value);

                    k = +(k, 1);
                };
            };
        } else if =(id, NODE_DECLARE) {
            variable declare_data = NodeDeclareData.*cast(pointer_data);
            variable variable_name = NodeDeclareData.>name(declare_data);
            variable variable_type = NodeDeclareData.>type(declare_data);

            hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), -(variable_scope_types_pointer, 1))), variable_name, variable_type);
            hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_declares_map), -(variable_scope_declares_pointer, 1))), variable_name, i);
        } else if =(id, NODE_ASSIGN) {
            variable assign_data = NodeAssignData.*cast(pointer_data);
            variable variable_name = NodeAssignData.>name(assign_data);

            variable scope_index = -(variable_scope_types_pointer, 1);
            variable variable_type = *.cast(0);
            while &&(=(variable_type, 0), <(scope_index, variable_scope_types_pointer)) {
                variable_type = *.cast(hashmap_string_get(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name));
                scope_index = -(scope_index, 1);
            };
            scope_index = +(scope_index, 1);

            if =(stack_pointer, 0) {
                print_node_error_beginning(nodes, i);
                println("Assign ran out of stack values");
                exit(1);
            };

            variable popped_stack = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

            if !(=(variable_type, 0)) {
                if string=(variable_type, "") {
                    variable_type = popped_stack;

                    hashmap_string_put(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name, popped_stack);

                    variable variable_declare3 = hashmap_string_get(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_declares_map), scope_index)), variable_name);
                    variable variable_declare4 = NodeDeclareData.*cast(nodes_get_pointer_data(nodes, whole_8.cast(variable_declare3)));
                    NodeDeclareData.<type(variable_declare4, variable_type);
                };

                if !(is_type(variable_type, popped_stack, nodes, defines_map, structure_members_array)) {
                    print_node_error_beginning(nodes, i);
                    print("Assign of ");
                    print(variable_name);
                    print(" wants '");
                    print(variable_type);
                    print("', given '");
                    print(popped_stack);
                    println("'");
                    exit(1);
                };
            } else {
                variable_type = *.cast(hashmap_string_get(&(globals_map), variable_name));

                if =(variable_type, 0) {
                    variable global_id = whole_8.cast(hashmap_string_get2(&(define_values_map), variable_name));
                    if !(=(global_id, 999)) {
                        variable_type = *.cast(autobuffer_array8_get(&(globals_array), global_id));
                    };
                };

                if !(=(variable_type, 0)) {
                    if !(is_type(variable_type, popped_stack, nodes, defines_map, structure_members_array)) {
                        print_node_error_beginning(nodes, i);
                        print("Assign of ");
                        print(variable_name);
                        print(" wants '");
                        print(variable_type);
                        print("', given '");
                        print(popped_stack);
                        println("'");
                        exit(1);
                    };
                } else {
                    print_node_error_beginning(nodes, i);
                    print("Assign target '");
                    print(variable_name);
                    println("' not found");
                    exit(1);
                };
            };
        } else if =(id, NODE_RETRIEVE) {
            variable variable_name = NodeRetrieveData.>name(NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, i)));

            if &&(string_length=(variable_name, "any_", 4), &&(=(nodes_get_id(nodes, +(i, 1)), NODE_INVOKE), NodeInvokeData.>has_specifier(NodeInvokeData.*cast(nodes_get_pointer_data(nodes, +(i, 1)))))) {
                autobuffer_stack8_push(&(stack), &(stack_pointer), variable_name);
            } else {
                variable scope_index = -(variable_scope_types_pointer, 1);
                variable variable_type = *.cast(0);
                while &&(=(variable_type, 0), <(scope_index, variable_scope_types_pointer)) {
                    variable_type = *.cast(hashmap_string_get(HashMap.*cast(autobuffer_array8_get(&(variable_scopes_types_map), scope_index)), variable_name));
                    scope_index = -(scope_index, 1);
                };
                scope_index = +(scope_index, 1);

                if !(=(variable_type, 0)) {
                    autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
                } else {
                    variable function_argument_names2 = *.cast(if =(current_function, 0) { autobuffer_array8_get(&(function_argument_names_array), current_function_id) } else { hashmap_string_get(&(function_argument_names_map), current_function) });
                    variable function_arguments2 = *.cast(if =(current_function, 0) { autobuffer_array8_get(&(function_arguments_array), current_function_id) } else { hashmap_string_get(&(function_arguments_map), current_function) });

                    variable_type = stringarray_get(function_argument_names2, function_arguments2, variable_name, array8_length(function_arguments2));
                    if !(=(variable_type, 0)) {
                        autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
                    } else {
                        variable_type = *.cast(hashmap_string_get(&(globals_map), variable_name));

                        if !(=(variable_type, 0)) {
                            autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
                        } else {
                            variable_type = *.cast(hashmap_string_get(&(defines_map), variable_name));

                            if !(=(variable_type, 0)) {
                                autobuffer_stack8_push(&(stack), &(stack_pointer), variable_type);
                            } else {
                                if !(=(hashmap_string_get(&(function_arguments_map), variable_name), 0)) {
                                    variable function_type_buffer = autobuffer_new(64);
                                    variable function_type_buffer_index = 0;

                                    autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), "*function[");
                                    variable function_arguments2 = *.cast(hashmap_string_get(&(function_arguments_map), variable_name));
                                    variable j = 0;
                                    while !(=(array8_get(function_arguments2, j), 0)) {
                                        variable function_argument = *.cast(array8_get(function_arguments2, j));
                                        autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), function_argument);
                                        autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), ",");
                                        j = +(j, 1);
                                    };
                                    if >(j, 0) {
                                        function_type_buffer_index = -(function_type_buffer_index, 1);
                                    };

                                    autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), ":");

                                    variable function_returns2 = *.cast(hashmap_string_get(&(function_returns_map), variable_name));
                                    variable j = 0;
                                    while !(=(array8_get(function_returns2, j), 0)) {
                                        variable function_return = *.cast(array8_get(function_returns2, j));
                                        autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), function_return);
                                        autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), ",");
                                        j = +(j, 1);
                                    };
                                    if >(j, 0) {
                                        function_type_buffer_index = -(function_type_buffer_index, 1);
                                    };

                                    autobuffer_push_string(&(function_type_buffer), &(function_type_buffer_index), "]");
                                    autobuffer_stack8_push(&(stack), &(stack_pointer), AutoBuffer.>buffer(&(function_type_buffer)));
                                } else {
                                    if string=(variable_name, "&") {
                                        autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_&");
                                    } else if string=(variable_name, "+") {
                                        autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_+");
                                    } else if string=(variable_name, "-") {
                                        autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_-");
                                    } else if string=(variable_name, "*") {
                                        autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_*");
                                    } else if string=(variable_name, "/") {
                                        autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_/");
                                    } else if string=(variable_name, "%") {
                                        autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_%");
                                    } else if string=(variable_name, "=") {
                                        autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_=");
                                    } else if string=(variable_name, ">") {
                                        autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_>");
                                    } else if string=(variable_name, "<") {
                                        autobuffer_stack8_push(&(stack), &(stack_pointer), "*function_<");
                                    } else {
                                        print_node_error_beginning(nodes, i);
                                        print("Retrieve target '");
                                        print(variable_name);
                                        println("' not found");
                                        exit(1);
                                    };
                                };
                            };
                        };
                    };
                };
            };
        } else if =(id, NODE_RETURN) {
            variable function_returns2 = *.cast(if =(current_function, 0) { autobuffer_array8_get(&(function_returns_array), current_function_id) } else { hashmap_string_get(&(function_returns_map), current_function) });

            variable temp = array8_length(function_returns2);
            variable j = -(temp, 1);
            while <(j, temp) {
                variable function_return = *.cast(array8_get(function_returns2, j));

                if =(stack_pointer, 0) {
                    print_node_error_beginning(nodes, i);
                    println("Return ran out of stack values");
                    exit(1);
                };

                variable stack_popped = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                
                if !(is_type(function_return, stack_popped, nodes, defines_map, structure_members_array)) {
                    print_node_error_beginning(nodes, i);
                    print("Return wants '");
                    print(function_return);
                    print("', given '");
                    print(stack_popped);
                    println("'");
                    exit(1);
                };

                j = -(j, 1);
            };

            if !(=(stack_pointer, 0)) {
                print_node_error_beginning(nodes, i);
                println("Return has extra stack values");
                exit(1);
            };
        } else if =(id, NODE_POINTER) {
            if =(stack_pointer, 0) {
                print_node_error_beginning(nodes, i);
                println("Pointer ran out of stack values");
                exit(1);
            };

            variable popped = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
            variable allocated = brk_allocate(+(length(popped), 2));
            copy("*", allocated, 1);
            copy(popped, *.cast(+(allocated, 1)), length(popped));
            autobuffer_stack8_push(&(stack), &(stack_pointer), allocated);
        } else if =(id, NODE_JUMP_CONDITIONAL) {
            if =(stack_pointer, 0) {
                print_node_error_beginning(nodes, i);
                println("Conditional jump ran out of stack values");
                exit(1);
            };

            variable popped = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
            if !(string=(popped, "boolean")) {
                print_node_error_beginning(nodes, i);
                print("Conditional Jump (if/while) wants 'boolean', given '");
                print(popped);
                println("'");
                exit(1);
            };
        } else if =(id, NODE_SCOPE) {
            variable new_hashmap = hashmap_new(512);
            variable allocated = brk_allocate(24);
            HashMap.<(HashMap.*cast(allocated), new_hashmap);
            autobuffer_stack8_push(&(variable_scopes_types_map), &(variable_scope_types_pointer), allocated);

            variable new_hashmap = hashmap_new(512);
            variable allocated = brk_allocate(24);
            HashMap.<(HashMap.*cast(allocated), new_hashmap);
            autobuffer_stack8_push(&(variable_scopes_declares_map), &(variable_scope_declares_pointer), allocated);
        } else if =(id, NODE_ENDSCOPE) {
            variable _ = autobuffer_stack8_pop(&(variable_scopes_types_map), &(variable_scope_types_pointer));
            variable _ = autobuffer_stack8_pop(&(variable_scopes_declares_map), &(variable_scope_declares_pointer));
        } else if =(id, NODE_STARTIFBLOCK) {
            autobuffer_stack8_push(&(if_blocks), &(if_block_pointer), stack_pointer);
        } else if =(id, NODE_ENDIFBLOCK) {
            variable end_if_id = NodeEndIfBlockData.>id(NodeEndIfBlockData.*cast(pointer_data));
            variable start_stack = whole_8.cast(autobuffer_stack8_pop(&(if_blocks), &(if_block_pointer)));
            variable previous_results = *.cast(autobuffer_array8_get(&(if_block_results), end_if_id));
            
            variable size = *(8, -(stack_pointer, start_stack));
            if =(previous_results, 0) {
                previous_results = brk_allocate(+(8, size));
                variable array = autobuffer_get_size(&(stack), *(8, start_stack), size);
                copy(array, previous_results, size);

                autobuffer_array8_set(&(if_block_results), end_if_id, previous_results);
            } else {
                variable array = autobuffer_get_size(&(stack), *(8, start_stack), size);
                variable previous_array = previous_results;

                variable max_size = size;
                if >(*(array8_length(previous_array), 8), size) {
                    size = *(array8_length(previous_array), 8);
                };

                variable j = 0;
                while <(j, /(size, 8)) {
                    variable previous_value = *.cast(array8_get(previous_array, j));
                    variable value = *.cast(array8_get(array, j));

                    variable error = false;

                    if =(value, 0) {
                        error = true;
                    } else if =(previous_value, 0) {
                        error = true;
                    } else if !(string=(value, previous_value)) {
                        error = true;
                    } else {
                        variable _ = autobuffer_stack8_pop(&(stack), &(stack_pointer));
                    };

                    if error {
                        print_node_error_beginning(nodes, i);
                        println("If does not have matching branch results");
                        exit(1);
                    };

                    j = +(j, 1);
                };
            };
        } else if =(id, NODE_INVOKE_POINTER) {
            variable function_type = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

            if string_length=(function_type, "*function_", 10) {
                variable function_name = +(function_type, 10);
                if string=(function_name, "&") {
                    variable popped = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                    variable allocated = brk_allocate(+(length(popped), 2));
                    copy("*", allocated, 1);
                    copy(popped, *.cast(+(allocated, 1)), length(popped));
                    autobuffer_stack8_push(&(stack), &(stack_pointer), allocated);

                    NodeInvokePointerData.<ignore(NodeInvokePointerData.*cast(pointer_data), true);
                };// else if string=(function_name, "+") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '+' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '+' wants matching arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "+_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
                //} else if string=(function_name, "-") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '-' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '-' wants matching arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "-_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
                //} else if string=(function_name, "*") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '*' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '*' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "*_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
                //} else if string=(function_name, "/") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '/' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '/' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "/_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
                //} else if string=(function_name, "%") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '%' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '%' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), second);

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "%_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
                //} else if string=(function_name, "=") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '=' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '=' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "=_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
                //} else if string=(function_name, ">") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '>' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '>' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), ">_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
                //} else if string=(function_name, "<") {
                //    if =(stack_pointer, 0) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '<' ran out of stack values");
                //        exit(1);
                //    };

                //    variable first = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                //    variable second = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));

                //    if |(!(=(get_size_linux_x86-642(first, nodes), get_size_linux_x86-642(second, nodes))), !(=(is_signed(first, nodes), is_signed(second, nodes)))) {
                //        print_node_error_beginning(nodes, i);
                //        print("Invoke of '<' has incompatable arguments, given '");
                //        print(first);
                //        print("' and '");
                //        print(second);
                //        println("'");
                //        exit(1);
                //    };

                //    autobuffer_stack8_push(&(stack), &(stack_pointer), "boolean");

                //    variable new_+_name = autobuffer_new(16);
                //    autobuffer_set(&(new_+_name), "<_", 0, 2);
                //    autobuffer_set(&(new_+_name), first, 2, length(first));

                //    NodeInvokeData.<name(invoke_data, AutoBuffer.>buffer(&(new_+_name)));
                //};
            } else {
                if string_length=(function_type, "*function[", 10) {
                    variable current_argument_buffer = autobuffer_new(64);
                    variable current_argument_buffer_index = 0;

                    variable arguments_buffer = autobuffer_new(64);
                    variable arguments_buffer_index = 0;

                    variable inner = 0;
                    variable j = 10;
                    while |(!(=(whole_1.>(whole_1.*cast(+(function_type, j))), 58_whole_1)), >(inner, 0)) {
                        variable character = whole_1.>(whole_1.*cast(+(function_type, j)));
                        if &&(|(=(character, 93_whole_1), =(character, 44_whole_1)), =(inner, 0)) {
                            autobuffer_array8_set(&(arguments_buffer), arguments_buffer_index, AutoBuffer.>buffer(&(current_argument_buffer)));
                            arguments_buffer_index = +(arguments_buffer_index, 1);

                            current_argument_buffer = autobuffer_new(64);
                            current_argument_buffer_index = 0;
                        } else {
                            autobuffer_push_whole_1(&(current_argument_buffer), &(current_argument_buffer_index), character);
                        };

                        if =(character, 91_whole_1) {
                            inner = +(inner, 1);
                        } else if =(character, 93_whole_1) {
                            inner = -(inner, 1);
                        };
                        j = +(j, 1);
                    };
                    if >(length(AutoBuffer.>buffer(&(current_argument_buffer))), 0) {
                        autobuffer_array8_set(&(arguments_buffer), arguments_buffer_index, AutoBuffer.>buffer(&(current_argument_buffer)));
                        arguments_buffer_index = +(arguments_buffer_index, 1);
                    };

                    variable k = integer_8.cast(arguments_buffer_index);
                    while >(k, 0_integer_8) {
                        k = -(k, 1_integer_8);

                        if =(stack_pointer, 0) {
                            print_node_error_beginning(nodes, i);
                            print("Invoke of '");
                            if =(nodes_get_id(nodes, -(i, 1)), NODE_RETRIEVE) {
                                variable previous_node_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(i, 1)));
                                print(NodeRetrieveData.>name(previous_node_data));
                            } else {
                                print("unknown");
                            };
                            println("' ran out of stack values");
                            exit(1);
                        };

                        variable given = *.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer)));
                        variable wanted = *.cast(autobuffer_array8_get(&(arguments_buffer), whole_8.cast(k)));

                        if !(is_type(wanted, given, nodes, defines_map, structure_members_array)) {
                            print_node_error_beginning(nodes, i);
                            print("Invoke of '");

                            if =(nodes_get_id(nodes, -(i, 1)), NODE_RETRIEVE) {
                                variable previous_node_data = NodeRetrieveData.*cast(nodes_get_pointer_data(nodes, -(i, 1)));
                                print(NodeRetrieveData.>name(previous_node_data));
                            } else {
                                print("unknown");
                            };

                            print("' wants '");
                            print(wanted);
                            print("', given '");
                            print(given);
                            println("'");
                            exit(1);
                        };
                    };

                    inner = 0;
                    current_argument_buffer = autobuffer_new(64);
                    current_argument_buffer_index = 0;

                    j = +(j, 1);

                    while |(!(=(whole_1.>(whole_1.*cast(+(function_type, j))), ASCII_CLOSED_BRACKET)), >(inner, 0)) {
                        variable character = whole_1.>(whole_1.*cast(+(function_type, j)));
                        if &&(|(=(character, ASCII_COLON), =(character, ASCII_COMMA)), =(inner, 0)) {
                            variable return_ = AutoBuffer.>buffer(&(current_argument_buffer));
                            autobuffer_stack8_push(&(stack), &(stack_pointer), return_);

                            current_argument_buffer = autobuffer_new(64);
                            current_argument_buffer_index = 0;
                        } else {
                            autobuffer_push_whole_1(&(current_argument_buffer), &(current_argument_buffer_index), character);
                        };

                        if =(character, ASCII_OPEN_BRACKET) {
                            inner = +(inner, 1);
                        } else if =(character, ASCII_CLOSED_BRACKET) {
                            inner = -(inner, 1);
                        };
                        j = +(j, 1);
                    };

                    if >(length(AutoBuffer.>buffer(&(current_argument_buffer))), 0) {
                        autobuffer_stack8_push(&(stack), &(stack_pointer), AutoBuffer.>buffer(&(current_argument_buffer)));
                    };
                } else {
                    print_node_error_beginning(nodes, i);
                    print("Attempting to invoke non function pointer '");
                    print(function_type);
                    println("'");
                    exit(1);
                };
            };

        } else if =(id, NODE_JUMP) {
        } else if =(id, NODE_TARGET) {
        } else if =(id, NODE_ENDFUNCTION) {
            current_function = *.cast(0);
        } else if =(id, NODE_STRUCTURE) {
        } else if =(id, NODE_GLOBAL) {
        } else if =(id, NODE_DEFINE) {
        } else if =(id, NODE_ENDDEFINE) {
        } else if =(id, NODE_SKIP) {
        } else if =(id, NODE_ENDSTATEMENT) {
            if !(=(stack_pointer, 0)) {
                print_node_error_beginning(nodes, i);
                println("Statement end has extra stack values");
                while !(=(stack_pointer, 0)) {
                    println(*.cast(autobuffer_stack8_pop(&(stack), &(stack_pointer))));
                };
                exit(1);

            };
        } else {
            print("Unhandled ");
            print_whole_8(id);
            println("");
        };

        i = +(i, 1);
    };
};
